<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhong Kangwei&#39;s Blog</title>
  
  <subtitle>Learn and Live.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-13T08:40:01.385Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zhong Kangwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO读写</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/IO%E8%AF%BB%E5%86%99/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/IO%E8%AF%BB%E5%86%99/</id>
    <published>2022-03-13T08:36:18.000Z</published>
    <updated>2022-03-13T08:40:01.385Z</updated>
    
    <content type="html"><![CDATA[<p>系统调用中的一些文件处理方式。</p><span id="more"></span><h3 id="I-O读写"><a href="#I-O读写" class="headerlink" title="I/O读写"></a>I/O读写</h3><p>【系统调用中的文件处理，而不是库函数】</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>打开已有的文件</p></li><li><p>如果打开失败，返回-1</p></li><li><p>如果打开成功，返回值&gt;=0，作为被打开文件的标识符，该整数被称为文件描述符</p></li></ul></li><li><p>参数</p><ul><li><p><code>pathname</code>，指定文件路径</p></li><li><p><code>flags</code>, 指定打开参数，可选的取值如下</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>O_RDONLY</th><th>以只读方式打开</th></tr></thead><tbody><tr><td>O_WRONLY</td><td>以只写方式打开</td></tr><tr><td>O_RDWR</td><td>以读写方式打开</td></tr><tr><td>O_APPEND</td><td>以追加模式打开，写文件时将内容追加文件末尾</td></tr><tr><td>O_TRUNC</td><td>如果文件存在，将文件的长度截断为0</td></tr><tr><td>O_CREAT</td><td>如果文件不存在，创建一个新文件</td></tr></tbody></table></div><ul><li><code>flags</code>的取值可以用<strong>位或</strong>的方式进行组合<ul><li><code>open(&quot;log.txt&quot;, O_RDWR | O_TRUNC);</code></li></ul></li></ul><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>如果文件存在，则打开文件；如果文件不存在，则创建文件</p></li><li><p><code>creat(path, mode)</code>和<code>open(path, O_CREAT|O_WRONLY|O_TRUNC, mode)</code>等价</p></li></ul></li><li><p>返回值</p><ul><li><p>如果创建失败，返回-1</p></li><li><p>如果创建成功，返回值&gt;=0，作为被创建文件的标识符，该整数被称为<strong>文件描述符</strong></p></li></ul></li><li><p>参数</p><ul><li><p><code>pathname</code>，指定文件路径</p></li><li><p><code>flags</code>, 指定打开参数，可选的取值与open相同</p></li><li><p><code>mode</code>, 新建文件的访问模式</p></li></ul></li></ul><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>将打开的文件关闭</p></li><li><p>操作系统需要为打开的文件分配资源，需要及时关闭不再使用的文件，从而<strong>释放相应资源</strong></p></li></ul></li><li><p>参数</p><ul><li>fd，使用open或者creat打开的<strong>文件描述符</strong></li></ul></li></ul><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>从打开的文件中读取数据到<strong>内存缓冲区</strong></p></li><li><p>如果读取失败，返回-1</p></li><li><p>如果读取成功，返回实际读取的字节个数；返回0则代表读取到了文件末尾</p></li></ul></li><li><p>参数</p><ul><li><p>fd, 使用open或者creat打开的文件描述符</p></li><li><p>buf, 内存缓冲区的起始位置</p></li><li><p>count, 内存缓冲区的长度，read的返回值<strong>小于等于</strong>count</p></li></ul></li></ul><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>把内存缓冲区的数据写入到打开的文件</p></li><li><p>如果写入失败，返回-1</p></li><li><p>如果写入成功，返回实际写入的<strong>字节个数</strong></p></li></ul></li><li><p>参数</p><ul><li><p>fd, 使用open或者creat打开的文件描述符</p></li><li><p>buf, 内存缓冲区的起始位置</p></li><li><p>count, 内存缓冲区的长度，write的返回值小于等于count</p></li></ul></li></ul><h4 id="定位文件"><a href="#定位文件" class="headerlink" title="定位文件"></a>定位文件</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>调整文件的访问位置</p></li><li><p>read和write从文件的访问位置读写文件</p></li></ul></li><li><p>参数</p><ul><li><p>fd, 使用open或者creat打开的文件描述符</p></li><li><p>offset, 相对于whence的位置偏移量</p></li><li><p>whence, 根据offset和whence设置文件访问位置，取值如下</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>SEEK_SET</th><th>文件访问位置 = offset</th></tr></thead><tbody><tr><td>SEEK_CUR</td><td>文件访问位置 = 文件访问位置 + offset</td></tr><tr><td>SEEK_END</td><td>文件访问位置 = 文件尾部位置 + offset</td></tr></tbody></table></div><h4 id="简单数据库"><a href="#简单数据库" class="headerlink" title="简单数据库"></a>简单数据库</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *message)</span> </span><br><span class="line">&#123;</span><br><span class="line">    perror(message);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> &#123;</span><span class="comment">// 描述数据库的记录</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">12</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;<span class="comment">// 用于保存被打开数据库的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">db_open用于打开或者创建一个数据库</span></span><br><span class="line"><span class="comment">mode指定新创建数据库文件的权限</span></span><br><span class="line"><span class="comment">O_RDWR，可以对文件进行读或者写</span></span><br><span class="line"><span class="comment">O_APPEND，文件以追加模式打开，写文件时会把数据追加到文件末尾</span></span><br><span class="line"><span class="comment">O_CREAT，如果文件不存在，则创建该文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">db_open</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mode_t</span> mode = <span class="number">0777</span>;</span><br><span class="line">    fd = open(path, O_RDWR | O_APPEND | O_CREAT, mode);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">db_close</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 关闭数据库</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以O_APPEND作为参数打开的数据库</span></span><br><span class="line"><span class="comment">写文件时，总是将数据追加到文件尾部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">db_append</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> age)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">record</span> <span class="title">record</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(record.name, name);</span><br><span class="line">    record.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = write(fd, &amp;record, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record));</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用lseek设置文件访问位置为offset</span></span><br><span class="line"><span class="comment">根据记录号index，计算记录的偏移量</span></span><br><span class="line"><span class="comment">SEEK_SET表示offset相对于文件头部</span></span><br><span class="line"><span class="comment">调用read在文件的offset位置处读取一条记录</span></span><br><span class="line"><span class="comment">最后，打印第index号记录的name字段和age字段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">db_dump</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;<span class="comment">// 根据记录号index打印数据库中的一条记录</span></span><br><span class="line">    <span class="type">int</span> offset = index * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record);</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">record</span> <span class="title">record</span>;</span></span><br><span class="line">    <span class="type">int</span> count = read(fd, &amp;record, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record));</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record))</span><br><span class="line">        panic(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %6s, age = %d\n&quot;</span>, record.name, record.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    db_open(<span class="string">&quot;my.db&quot;</span>); <span class="comment">// 在当前目录下创建数据库</span></span><br><span class="line">    db_append(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>);<span class="comment">// 添加记录</span></span><br><span class="line">    db_append(<span class="string">&quot;jerry&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    db_append(<span class="string">&quot;mike&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    db_dump(<span class="number">0</span>);<span class="comment">// 打印记录</span></span><br><span class="line">    db_dump(<span class="number">1</span>);</span><br><span class="line">    db_dump(<span class="number">2</span>);</span><br><span class="line">    db_close();<span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cc db.c</span><br><span class="line">$ ./a.out</span><br><span class="line">name =    tom, age = 10</span><br><span class="line">name =  jerry, age = 11</span><br><span class="line">name =   mike, age = 12</span><br></pre></td></tr></table></figure><p>查看目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">-rwxrwxr-x 1 zgw zgw 7824 6月  11 16:34 a.out</span><br><span class="line">-rw-rw-r-- 1 zgw zgw 1180 6月  11 16:21 db.c</span><br><span class="line">-rwxrwxr-x 1 zgw zgw   48 6月  11 16:34 my.db</span><br></pre></td></tr></table></figure><p>每条记录占用16个字节，总共3条条记录，大小为48个字节</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统调用中的一些文件处理方式。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程管理</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-13T08:36:06.000Z</published>
    <updated>2022-03-13T08:42:28.983Z</updated>
    
    <content type="html"><![CDATA[<p>进程的定义、特点，创建进程，删除进程，装入程序，退出进程,等待进程等。</p><span id="more"></span><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p><strong>定义</strong></p><ul><li><p>应用程序关于某数据集合上的一次运行活动</p></li><li><p>操作系统进行资源分配和调度的基本单位</p></li></ul><p><strong>进程是程序的一次执行过程</strong></p><ul><li><p>进程是动态的，程序是静态的</p></li><li><p>同一程序同时运行于若干个数据集合上，该程序将对应与若干个不同的进程</p></li></ul><p><strong>每个进程拥有独立的地址空间</strong></p><ul><li><p>地址空间包括代码段、数据段和堆栈段</p><ul><li><p>代码段，存储程序的代码</p></li><li><p>数据段，存储程序的全局变量和动态分配的内存</p></li><li><p>堆栈段，存储函数运行时的局部变量</p></li></ul></li><li><p>进程之间的地址空间是隔离的</p><ul><li><p>一个进程崩溃不会影响另一个进程</p></li><li><p>一个进程崩溃不会影响到操作系统</p></li></ul></li></ul><h4 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h4><p><strong>进程控制块</strong></p><ul><li>操作系统使用一个结构体记录进程的各类属性，该结构体被称为进程控制块</li></ul><p><strong>进程标识</strong></p><ul><li><p>进程id，每个进程的id都是唯一的</p></li><li><p>父进程id</p></li></ul><p><strong>地址空间</strong></p><ul><li><p>代码段的起始地址和长度</p></li><li><p>数据段的起始地址和长度</p></li><li><p>堆栈段的起始地址和长度</p></li></ul><p><strong>打开文件列表</strong></p><ul><li><p>打开文件时，在打开文件列表中记录被打开文件的信息</p></li><li><p>关闭文件时，在打开文件列表中删除被关闭文件的信息</p></li><li><p>进程终止时，操作系统遍历打开文件列表，将尚未关闭的文件关闭</p></li></ul><h4 id="getpid"><a href="#getpid" class="headerlink" title="getpid"></a>getpid</h4><p><strong>原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能描述</strong></p><ul><li>getpid获取当前进程ID</li><li><p>getppid获取父进程ID</p></li><li><p>pid_t是C语言中用户自定义类型</p><ul><li><p>在sys/types.h中定义</p></li><li><p>typedef int pid_t;</p></li></ul></li></ul><p><strong>举例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %x, ppid = %x\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = <span class="number">4761</span>, ppid = <span class="number">2570</span></span><br></pre></td></tr></table></figure><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><strong>原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li><p>创建一个子进程，父子进程并发运行</p></li><li><p>子进程<strong>复制父进程</strong>的如下属性</p><ul><li><p>代码段、数据段的内容，父子进程拥有相同的代码和数据【代码段一直一样，但是数据段只有一开始一样，后面会各自修改】</p></li><li><p>打开文件列表</p></li></ul></li><li><p>不复制进程的PID属性，父子的进程的PID是唯一的</p></li></ul><p><strong>返回值</strong></p><ul><li><p>pid是进程ID的缩写，pid_t是使用typedef定义的进程ID类型</p></li><li><p>父进程从fork返回处继续执行，在父进程中，fork返回<strong>子进程PID</strong></p></li><li><p>子进程从<strong>fork返回处</strong>开始执行，在子进程中，fork<strong>返回0</strong></p><p>【注意：不是fork返回2次，而是在两个父子进程中fork各返回一次】</p></li></ul><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child process\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent process\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc fork.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>​    输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid = <span class="number">5327</span></span><br><span class="line">In parent process</span><br><span class="line">pid = <span class="number">0</span></span><br><span class="line">In child process</span><br></pre></td></tr></table></figure><p><strong>解释：为什么if-else都会执行？</strong></p><ul><li>每个进程都有一个独立的地址空间</li></ul><p><strong>父进程：</strong></p><ul><li><p>父进程地址空间的代码和数据为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, pid); </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child process\n&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent process\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父进程执行fork函数时创建新的子进程</p></li><li><p>父进程执行完<code>fork()</code>后返回的是子进程PID，然后打印该PID</p></li><li><p>父进程中<code>pid</code>的值不为0，执行else分支</p></li></ul><p><strong>子进程：</strong></p><ul><li><p>子进程也有一个独立的地址空间</p><ul><li><p>操作系统使用fork创建子进程地址空间</p></li><li><p>把父进程地址空间的代码复制到子进程地址空间中</p></li><li><p>子进程的地址空间与父进程的地址空间的代码相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, pid); </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child process\n&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent process\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>子进程被创建后从<code>fork()</code>返回处开始执行</p></li><li><p>子进程中fork返回值为0，执行print语句，打印pid的值0</p></li><li><p>pid为0，执行then分支中的printf语句</p></li></ul><p><strong>这是由父子进程并发运行导致的</strong></p><ul><li><p>子进程执行then分支</p></li><li><p>父进程执行else分支</p></li></ul><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//包含fork函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork(); </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child:  child  PID = %d, parent PID = %d\n&quot;</span>, getpid(), getppid()); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent: parent PID = %d, child  PID = %d\n&quot;</span>, getpid(), pid); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc fork.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>​    输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In parent: parent PID = <span class="number">9145</span>, child  PID = <span class="number">9146</span></span><br><span class="line">In child:  child  PID = <span class="number">9146</span>, parent PID = <span class="number">9145</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>父进程执行fork()后，返回子进程的PID: 9146</li><li><p>在父进程中</p><ul><li><p>pid的值不为0，因此执行else分支</p></li><li><p>调用<code>getpid()</code>返回的是父进程的PID：9145</p></li><li><p><strong>pid为新创建的子进程</strong>PID：9146</p></li></ul></li><li><p>子进程被创建后，从<strong>fork返回处</strong>开始执行</p><ul><li>在子进程中，fork返回值为0，因此执行then分支</li></ul></li><li>在子进程中<ul><li>调用<code>getpid()</code>返回的是子进程的PID：9146</li><li>调用<code>getppid()</code>返回的是父进程的PID：9145</li></ul></li></ul><h3 id="进程特性"><a href="#进程特性" class="headerlink" title="进程特性"></a>进程特性</h3><h4 id="并发特性"><a href="#并发特性" class="headerlink" title="并发特性"></a>并发特性</h4><ul><li><p>父进程和子进程<strong>并发运行</strong></p><ul><li><p>父进程创建子进程后，父子进程都处于运行状态中</p></li><li><p>两个进程的输出结果是交织在一起的</p></li></ul></li><li><p><strong>两者的代码段内容相同</strong></p><ul><li><p>父进程从fork()返回处执行，fork()返回为子进程的PID</p></li><li><p>子进程从fork()返回处执行，fork()返回0</p></li></ul></li></ul><p><strong>举例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;parent&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        child();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    得到的结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parent</span><br><span class="line">parent</span><br><span class="line">parent</span><br><span class="line">child</span><br><span class="line">child</span><br><span class="line">child</span><br></pre></td></tr></table></figure><p>​    从该输出结果看，父子进程似乎是串行执行的。【Why？分配的时间片足够长，在时间片内足够输出三次】</p><p><strong>改进：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child&quot;</span>); </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">parent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;parent&quot;</span>); </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parent</span><br><span class="line">child</span><br><span class="line">parent</span><br><span class="line">child</span><br><span class="line">parent</span><br><span class="line">child</span><br></pre></td></tr></table></figure><ul><li><p>从输出结果看</p><ul><li><p>父子进程的输出是交织在一起的</p></li><li><p>从而验证，父子进程是<strong>并发执行</strong>的</p></li></ul></li></ul><h4 id="fork的实现细节"><a href="#fork的实现细节" class="headerlink" title="fork的实现细节"></a>fork的实现细节</h4><ul><li><p>操作系统为子进程创建PCB(进程控制块)</p><ul><li><p>把父进程的大部分属性<strong>复制</strong>到子进程的PCB中</p></li><li><p>不复制PID属性，父子进程拥有<strong>不同的PID</strong></p></li></ul></li><li><p>操作系统为子进程创建地址空间</p><ul><li>把父进程的代码和数据<strong>复制</strong>到子进程的地址空间中</li></ul></li></ul><h4 id="隔离特性"><a href="#隔离特性" class="headerlink" title="隔离特性"></a>隔离特性</h4><ul><li><p>进程的地址空间是互相隔离的</p><ul><li>每个进程拥有自己的地址空间</li><li><p>进程<strong>仅能访问自己的地址空间</strong></p></li><li><p>如果出现非法内存访问，仅仅当前进程受到影响</p></li></ul></li><li><p>全局变量</p><ul><li><p>全局变量存在于两个地址空间中，<strong>并非被两个进程共享</strong></p></li><li><p>父进程和子进程访问的是<strong>自己的全局变量</strong>，互相不影响</p></li></ul></li></ul><p><strong>举例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        global++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child, global = %d\n&quot;</span>, global);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        global++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent, global = %d\n&quot;</span>, global);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    child(); </span><br><span class="line">    parent(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In child, global = <span class="number">1</span></span><br><span class="line">In child, global = <span class="number">2</span></span><br><span class="line">In child, global = <span class="number">3</span></span><br><span class="line">In parent, global = <span class="number">4</span></span><br><span class="line">In parent, global = <span class="number">5</span></span><br><span class="line">In parent, global = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>​    该程序是一个单进程程序，函数<code>parent()</code>和函数<code>child()</code>串行执行，两者访问的是相同的变量。</p><p><strong>修改为多进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        global++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child, global = %d\n&quot;</span>, global);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        global++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent, global = %d\n&quot;</span>, global);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        child();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In parent, global = <span class="number">1</span></span><br><span class="line">In child, global = <span class="number">1</span></span><br><span class="line">In parent, global = <span class="number">2</span></span><br><span class="line">In child, global = <span class="number">2</span></span><br><span class="line">In parent, global = <span class="number">3</span></span><br><span class="line">In child, global = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>​    在父子进程中，<strong>各有一份</strong>global变量，global变量存在于两个地址空间中，并非被两个进程共享，父进程和子进程访问的是<strong>自己的global变量</strong>，因此互相不影响。</p><h3 id="装入程序"><a href="#装入程序" class="headerlink" title="装入程序"></a>装入程序</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><ul><li>C程序的main函数原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><p>操作系统将命令行参数传递给main函数</p></li><li><p><code>argc</code>，命令行参数的个数</p></li><li><p><code>argv</code>，命令行参数数组</p></li></ul></li><li><p>例子</p><ul><li><p><code>cp /etc/passwd passwd.bak</code></p></li><li><p><code>argc = 3</code></p></li><li><p><code>argv = &#123;&quot;cp&quot;, &quot;/etc/passwd&quot;, &quot;passwd.bak&quot;&#125;</code></p></li><li><p><strong>命令名也被当作是命令参数</strong>，所以argc != 2</p></li></ul></li></ul><h4 id="命令行演示举例"><a href="#命令行演示举例" class="headerlink" title="命令行演示举例"></a>命令行演示举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印<code>argc</code>和<code>*argv[]</code>的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cc cmd.c</span><br><span class="line">./a.out hello</span><br><span class="line">---------------------------</span><br><span class="line">argc = 2</span><br><span class="line">argv[0] = ./a.out</span><br><span class="line">argv[1] = hello </span><br><span class="line">---------------------------</span><br><span class="line">./a.out a b c</span><br><span class="line">---------------------------</span><br><span class="line">argc = 4</span><br><span class="line">argv[0] = ./a.out</span><br><span class="line">argv[1] = a</span><br><span class="line">argv[2] = b</span><br><span class="line">argv[3] = c</span><br></pre></td></tr></table></figure><h4 id="绝对路径和命令名"><a href="#绝对路径和命令名" class="headerlink" title="绝对路径和命令名"></a>绝对路径和命令名</h4><ul><li><p>装入程序的两种方式</p><ul><li><p>可以输入命令的绝对路径调用程序</p></li><li><p>也可以输入命令的命令名调用程序</p></li></ul></li><li><p>which命令列出一条命令的绝对路径</p><ul><li>```c<h2 id="which-echo"><a href="#which-echo" class="headerlink" title="which echo"></a>which echo</h2>/bin/echo<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    执行结果表明程序<span class="keyword">echo</span>存在于<span class="string">/bin</span>目录下</span><br><span class="line"></span><br><span class="line">- 输入<span class="keyword">echo</span>命令的绝对路径</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">  <span class="string">/bin/echo</span> a b c</span><br><span class="line">  <span class="params">---------------</span></span><br><span class="line">  a b c</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​    echo命令正常执行输出参数a、b、c</p><ul><li><p>打印PATH环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">--------------------</span><br><span class="line">/bin:/usr/bin:/sbin:/usr/sbin</span><br></pre></td></tr></table></figure><p>PATH环境变量中包含<code>/bin</code>目录【PATH格式：目录之间用<strong>冒号</strong>分开！】</p></li><li><p>因此可以直接用<code>echo</code>命令名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo a b c</span><br><span class="line">-------------</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure></li></ul><h4 id="execl-amp-execlp"><a href="#execl-amp-execlp" class="headerlink" title="execl&amp;execlp"></a>execl&amp;execlp</h4><p>用于装入程序</p><p><strong>execl原型：</strong></p><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>将当前进程的地址空间的内容<strong>全部清空</strong></p></li><li><p>将path指定的<strong>可执行程序的代码和数据</strong>装入到当前进程的地址空间</p></li></ul></li><li><p>参数</p><ul><li><p>该函数的参数个数可变</p></li><li><p><strong>最后一个参数必须是NULL</strong></p></li><li><p>第一个参数path指定<strong>被装入程序的路径</strong></p><ul><li><p>可以是命令的绝对路径</p></li><li><p>可以是命令的相对路径</p></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>装入失败后，返回值为-1</p></li><li><p>装入成功后，从被装入程序的<strong>main函数开始执行</strong></p></li></ul></li></ul><p><strong>举例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;before exec&quot;</span>);<span class="comment">// 在执行execl前打印字符串</span></span><br><span class="line">    <span class="type">int</span> error = execl(<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 最后必须为NULL</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">execl系统调用会清空当前地址空间所有内容</span></span><br><span class="line"><span class="comment">将/bin/echo程序的代码和数据装入到当前地址空间中</span></span><br><span class="line"><span class="comment">从echo程序的main函数开始执行</span></span><br><span class="line"><span class="comment">echo程序打印从execl系统调用传递过来的参数</span></span><br><span class="line"><span class="comment">当echo程序执行return返回后</span></span><br><span class="line"><span class="comment">进程调用exit系统调用</span></span><br><span class="line"><span class="comment">进程就结束了</span></span><br><span class="line"><span class="comment">原程序的代码已经完全被替换成echo的代码</span></span><br><span class="line"><span class="comment">因此不会再执行原程序的第二条puts语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)<span class="comment">// 如果execl执行成功，这条打印语句就不会被执行</span></span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;after exec&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc execl.c</span><br><span class="line">./a.out</span><br><span class="line">-------------------</span><br><span class="line">before <span class="built_in">exec</span></span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><p><strong>execlp原型：</strong></p><p>【这里的<code>p</code>代表PATH】</p><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li>与execl相同e</li></ul></li><li><p>execl和execlp的区别</p><ul><li><p>在execl中，第一个参数指定可执行程序的路径</p><ul><li><p>该路径可以是绝对路径</p></li><li><p>该路径可以是相对于当前工作目录的相对路径</p></li></ul></li><li><p>在execlp中，第一个参数指定可执行程序的路径</p><ul><li><p>该路径可以是绝对路径</p></li><li><p>该路径可以是相对于当前工作目录的相对路径</p></li><li>该路径可以是<strong>PATH环境变量</strong>指定目录下的相对路径</li></ul></li></ul></li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;before exec&quot;</span>);</span><br><span class="line">    <span class="type">int</span> error = execl(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;after exec&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc execlp.c</span><br><span class="line">./a.out</span><br><span class="line">before exec</span><br><span class="line">exec: No such file or directory</span><br><span class="line">after exec</span><br></pre></td></tr></table></figure><p>​    找不到该目录；</p><p>​    修改成<code>execlp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> error = execlp(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cc execlp.c</span><br><span class="line">./a.out</span><br><span class="line">before exec</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><p>给出程序echo的相对路径，execlp会在PATH环境变量指定的目录下查找echo，execlp搜索PATH环境变量指定的目录，在PATH环境指定的目录下找到程序echo。</p><h4 id="execv-amp-execvp"><a href="#execv-amp-execvp" class="headerlink" title="execv&amp;execvp"></a>execv&amp;execvp</h4><p><strong>execv原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li>与execl相同</li></ul></li><li><p>参数</p><ul><li>argv指定传递给程序的参数，argv数组的<strong>最后一项必须是NULL指针</strong></li></ul></li><li><p>execl和execv的区别</p><ul><li>execl，函数名execl末尾的<strong>l表示list</strong>，参数以列表的形式传递给可执行程序</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li>execv，函数名execv末尾的v<strong>表示vector</strong>，参数以数组的形式传递给可执行程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;before exec&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">int</span> error = execv(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;after exec&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cc execv.c</span><br><span class="line">$ ./a.out</span><br><span class="line">before <span class="built_in">exec</span></span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><p><strong>execvp原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li>与execv相同</li></ul></li><li><p>execv和execvp的区别</p><ul><li><p>在execv中，第一个参数指定可执行程序的路径</p><ul><li><p>该路径可以是绝对路径</p></li><li><p>该路径可以是相对于当前工作目录的相对路径</p></li></ul></li><li><p>在execvp中，第一个参数指定可执行程序的路径</p><ul><li><p>该路径可以是绝对路径</p></li><li><p>该路径可以是相对于当前工作目录的相对路径</p></li><li><p>该路径可以是<strong>PATH环境变量</strong>指定目录下的相对路径</p></li></ul></li></ul></li></ul><p>（举例和execl基本相同，略）</p><h3 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a>退出进程</h3><h4 id="exit原型"><a href="#exit原型" class="headerlink" title="exit原型"></a>exit原型</h4><ul><li>原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>正常退出当前进程</p></li><li><p>将status &amp; 0xFF作为退出码返回给父进程</p></li></ul></li><li><p>预定义常量</p><ul><li><p><code>EXIT_SUCCESS</code>，为0的数值，表示程序正常退出</p></li><li><p><code>EXIT_FAILURE</code>，为非0的数值，表示程序执行过程发生了错误，异常退出</p></li></ul></li><li><p>在linux shell中，可以通过特殊的环境变量<code>$?</code>获得刚执行程序的退出码</p></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;before exit&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;after exit&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用exit前，打印字符串before exit；调用exit，退出当前进程，退出码为100；调用exit后，打印字符串after exit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cc exit.c</span><br><span class="line">$ ./a.out</span><br><span class="line">before <span class="built_in">exit</span></span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>表明程序仅仅执行了调用exit前的puts语句</p><h4 id="main函数中返回"><a href="#main函数中返回" class="headerlink" title="main函数中返回"></a>main函数中返回</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;before return&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在return前，打印字符串before return</p></li><li><p>从main函数中返回，当前进程就结束了</p><ul><li>main函数返回100，该值即为退出码</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cc return.c</span><br><span class="line">$ ./a.out</span><br><span class="line">before <span class="built_in">return</span></span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">100</span><br></pre></td></tr></table></figure><ul><li><p>通过特殊的环境变量$?获得程序的退出码</p></li><li><p>main函数return 100，因此退出码是100 =&gt;隐式调用<code>exit</code></p></li></ul><h4 id="隐式调用exit"><a href="#隐式调用exit" class="headerlink" title="隐式调用exit"></a>隐式调用exit</h4><p>一个程序开始执行并不是从<code>main()</code>函数开始的，而是从汇编语言的一个特殊函数<code>_start</code>开始的</p><ul><li>函数_start定义在汇编文件<code>start.asm</code>中</li><li><code>start.asm</code>是80x86的汇编语言编写而成的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        global _start</span><br><span class="line">        <span class="keyword">extern</span> main</span><br><span class="line">        <span class="keyword">extern</span> <span class="built_in">exit</span></span><br><span class="line">_start: </span><br><span class="line">        call    main  </span><br><span class="line">        add     esp,</span><br><span class="line">        push    eax </span><br><span class="line">        call    <span class="built_in">exit</span> </span><br><span class="line">        add     esp, <span class="number">4</span></span><br><span class="line">        hlt</span><br></pre></td></tr></table></figure><ul><li>然后跳转到<code>return.c</code>中的main函数开始执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>现在跳转到回start.asm</p><ul><li>main函数的返回值为100</li></ul></li><li><p>在80x86中，call的返回值被存放在寄存器eax中</p></li><li><p>将call的返回值100<strong>压入堆栈</strong>，<strong>作为参数传递给exit</strong></p></li><li><p>通过call指令调用exit</p></li></ul><blockquote><p>尽管在return.c中没有显式调用exit，但是main函数返回上级函数_start后，_start会调用exit结束当前进程</p></blockquote><h4 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h4><ul><li><strong>原型</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p><strong>注册一个回调函数</strong>function，进程正常结束时，function会被调用</p></li><li><p>如果注册多个回调函数，进程结束时，以<strong>与注册相反的顺序</strong>调用回调函数</p></li></ul></li><li><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;f1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;f2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">f3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;f3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">// 使用atexit注册3个回调函数</span></span><br><span class="line">    atexit(f1);</span><br><span class="line">    atexit(f2);</span><br><span class="line">    atexit(f3);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cc atexit.c</span><br><span class="line">$ ./a.out</span><br><span class="line">main</span><br><span class="line">f3</span><br><span class="line">f2</span><br><span class="line">f1</span><br></pre></td></tr></table></figure><ul><li><p>调用注册函数</p><ul><li><p>注册的顺序是f1、f2、f3</p></li><li><p>调用的顺序则<strong>相反</strong>，是f3、f2、f1</p></li></ul></li></ul></li></ul><h3 id="等待进程"><a href="#等待进程" class="headerlink" title="等待进程"></a>等待进程</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li>等待子进程结束【阻塞】</li></ul></li><li><p>参数</p><ul><li>status<ul><li>如果status不为NULL，子进程的退出码保存在status<strong>指向的变量</strong>中</li></ul></li></ul></li></ul><h4 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h4><ul><li><p>进程可能由于不同的原因退出</p><ul><li><p>主动调用exit正常退出</p></li><li><p>接受信号后退出</p></li></ul></li><li><p>查询退出原因的宏</p></li></ul><div class="table-container"><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>WIFEXITED(status)</td><td>如果进程通过调用exit<strong>正常退出</strong>，则返回真</td></tr><tr><td>WEXITSTATUS(status)</td><td>如果进程通过调用exit正常退出，返回进程的<strong>退出码</strong></td></tr><tr><td>WIFSIGNALED(status)</td><td>如果进程接受信号后退出，则返回真</td></tr><tr><td>WTERMSIG(status)</td><td>如果进程接受信号后退出，返回导致进程退出的信号</td></tr></tbody></table></div><h4 id="举例1—基础用法"><a href="#举例1—基础用法" class="headerlink" title="举例1—基础用法"></a>举例1—基础用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Child process&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        child(); </span><br><span class="line">    wait(<span class="literal">NULL</span>);<span class="comment">// 先等子进程执行</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Parent process&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>父进程执行wait函数</p><ul><li><p>当子进程执行完毕后，从wait函数返回</p></li><li><p>wait的参数为NULL，表示忽略子进程的返回码</p></li></ul></li><li><p>等待子进程结束后</p><ul><li>父进程打印字符串”Parent process”</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc wait1.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Child process</span><br><span class="line">Parent process</span><br></pre></td></tr></table></figure><h4 id="举例2—获取子进程的退出码"><a href="#举例2—获取子进程的退出码" class="headerlink" title="举例2—获取子进程的退出码"></a>举例2—获取子进程的退出码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        child(); </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    wait(&amp;status);<span class="comment">// status的地址！！</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WIFEXITED = true\n&quot;</span>); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WEXITSTATUS = %d\n&quot;</span>,  WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>父进程调用wait，等待子进程结束</p><ul><li><p>将变量status的<strong>地址</strong>传递给wait</p></li><li><p>用于接受子进程的退出码</p></li></ul></li><li><p><code>WIFEXITED</code>判断子进程是否是通过调用exit退出的</p></li><li><p><code>WEXITSTATUS</code>打印子进程的退出码</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc wait2.c</span><br><span class="line">$ ./a.out</span><br><span class="line">WIFEXITED = <span class="literal">true</span></span><br><span class="line">WEXITSTATUS = 123</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程的定义、特点，创建进程，删除进程，装入程序，退出进程,等待进程等。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>编译与运行</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/</id>
    <published>2022-03-13T08:35:54.000Z</published>
    <updated>2022-03-13T08:44:52.615Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用gcc工具编译，Linux环境变量，如何写Makefile</p><span id="more"></span><h3 id="Linux编译与运行"><a href="#Linux编译与运行" class="headerlink" title="Linux编译与运行"></a>Linux编译与运行</h3><p>使用gcc工具进行编译，常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc test.c<span class="comment"># 默认生成a.out可执行文件</span></span><br><span class="line">cc -o <span class="built_in">test</span> test.c<span class="comment"># 生成-o后面的参数为名字的可执行文件</span></span><br></pre></td></tr></table></figure><p>编译多文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc -c file1.c</span><br><span class="line">cc -c file2.c</span><br><span class="line">cc -o file file1.o file2.o</span><br><span class="line"><span class="meta"># </span><span class="language-bash">也可以合并</span></span><br><span class="line">cc -o file file1.c file2.c</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test<span class="comment"># ./表示当前目录</span></span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>为什么可以直接找到<code>/bin/ls</code>呢？</p><p>引入了环境变量=&gt;用于设置参数的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH #显示PATH环境变量的值</span><br></pre></td></tr></table></figure><p>输入<code>ls</code>时，在环境变量中一个一个试，直到试到成功的那个为止</p><p>把当前目录加入环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=.:/bin:/usr/bin</span><br></pre></td></tr></table></figure><p>为什么不把<code>.</code>加入PATH？</p><p>牵扯到用户和权限的问题，PATH环境变量中的目录必须是可信的</p><h4 id="Make-amp-Makefile"><a href="#Make-amp-Makefile" class="headerlink" title="Make&amp;Makefile"></a>Make&amp;Makefile</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc - c main.c</span><br><span class="line">cc - c print.c</span><br><span class="line">cc -o exe main.o print.o</span><br></pre></td></tr></table></figure><p>如果修改了<code>print .c</code>文件，再次编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc - c print.c</span><br><span class="line">cc -o exe main.o print.o</span><br></pre></td></tr></table></figure><p><strong>Makefile:</strong></p><p>标准块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">object: dependency</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  action</span></span><br><span class="line"></span><br><span class="line">exe:main.o print.o</span><br><span class="line">cc -o exe main.o print.o</span><br><span class="line">main.o: main.c</span><br><span class="line">cc -c main.c</span><br><span class="line">print.o:print.c</span><br><span class="line">cc -c print.c</span><br><span class="line">clean:</span><br><span class="line">rm -f exe *.o</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make exe</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍如何使用gcc工具编译，Linux环境变量，如何写Makefile&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>常用网站导航</title>
    <link href="http://example.com/Tools/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/"/>
    <id>http://example.com/Tools/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/</id>
    <published>2022-03-12T14:01:06.000Z</published>
    <updated>2022-03-13T08:46:22.668Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
</summary>
      
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>时空复杂度分析</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2022-03-12T06:17:59.000Z</published>
    <updated>2022-03-12T06:20:36.499Z</updated>
    
    <content type="html"><![CDATA[<p>常用算法的时空复杂度分析，以及根据数据范围判断用什么算法。</p><span id="more"></span><h3 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3><ul><li>C++在1s内能算$10^7$~$10^8$次，控制在$10^7$次以内为最加</li></ul><h4 id="根据数据选算法"><a href="#根据数据选算法" class="headerlink" title="根据数据选算法"></a>根据数据选算法</h4><ol><li>$n≤30$，状态压缩 dp，DFS+剪枝，指数级别暴搜+剪枝</li><li>$n≤100$，或者几百=&gt;$O(n^3)$，floyd，dp</li><li>$n≤1000$=&gt;$O(n^2)$，$O(n^2logn)$=&gt;dp，二分，朴素Dijkstra</li><li>$n≤10^4$=&gt;$O(n+\sqrt{n})$块状链表</li><li>$n≤10^5$=&gt;$O(nlogn)$算法=&gt;各种sort，线段树，树状数组，set，map，heap，堆优化版Dijkstra，spfa，二分</li><li>$n≤10^6$=&gt;$O(n)/常数小的O(nlogn)$=&gt;$O(n)$：hash，双指针，kmp 常数小的$O(nlogn)$：各种sort，spfa，树状数组，heap，堆优化版Dijkstra，spfa，前缀和与差分</li><li>$n≤10^7$=&gt;$O(n)$，双指针扫描，kmp，线性筛素数</li><li>$n≤10^9$=&gt;$O(\sqrt{n})$，判断质数等</li><li>$n≤10^{18}$=&gt;$O(logn)$，欧几里得求最大公约数，快速幂</li></ol><h4 id="代码时间复杂度分析"><a href="#代码时间复杂度分析" class="headerlink" title="代码时间复杂度分析"></a>代码时间复杂度分析</h4><ol><li><p>纯循环</p></li><li><p>递归=&gt;通过主定理计算</p><ul><li>快排、归并=&gt;每层O(n)，一共logn层</li></ul></li><li><p>双指针算法</p><p>看上去是两重循环，但内层的j是<strong>只加不减</strong>的，因此内循环执行的次数≤n，因此复杂度是O(n)</p></li><li><p>单调栈和单调队列</p><p>看上去是两重循环，但是元素只会进出一次，因此复杂度为O(n)</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用算法的时空复杂度分析，以及根据数据范围判断用什么算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法基础" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/Trie/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/Trie/</id>
    <published>2022-03-04T09:31:55.000Z</published>
    <updated>2022-03-04T09:54:02.154Z</updated>
    
    <content type="html"><![CDATA[<p>一个高效存储和查找字符串集合的数据结构。</p><span id="more"></span><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>用途：高效存储和查找字符串集合的数据结构</p><p>使用情况：一般出现的字符串较短，或全为大写，或全为小写，或全为数字。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>先建立一个根节点，然后开始存储单词，并在每个单词结尾处<strong>标记</strong>，重复的前缀可以利用。</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220228100904429.png" alt="image-20220228100904429" style="zoom:50%;" /></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>按路径查找，不存在的两种可能：</p><ol><li>有该字符串，但结束时没有结尾标记</li><li>沿路径找不到该字符串</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;    <span class="comment">// 下标为0的点既是根节点，又是空节点</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;   <span class="comment">//idx表示指针指向的点（每一个点最多26个子节点）</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//情况1：没有匹配的字符</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];   <span class="comment">//情况2：若没有结尾，则cnt[p]为0，也属于匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个高效存储和查找字符串集合的数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>基础STL使用</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80STL%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80STL%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-04T09:27:51.000Z</published>
    <updated>2022-03-04T09:30:41.853Z</updated>
    
    <content type="html"><![CDATA[<p>Vector,pair,string,queue,priority_queue,stack,deque等基本容器的使用方法。</p><span id="more"></span><h3 id="基础STL的使用"><a href="#基础STL的使用" class="headerlink" title="基础STL的使用"></a>基础STL的使用</h3><p>每个容器都有的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">size</span>()<span class="comment">//返回元素个数， 时间复杂度O(1)</span></span><br><span class="line">a.<span class="built_in">empty</span>()<span class="comment">//返回元素是否为空，空则返回True，时间复杂度O(1)</span></span><br></pre></td></tr></table></figure><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector是变长数组，是<strong>倍增</strong>的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;<span class="comment">//定义一个vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//定义一个长度为10的vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;<span class="comment">//定义一个长度为10的vector,每一个都初始化为3</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[<span class="number">10</span>];<span class="comment">//vector数组，即定义10个vector</span></span><br><span class="line"><span class="comment">/*------- 输出 -------*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//范围遍历，效率高，auto自动推断变量类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator i = a.begin; i != a.<span class="built_in">end</span>(); i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">// 迭代遍历</span></span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">a.<span class="built_in">size</span>()<span class="comment">//返回元素个数， 时间复杂度O(1)</span></span><br><span class="line">a.<span class="built_in">empty</span>()<span class="comment">//返回元素是否为空，空则返回True，时间复杂度O(1)</span></span><br><span class="line">a.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line">a.<span class="built_in">front</span>()<span class="comment">//返回第一个数</span></span><br><span class="line">a.<span class="built_in">back</span>()<span class="comment">//返回最后一个数</span></span><br><span class="line">a.<span class="built_in">push_back</span>()<span class="comment">//在最后插入一个数</span></span><br><span class="line">a.<span class="built_in">pop_back</span>()<span class="comment">//把最后一个数删掉</span></span><br><span class="line">a.<span class="built_in">begin</span>()<span class="comment">//vector的第0个数</span></span><br><span class="line">a.<span class="built_in">end</span>()<span class="comment">//vector最后一个数的后面那个数</span></span><br><span class="line">a[x]<span class="comment">//和数组一样，支持随机选址</span></span><br><span class="line"><span class="comment">/*------- 支持比较运算 -------*/</span></span><br><span class="line"><span class="comment">//按字典顺序比大小,即从第一位开始比较，如果第一个数小于则小于，如果相等则比较下一位</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) <span class="built_in">puts</span>(<span class="string">&quot;a &lt; b&quot;</span>);</span><br></pre></td></tr></table></figure><p>底层实现原理：</p><p>系统为某一程序分配空间时，所需时间与空间无关，与<strong>申请次数</strong>有关。</p><p>vector的优化目标是减少申请次数，但可以浪费空间=&gt;倍增思想</p><p>e.g. 先分配32B，满了之后申请长度为64B的空间，并把前面的元素copy过来。</p><p>申请长度为n，则申请次数为logn，额外copy次数为O(1)</p><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以定义任意两个类型的组合</span></span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt; p;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;turbo&quot;</span>);</span><br><span class="line">p = (<span class="number">10</span>, <span class="string">&quot;turbo&quot;</span>);</span><br><span class="line"><span class="comment">// 取数</span></span><br><span class="line">p.first</span><br><span class="line">p.second  </span><br><span class="line"><span class="comment">//支持大小比较，按字典序（先比first，再比second）</span></span><br><span class="line">p1 &lt; p2</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line">pari&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; p;<span class="comment">//存储三个属性</span></span><br></pre></td></tr></table></figure><p>应用：某一个东西有两个属性，则可以用pair来存，按照其中一个属性排序很方便</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">a.<span class="built_in">size</span>()<span class="comment">//返回字符串长度</span></span><br><span class="line">a.<span class="built_in">empty</span>()<span class="comment">//返回字符串是否为空，空则返回True</span></span><br><span class="line">a.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line">a.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//返回字串，string本来的下标是从0开始，前一个参数为起始位置，后一个参数为长度；若第二个参数超过了最大长度，则输出到最大长度就截止；省略第二个参数，则返回从第一个参数开始的整个子串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.<span class="built_in">c_str</span>());<span class="comment">//这里的c_str()返回的是字符串存储的起始地址</span></span><br><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">string a = <span class="string">&quot;turbo&quot;</span></span><br><span class="line"><span class="comment">/*------- 常用运算 -------*/</span></span><br><span class="line">a += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">a += <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">q.<span class="built_in">size</span>()<span class="comment">// 返回元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>()<span class="comment">// 返回元素是否为空</span></span><br><span class="line"><span class="comment">//没有clear 函数！如果要清空，直接初始化</span></span><br><span class="line">q = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">q.<span class="built_in">push</span>()<span class="comment">// 向队尾插入一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>()<span class="comment">// 返回队头元素</span></span><br><span class="line">q.<span class="built_in">back</span>()<span class="comment">// 返回队尾元素</span></span><br><span class="line">q.<span class="built_in">pop</span>()<span class="comment">// 弹出队头元素</span></span><br></pre></td></tr></table></figure><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>优先队列（堆），<strong>默认大根堆</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">//如果要用小根堆？</span></span><br><span class="line"><span class="comment">//法1：将要用的数取负，然后再反过来</span></span><br><span class="line"><span class="comment">//法2：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">heap.<span class="built_in">size</span>()<span class="comment">// 返回元素个数</span></span><br><span class="line">heap.<span class="built_in">empty</span>()<span class="comment">// 返回元素是否为空</span></span><br><span class="line">heap.<span class="built_in">clear</span>()</span><br><span class="line">heap.<span class="built_in">push</span>()<span class="comment">// 插入一个元素</span></span><br><span class="line">heap.<span class="built_in">top</span>()<span class="comment">// 返回堆顶元素</span></span><br><span class="line">heap.<span class="built_in">pop</span>()<span class="comment">// 弹出堆顶元素</span></span><br></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>栈，<code>push()</code>， <code>top()</code>， <code>pop()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">s.<span class="built_in">size</span>()<span class="comment">// 返回元素个数</span></span><br><span class="line">s.<span class="built_in">empty</span>()<span class="comment">// 返回元素是否为空</span></span><br><span class="line">s.<span class="built_in">push</span>()<span class="comment">// 栈顶插入一个元素</span></span><br><span class="line">s.<span class="built_in">top</span>()<span class="comment">// 返回栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>()<span class="comment">// 弹出栈顶元素</span></span><br></pre></td></tr></table></figure><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">q.<span class="built_in">size</span>()</span><br><span class="line">q.<span class="built_in">empty</span>()</span><br><span class="line">q.<span class="built_in">clear</span>()</span><br><span class="line">q.<span class="built_in">front</span>()<span class="comment">// 返回第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>()<span class="comment">// 返回最后一个元素</span></span><br><span class="line">q.<span class="built_in">push_back</span>()<span class="comment">// 最后插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop_back</span>()<span class="comment">// 最后删除一个元素</span></span><br><span class="line">q.<span class="built_in">push_front</span>()<span class="comment">// 最前插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop_front</span>()<span class="comment">// 最后插入一个元素</span></span><br><span class="line">q.<span class="built_in">begin</span>()<span class="comment">// 指向第一个数</span></span><br><span class="line">q.<span class="built_in">end</span>()<span class="comment">// 指向最后一个数的后面</span></span><br></pre></td></tr></table></figure><p>功能很全但是效率比较慢</p><h4 id="set，map，multiset，multimap"><a href="#set，map，multiset，multimap" class="headerlink" title="set，map，multiset，multimap"></a>set，map，multiset，multimap</h4><p>基于平衡二叉树实现（红黑树），动态维护有序序列</p><p><strong>set&amp;multiset</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; MS;</span><br><span class="line"><span class="comment">//set中不能有重复元素，multiset可以有重复元素</span></span><br><span class="line"><span class="comment">//set所有操作的时间复杂度是O(logn),size()和empty是O(1)</span></span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">S.<span class="built_in">size</span>()</span><br><span class="line">S.<span class="built_in">empty</span>()</span><br><span class="line">S.<span class="built_in">clear</span>()</span><br><span class="line">S.<span class="built_in">insert</span>(x)<span class="comment">//插入一个数，若重复则会被忽略</span></span><br><span class="line">S.<span class="built_in">find</span>(x)<span class="comment">//查找一个数，若不存在则返回and迭代器    </span></span><br><span class="line">S.<span class="built_in">count</span>(x)<span class="comment">// 返回一个数的个数，set中只有0/1，multiset中则可以是多个</span></span><br><span class="line">S.<span class="built_in">erase</span>(x)<span class="comment">// 1.输入一个数x，删除所有x，O(k + logn)，k为x的个数；2.输入一个迭代器，删除这个迭代器</span></span><br><span class="line">S.<span class="built_in">lower_bound</span>(x)<span class="comment">//返回大于等于x的最小的数的迭代器</span></span><br><span class="line">S.<span class="built_in">upper_bound</span>(x)<span class="comment">// 返回大于x的最小的数的迭代器</span></span><br><span class="line">s.<span class="built_in">begin</span>()<span class="comment">// 指向第一个数</span></span><br><span class="line">s.<span class="built_in">end</span>()<span class="comment">// 指向最后一个数的后面</span></span><br></pre></td></tr></table></figure><p><strong>map&amp;multimap</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; a;</span><br><span class="line">multimap&lt;string, <span class="type">int</span>&gt; ma;<span class="comment">// 可以有重复元素</span></span><br><span class="line">a[<span class="string">&quot;turbo&quot;</span>] = <span class="number">1</span>;<span class="comment">//&quot;turbo&quot;映射到了1</span></span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">cout &lt;&lt; a[<span class="string">&quot;turbo&quot;</span>] &lt;&lt; endl;<span class="comment">// 可以直接找到映射到的1，像数组一样用，但是时间复杂度为O(logn), multimap不支持该操作</span></span><br><span class="line">a.<span class="built_in">size</span>()</span><br><span class="line">a.<span class="built_in">empty</span>()</span><br><span class="line">a.<span class="built_in">clear</span>()</span><br><span class="line">a.<span class="built_in">insert</span>(x)<span class="comment">// 插入的是一个pair</span></span><br><span class="line">a.<span class="built_in">erase</span>(x)  <span class="comment">// 插入的参数是pair或迭代器</span></span><br><span class="line">a.<span class="built_in">find</span>(x) <span class="comment">// 查找一个pair</span></span><br><span class="line">a.<span class="built_in">lower_bound</span>(x)<span class="comment">//返回大于等于x的最小的数的迭代器</span></span><br><span class="line">a.<span class="built_in">upper_bound</span>(x)<span class="comment">// 返回大于x的最小的数的迭代器</span></span><br></pre></td></tr></table></figure><h4 id="unodered-set，unordered-map，unordered-multiset，unordered-multimap"><a href="#unodered-set，unordered-map，unordered-multiset，unordered-multimap" class="headerlink" title="unodered_set，unordered_map，unordered_multiset，unordered_multimap"></a>unodered_set，unordered_map，unordered_multiset，unordered_multimap</h4><p>通过哈希表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和上面有序的类似，但增删改查的时间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// 不支持lower_bound()/upper_bound()，不支持迭代器的++,--（即不支持和排序有关的所有操作）</span></span><br></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>压位，可以省8位空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">bitset&lt;10000&gt; s;<span class="comment">//尖括号里写的是个数</span></span><br><span class="line"><span class="comment">/*------- 常用运算 -------*/</span></span><br><span class="line"><span class="comment">// 支持所有位运算</span></span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt; , &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line">s.<span class="built_in">count</span>()    <span class="comment">// 总共有多少个1</span></span><br><span class="line">s.<span class="built_in">any</span>()<span class="comment">// 判断是否至少有一个1</span></span><br><span class="line">s.<span class="built_in">none</span>()<span class="comment">// 判断是否全为0  </span></span><br><span class="line">s.<span class="built_in">set</span>()<span class="comment">// 把所有位置1</span></span><br><span class="line">s.<span class="built_in">reset</span>()    <span class="comment">// 把所有位置0</span></span><br><span class="line">s.<span class="built_in">reset</span>(k)    <span class="comment">// 把第k位置0</span></span><br><span class="line">s.<span class="built_in">set</span>(k, v)   <span class="comment">// 把k位置v </span></span><br><span class="line">s.<span class="built_in">flip</span>()<span class="comment">//等价于~</span></span><br><span class="line">s.<span class="built_in">flip</span>(k)<span class="comment">//第k位取反    </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vector,pair,string,queue,priority_queue,stack,deque等基本容器的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="编程基础" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/</id>
    <published>2022-03-04T09:26:11.000Z</published>
    <updated>2022-03-04T09:26:59.405Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表的基本使用和解决冲突的办法。</p><span id="more"></span><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h4><p>将比较庞大的数据映射到比较小的一个区间内</p><p>算法题中一般只有<strong>增加</strong>和<strong>查找</strong>两个操作（如果要实现删除，就开一个数组，然后打标记表示删除）</p><h4 id="一般情况的哈希（按冲突处理方式分）"><a href="#一般情况的哈希（按冲突处理方式分）" class="headerlink" title="一般情况的哈希（按冲突处理方式分）"></a>一般情况的哈希（按冲突处理方式分）</h4><ul><li>怎么实现哈希？<strong>直接取模最方便</strong>（mod的数一般要取质数，冲突概率最小）！</li></ul><h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p>为确保所有值都有坑，需要将哈希表长度开到需存的数的数量的<strong>2-3</strong>倍</p><p>方法：计算出的哈希值的位置已经有值占用就往后推，直到找到空的位置为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">// 如果x已经存在，返回x的下标；若x不存在，返回x应该存的位置</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)&#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;<span class="comment">//到最后没找到的话又从第一个开始找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">find</span>(x);</span><br><span class="line">h[k] = x;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><ol><li>计算哈希值，看哈希值的位置是不是该数，若为空则没有该数；</li><li>若为该数，则找到；</li><li>若不是该数，则按规则继续往后找，直到找到该数或找到空的位置（没有该数）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">if</span>(h[k] != null) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>映射到同一个位置的时候，用链表串起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">h(11) = 3</span></span><br><span class="line"><span class="comment">h(23) = 3</span></span><br><span class="line"><span class="comment">[0 1 2 3 4 5 ... 10^5-1]</span></span><br><span class="line"><span class="comment">       |</span></span><br><span class="line"><span class="comment">       11</span></span><br><span class="line"><span class="comment">       |</span></span><br><span class="line"><span class="comment">       23</span></span><br></pre></td></tr></table></figure><p>一般情况下，冲突的情况很少，时间复杂度可以看成<code>O(1)</code></p><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//h[N]为哈希表值为k的地方指向的第一个数，e[N]存储数，ne[N]存储指向下一个数的指针，idx为当前指针的位置</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;     <span class="comment">// C++中 负数的模还是负数，为了统一转化为正数，采用这种写法</span></span><br><span class="line">    e[idx] = x;     <span class="comment">// 单链表的插入</span></span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><p>计算出哈希值以后沿着链表查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == e[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串的哈希"><a href="#字符串的哈希" class="headerlink" title="字符串的哈希"></a>字符串的哈希</h4><p><strong>应用：</strong>快速判断两个字符串是否相等（O(1)就能做）</p><p>除了循环节，在其他方面KMP就不如HASH算法了</p><hr><p>字符串<strong>前缀</strong>哈希法</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;ABCABCD&quot;</span></span><br><span class="line">h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">h[<span class="number">1</span>] = <span class="string">&quot;A&quot;</span>的hash值</span><br><span class="line">h[<span class="number">2</span>] = <span class="string">&quot;AB&quot;</span>的hash值</span><br><span class="line">h[<span class="number">3</span>] = <span class="string">&quot;ABC&quot;</span>的hash值</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="如何得到前缀子串哈希值（预处理）？"><a href="#如何得到前缀子串哈希值（预处理）？" class="headerlink" title="如何得到前缀子串哈希值（预处理）？"></a><strong>如何得到前缀子串哈希值（预处理）？</strong></h5><ol><li><p>把字符串的每个字符都转换成数字，如<code>char - &#39;A&#39; + 1</code>（<strong>不能映射成0！！！</strong>）</p><blockquote><p>如“A”映射成0，那“AA”也是0</p></blockquote></li><li><p>把字符串看成p进制的数（p一般取131或13331）</p></li><li><p>把p进制转换成十进制数，并<code>mod Q</code>即可映射到哈希表（Q一般取$2^{64}$）</p></li></ol><p>按这种方法取P，Q，99%不会出现冲突（直接假定不会出现冲突做题）</p><p>用<code>unsigned long long</code>存储，直接溢出，则不需要取模了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[i] = h[i - <span class="number">1</span>] * p + str[i];</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//预处理得前缀哈希值</span></span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h5 id="字符串-L-R-区间的哈希值计算"><a href="#字符串-L-R-区间的哈希值计算" class="headerlink" title="字符串[L,R]区间的哈希值计算"></a>字符串[L,R]区间的哈希值计算</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = h[R] - h[L - <span class="number">1</span>] * p^(R - L + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>预处理完前缀哈希值以后，可以在<code>O(1)</code>时间算出任意子段的哈希值了</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>哈希和离散化有什么区别？</p><p>离散化是一种比较特殊的方式，它需要<strong>保序</strong>，而哈希不需要保序。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表的基本使用和解决冲突的办法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%A0%86/</id>
    <published>2022-03-04T09:24:30.000Z</published>
    <updated>2022-03-04T09:25:18.120Z</updated>
    
    <content type="html"><![CDATA[<p>堆的基础算法，用数组实现。</p><span id="more"></span><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>堆是一个<strong>完全二叉树</strong></p><p>小根堆：每一个结点小于等于左右儿子</p><p>大根堆：每一个结点大于等于左右儿子</p><hr><h4 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h4><p>用<strong>一维数组</strong>存，第一个点为根结点（<strong>下标从1开始！</strong>），$x$的左儿子为$2x$，$x$的右儿子为$2x+1$</p><hr><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h5><p>法1：O(nlogn)直接每一个插入</p><p>法2：<strong>O(n)</strong>从n/2【非叶子结点】开始down，一直down到1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i; i --) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h5 id="down-x"><a href="#down-x" class="headerlink" title="down(x)"></a>down(x)</h5><p><strong>这里的x表示的是结点的下标！！</strong></p><p>时间复杂度：O(logn)</p><p>往下调整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;   <span class="comment">// down编号为u的结点</span></span><br><span class="line">    <span class="type">int</span> t = u;  <span class="comment">// t记录一个结点和两个子节点中的最小值的编号</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= arr_size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= arr_size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);   <span class="comment">// 换的是值</span></span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="up-x"><a href="#up-x" class="headerlink" title="up(x)"></a>up(x)</h5><p>O(logn)</p><p>往上调整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])&#123;<span class="comment">// 只要和父结点比，可以写成迭代的形式</span></span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="STL可实现的操作"><a href="#STL可实现的操作" class="headerlink" title="STL可实现的操作"></a>STL可实现的操作</h4><h5 id="插入一个数"><a href="#插入一个数" class="headerlink" title="插入一个数"></a>插入一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heap[++size] = x;</span><br><span class="line"><span class="built_in">up</span>(size);</span><br></pre></td></tr></table></figure><h5 id="求集合当中的最小值"><a href="#求集合当中的最小值" class="headerlink" title="求集合当中的最小值"></a>求集合当中的最小值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h5 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h5><p>一维数组删除头结点很难，删除尾结点比较简单，所以先把最后一个点覆盖第一个点，然后调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="STL实现不了的操作"><a href="#STL实现不了的操作" class="headerlink" title="STL实现不了的操作"></a>STL实现不了的操作</h4><h5 id="删除任意一个元素"><a href="#删除任意一个元素" class="headerlink" title="删除任意一个元素"></a>删除任意一个元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);<span class="comment">//虽然down和up两个都写，但是只会执行一个</span></span><br></pre></td></tr></table></figure><h5 id="修改任意一个元素"><a href="#修改任意一个元素" class="headerlink" title="修改任意一个元素"></a>修改任意一个元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);<span class="comment">//虽然down和up两个都写，但是只会执行一个</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆的基础算法，用数组实现。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-03-04T09:22:12.000Z</published>
    <updated>2022-03-04T09:23:43.193Z</updated>
    
    <content type="html"><![CDATA[<p>并查集的基本使用和优化。</p><span id="more"></span><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a><strong>支持操作</strong></h4><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合中</li></ol><p>近乎O(1)的时间内完成（不是完全O(1))</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每个集合用一棵树来表示，<strong>树根的编号就是整个集合的编号</strong>。每个节点存储它的父节点，p[x]表示x的父结点。</p><ul><li><p>如何判断树根？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[x] == x)</span><br></pre></td></tr></table></figure></li><li><p>如何求x的集合编号？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p[x] != x) x = p[x];</span><br></pre></td></tr></table></figure><p>只要x不是树根就一直往上走，一直走到树根为止</p></li><li><p>如何合并两个集合？</p><p>把Set1当作Set2的儿子或者把Set2当作Set1的儿子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[x] = y;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>【<strong>路径压缩</strong>】一旦往上走找到了根节点，则把路径上所有的点都指向根节点，这样就只需要扫一遍。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">//实现集合的查找和路径压缩，返回的是祖宗节点</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) p[i] = i;  <span class="comment">//每个数各自在一个集合中</span></span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);    <span class="comment">//尽管只有一个字符，但还是用字符串读入，可以自动过滤很多空格换行符等，防止被坑</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = p[<span class="built_in">find</span>(b)];   <span class="comment">//把a所在的集合插入b所在的集合</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="built_in">find</span>(a)] == p[<span class="built_in">find</span>(b)]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;并查集的基本使用和优化。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前缀和与差分</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</id>
    <published>2022-03-04T09:18:59.000Z</published>
    <updated>2022-03-04T09:54:21.161Z</updated>
    
    <content type="html"><![CDATA[<p>一维、二维的前缀和与差分算法。</p><span id="more"></span><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和$s_i=a_1+a_2+…+a_i$</p><ul><li><p>求法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//important</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] +a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组a的下标一定要从1开始！！！</strong>=&gt;为了定义$s_0$，处理边界问题</p></li><li><p>作用：</p><p>能快速求出原数组中一段数的和（区间和的计算）</p></li><li><p>扩展到二维：求子矩阵的和</p><p><strong>两个方向的前缀</strong></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211130193812461.png" alt="image-20211130193812461"></p><p><code>s[i,j]</code>求的是左上部分的前缀和。</p></li></ul><p>  初始化：<code>s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]</code></p><p>  <img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211130194139172.png" alt="image-20211130194139172"></p><p>  求红色矩阵的前缀和，使用求面积的方法，即<code>sum=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]-s[x1-1][y1-1]</code></p><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分是前缀和的逆运算(相邻元素之差)</p><p>使得a[]是b[]的前缀和，则b是a的差分。</p><ul><li>求法</li></ul><p>​    $a_i = b_1+b_2+…+b_i$</p><p>​    $b_1=a_1$</p><p>​    $b_2=a_2-a_1$</p><p>​    …</p><ul><li><p>作用</p><p>对b数组求一遍前缀和即可得到原数组a</p><p>O(n)时间内可得到a</p><p>使用场景：[l,r]的每个元素都要加上数c，用差分可以由O(n)降到O(1)</p></li></ul><p>​    即，<code>b[l]+c</code>，则<code>a[l],a[l+1]...</code>都会加c，因为是通过前缀和求的。</p><p>​    在后面<code>b[r+1]-c</code>，则实现了<code>a[l,r]</code>都加c</p><ul><li><p>二维差分</p><p>给一个子矩阵的每个元素加一个值</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211130201000274.png" alt="image-20211130201000274"></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[x1][y1]+=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一维、二维的前缀和与差分算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="基础算法" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++中sort函数的使用总结</title>
    <link href="http://example.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E4%B8%ADsort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-1/"/>
    <id>http://example.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E4%B8%ADsort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-1/</id>
    <published>2022-03-04T09:15:19.000Z</published>
    <updated>2022-03-04T10:43:16.328Z</updated>
    
    <content type="html"><![CDATA[<p>C++中sort函数使用方法的总结和举例。</p><span id="more"></span><h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><h2 id="如何使用sort函数"><a href="#如何使用sort函数" class="headerlink" title="如何使用sort函数"></a>如何使用sort函数</h2><p>头文件：<code>include &lt;iostream&gt;</code>以及<code>using namespace std;</code></p><p><code>sort(首元素地址(必填)，尾元素地址的下一个地址（必填），比较函数（选填）)</code></p><p>对尾元素下一个地址的理解：也可以是从首元素地址开始，给几个数进行排序，就第二个参数加几</p><p>如果不写比较函数则默认对前面给出的区间进行递增排序</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对char进行排序是默认按字典序</p><p>如果没有可比性，则需要人为制定比较规则，sort函数中第三个参数就是用来制定规则的</p><h2 id="如何实现比较函数cmp"><a href="#如何实现比较函数cmp" class="headerlink" title="如何实现比较函数cmp"></a>如何实现比较函数cmp</h2><h3 id="基本数据类型数组的排序"><a href="#基本数据类型数组的排序" class="headerlink" title="基本数据类型数组的排序"></a>基本数据类型数组的排序</h3><p>如果要从大到小排序，则用cmp函数告诉sort()，何时要交换元素(让大小比较关系反过来）,是一个<strong>bool类型</strong>的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;<span class="comment">//当a大于b时，a放在前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体数组的排序"><a href="#结构体数组的排序" class="headerlink" title="结构体数组的排序"></a>结构体数组的排序</h3><p>定义一个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>一级排序：按x从大到小进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按照x从大到小排序 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级排序：当x相等的情况下，按照y的大小从小到大进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按照x从大到小排序 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ssd[<span class="number">0</span>].x=<span class="number">2</span>;</span><br><span class="line">ssd[<span class="number">0</span>].y=<span class="number">2</span>;</span><br><span class="line">ssd[<span class="number">1</span>].x=<span class="number">1</span>;</span><br><span class="line">ssd[<span class="number">1</span>].y=<span class="number">3</span>;</span><br><span class="line">ssd[<span class="number">2</span>].x=<span class="number">3</span>;</span><br><span class="line">ssd[<span class="number">2</span>].y=<span class="number">1</span>;</span><br><span class="line">ssd[<span class="number">3</span>].x=<span class="number">1</span>;</span><br><span class="line">ssd[<span class="number">3</span>].y=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">sort</span>(ssd,ssd+<span class="number">3</span>,cmp1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;ssd[i].x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ssd[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ssd,ssd+<span class="number">4</span>,cmp2);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;ssd[i].x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ssd[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="容器排序"><a href="#容器排序" class="headerlink" title="容器排序"></a>容器排序</h3><p>在STL标准容器中，只有vector，string，deque可以用排序</p><p>vector：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">sort</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;vi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">321</span></span><br></pre></td></tr></table></figure><p>string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str1.<span class="built_in">length</span>()&lt;str2.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string str[<span class="number">3</span>]=&#123;<span class="string">&quot;babb&quot;</span>,<span class="string">&quot;bc&quot;</span>,<span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(str,str+<span class="number">3</span>);<span class="comment">//按字典序从小到大排序(一个一个字母比） </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(str,str+<span class="number">3</span>,cmp);<span class="comment">//按字符串长度排序 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">babb</span><br><span class="line">bc</span><br><span class="line">bc</span><br><span class="line">aaa</span><br><span class="line">babb</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中sort函数使用方法的总结和举例。&lt;/p&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="编程基础" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>用Docker部署KubeFate</title>
    <link href="http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E7%94%A8Docker%E9%83%A8%E7%BD%B2KubeFate/"/>
    <id>http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E7%94%A8Docker%E9%83%A8%E7%BD%B2KubeFate/</id>
    <published>2022-03-03T11:48:32.000Z</published>
    <updated>2022-03-03T11:49:40.342Z</updated>
    
    <content type="html"><![CDATA[<p>使用FATE开源库，通过Docker部署KubeFate集群。</p><span id="more"></span><h1 id="用Docker部署KubeFate"><a href="#用Docker部署KubeFate" class="headerlink" title="用Docker部署KubeFate"></a>用Docker部署KubeFate</h1><hr><p>工具：CentOS7 虚拟机或物理机</p><p><a href="https://github.com/FederatedAI/KubeFATE/blob/master/docker-deploy/README_zh.md">官方中文文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/121738171">单机部署KubeFate</a></p><hr><h3 id="安装Docker容器"><a href="#安装Docker容器" class="headerlink" title="安装Docker容器"></a>安装Docker容器</h3><ul><li><p>安装系统依赖工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>yum的配置管理，添加docker的软件源地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>(通过阿里云镜像)</p></li><li><p>更新yum缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure></li><li><p>查看docker的所有版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure></li><li><p>选一个进行安装</p><p>fate官方文档要求所有主机安装Docker 版本 : 18+；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce-18.03.1.ce</span><br></pre></td></tr></table></figure></li><li><p>启动docker服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>加入开机启动项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li><li><p>查看docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker version</span><br></pre></td></tr></table></figure></li><li><p>测试docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/03/EGCOzy7LjwFvB8M.png" alt="image-20220226100155056"></p><p>测试成功！</p></li></ul><h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker-Compose"></a>安装Docker-Compose</h3><p><strong>官方要求所有主机安装Docker-Compose 版本: 1.24+；</strong></p><ul><li>安装指定版本Docker-Compose</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>github访问太慢，可以用daocloud安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ul><li><p>添加可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/03/OD5usTZPvGWi8xX.png" alt="image-20220226101152561"></p></li><li><p>检查端口是否被占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -apln|grep 8080                                                                               </span><br><span class="line">netstat -apln|grep 9360                                                                    </span><br><span class="line">netstat -apln|grep 9380</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220226101331899.png" alt="image-20220226101331899"></p><p>这表示都没有占用，若有占用则要先kill占用端口的进程</p></li></ul><h3 id="部署KubeFATE"><a href="#部署KubeFATE" class="headerlink" title="部署KubeFATE"></a>部署KubeFATE</h3><ul><li>创建文件夹<code>fate</code></li></ul><hr><ul><li><p>在文件夹中下载fate镜像(只有1.4.0)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://webank-ai-1251170195.cos.ap-guangzhou.myqcloud.com/fate_1.4.0-images.tar.gz</span><br></pre></td></tr></table></figure><p>国内用户从此处下载速度较快</p></li><li><p>加载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker load -i fate_1.4.0-images.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>验证镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ul><hr><p>  或者直接根据官方文档手动下载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version=1.7.2          </span><br><span class="line">version_server=2.1.5   </span><br><span class="line">docker pull federatedai/eggroll:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/fateboard:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/python:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/client:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/serving-server:<span class="variable">$version_server</span>-release</span><br><span class="line">docker pull federatedai/serving-proxy:<span class="variable">$version_server</span>-release</span><br><span class="line">docker pull redis:5</span><br><span class="line">docker pull mysql:8</span><br></pre></td></tr></table></figure><p>版本号从<code>release</code>里查看最新的版本号</p><hr><ul><li><p>下载KubeFate</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/FederatedAI/KubeFATE/releases/download/v1.7.0-a/kubefate-docker-compose.tar.gz</span><br></pre></td></tr></table></figure><p>版本号可在官方文档中查看</p></li><li><p>将KubeFate放入<code>/home</code>目录进行解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf kubefate-docker-compose-v1.7.1-a.tar.gz </span><br></pre></td></tr></table></figure></li><li><p>准备两台主机，修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user=root                                  # 运行FATE容器的用户</span><br><span class="line">dir=/data/projects/fate                     # docker-compose部署目录</span><br><span class="line">partylist=(10000 9999)                      # 组织id</span><br><span class="line">partyiplist=(192.168.126.166 192.168.126.167)       # id对应训练集群ip</span><br><span class="line">servingiplist=(192.168.126.166 192.168.126.167)     # id对应在线预测集群ip</span><br><span class="line"><span class="meta"># </span><span class="language-bash">computing_backend could be eggroll or spark.</span></span><br><span class="line">computing_backend=eggroll</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="literal">true</span> <span class="keyword">if</span> you need python-nn <span class="keyword">else</span> <span class="literal">false</span>, the default value will be <span class="literal">false</span></span></span><br><span class="line">enabled_nn=false</span><br><span class="line"></span><br><span class="line">fateboard_username=admin                    # 访问fateboard的用户名</span><br><span class="line">fateboard_password=admin                    # 访问fateboard的密码</span><br></pre></td></tr></table></figure><p>user一般要用root，如果不是root则要有<code>/data/projects/fate</code>文件夹权限和docker权限。</p><p><code>party 10000</code>的集群将部署在<em>192.168.126.166</em>上，而<code>party 9999</code>的集群将部署在<em>192.168.126.167</em>上。为了减少所需拉取镜像的大小，KubeFATE在默认情况下，会使用不带神经网络的“python”容器，若需要跑神经网络的算法则需把“parties.conf”中的<code>enabled_nn</code>设置成<code>true</code></p><ul><li><p>执行部署脚本（host）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./generate_config.sh          # 生成部署文件</span><br><span class="line">./docker_deploy.sh all        # 在各个party上部署FATE</span><br></pre></td></tr></table></figure></li><li><p>通过SSH登录其中一个主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.7.1</span><br></pre></td></tr></table></figure></li><li><p>验证实例状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>若各个组件都是运行（up）状态，说明部署成功。</p></li><li><p>验证部署</p><p>docker-compose上的FATE启动成功之后需要验证各个服务是否都正常运行，我们可以通过验证toy_example示例来检测。</p><p>选择192.168.126.167这个节点验证，使用以下命令验证：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">在192.168.126.167上执行下列命令</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it confs-10000_client_1 bash                        <span class="comment">#进入python组件容器内部</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">flow <span class="built_in">test</span> toy --guest-party-id 10000 --host-party-id 9999        <span class="comment">#验证</span></span></span><br></pre></td></tr></table></figure><p>至此，基本部署完毕。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用FATE开源库，通过Docker部署KubeFate集群。&lt;/p&gt;</summary>
    
    
    
    <category term="隐私计算" scheme="http://example.com/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="隐私计算" scheme="http://example.com/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    <category term="联邦学习" scheme="http://example.com/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>联邦学习概述</title>
    <link href="http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/</id>
    <published>2022-03-03T11:45:02.000Z</published>
    <updated>2022-03-03T11:47:05.115Z</updated>
    
    <content type="html"><![CDATA[<p>联邦学习基础的行业背景、基本特点、分类等。</p><span id="more"></span><h2 id="联邦学习概述"><a href="#联邦学习概述" class="headerlink" title="联邦学习概述"></a>联邦学习概述</h2><h3 id="行业背景"><a href="#行业背景" class="headerlink" title="行业背景"></a>行业背景</h3><p>数据分布不均衡，对数据使用监管趋于严格==&gt;<strong>数据孤岛</strong></p><p>联邦学习就可以来解决数据孤岛问题。</p><h3 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h3><ul><li>数据隔离：数据不泄露到外部</li><li>无损：联邦模型效率等同或接近全量数据模型</li><li>对等：参与者的地位对等</li><li>共同获益：参与者能够共同获益</li></ul><h3 id="联邦学习分类"><a href="#联邦学习分类" class="headerlink" title="联邦学习分类"></a>联邦学习分类</h3><h4 id="横向联邦学习"><a href="#横向联邦学习" class="headerlink" title="横向联邦学习"></a>横向联邦学习</h4><p>数据方：特征维度相同，通过联邦学习有更多的数据样本</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>A与B联合建模，双方都有X，Y，但样本不够多</p><p><img src="https://s2.loli.net/2022/03/03/65zDKWXnUvaHtBk.png" alt="image-20220302114121917"></p><p><strong>假设</strong>：双方都有X,Y；双方不暴露自己的X,Y</p><p><strong>传统建模</strong>：各自样本不够多</p><p><strong>期望</strong>：保护隐私的条件下，建立联合模型，且效果超过单边数据建模</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>常用方法：<strong>FedAvg</strong>【是<strong>无损</strong>的，也可以跟差分隐私结合一起用】</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302114504380.png" alt="image-20220302114504380"></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302114615724.png" alt="image-20220302114615724"></p><h4 id="纵向联邦学习"><a href="#纵向联邦学习" class="headerlink" title="纵向联邦学习"></a>纵向联邦学习</h4><p>数据方：样本ID相同，通过联邦学习丰富样本特征，更精准地刻画样本</p><h5 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h5><p>A与B联合建模，B有Y（表现），期望优化Y的预测模型</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302103142501.png" alt="image-20220302103142501"></p><p><strong>假设</strong>：只有B拥有“Y”，合作的A无法暴露含有隐私的“X”</p><p><strong>传统建模方法</strong>：B的隐私数据“X”不能全量传到“Y”，A缺乏“Y”，无法独立建模</p><p><strong>期望</strong>：保护隐私的条件下，建立联合模型，且效果超过单边数据建模</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li><p><strong>数据对齐</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Party A: </span><br><span class="line">ID <span class="keyword">set</span> X:[u1, u2, u3, u4]</span><br><span class="line">Party <span class="comment">B:</span> </span><br><span class="line">ID <span class="comment">set Y:[u1, u2, u3, u5]</span></span><br><span class="line">要求寻找X∩Y <span class="comment">= [u1, u2, u3]</span></span><br><span class="line">且PartyA不知道PartyB有u5</span><br><span class="line">PartyB不知道PartyA有u4</span><br></pre></td></tr></table></figure><p>解决方案：<strong>RSA+哈希的安全求交</strong></p><ol><li>PartyB通过RSA产生n,e,d并将公钥(n,e)发送给Party A</li><li>PartyA对于每条样本产生随机数$r_i$并将id哈希得到<code>H(u)</code>，将$Y_A={r_1^eH(u1),r_2^eH(u2),r_3^eH(u3),r_4^eH(u4)}$发送给PartyB【$r_i$相当于PartyA给自己上的锁，RSA相当于PartyB给自己上的锁，因此双方都未泄露数据】</li><li>PartyB对每一个$r_i^eH(u_i)$求$d$次幂，并mod n，相当于对其进行二次加密，即$r_i*(H(u_i))^d$，其集合定义为$Z_A$；同时PartyB对自己的数据求$H((H(u_i))^d)$，其集合定义为$Z_B$，将$Z_A,Z_B$发给PartyA</li><li>PartyA对$r_i<em>(H(u_i))^d$进行处理，$r_i$在PartyA手中，所以直接求$H(r_i</em>(H(u_i))^d/r_i) = H((H(u_i))^d)$，将该集合定义为$D_A$</li><li><strong>求交</strong>：$I = D_A ∩ Z_B={H((H(u_1))^d), H((H(u_2))^d), H((H(u_3))^d)}$，并将I发送给B</li></ol><p>通过这5步，PartyA和PartyB没有泄露其他ID，并且找到了相同的ID</p></li><li><p><strong>联邦特征工程</strong></p><p> 求WoE(Weight of Evidence)和IV(Information Value)</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题：在保护双方隐私的前提下，A(含<span class="keyword">X</span>)，B（含<span class="keyword">X</span>，<span class="keyword">Y</span>）特征，如何计算Woe和IV？</span><br><span class="line">难点：</span><br><span class="line"><span class="number">1</span>.A只有特征<span class="keyword">X</span>，没有<span class="keyword">Y</span>；计算Woe和IV依靠<span class="keyword">X</span>和<span class="keyword">Y</span>（B侧特征Woe&amp;IV可以本地计算）</span><br><span class="line"><span class="number">2</span>.A不能对B暴露<span class="keyword">X</span>，B不能对A暴露<span class="keyword">Y</span></span><br><span class="line">最终只能让B获得所有特征Woe&amp;IV</span><br></pre></td></tr></table></figure><p>解决方案：<strong>加法同态加密</strong></p><p><code>Encry(x)</code>：x的加法同态加密</p><p><code>Encode(x)</code>：本地编码</p><ol><li><p>PartyB对每个ID的$y_i，1-y_i$进行加密，发送给PartyA，即{$ID_i, Encry(y_i),Encry(1-y_i)$}</p></li><li><p>PartyA统计每个数据集中$Encry(y_i)$的和以及$Encry(1-y_i)$的和，并发送给PartyB，即{$Encode(id_set_i), sum(Encry(y_i)),sum(Encry(1-y_i))$}</p></li><li><p>B方即可本地计算Woe和IV</p><script type="math/tex; mode=display">npos_i=Decry(sum(Encry(yi)))</script><script type="math/tex; mode=display">nneg_i=Decry(sum(Encry(1 - yi)))</script><script type="math/tex; mode=display">distpos_i = npos_i / pos_total</script><script type="math/tex; mode=display">distneg_i = nneg_i / neg_total</script><script type="math/tex; mode=display">Woe_i = 100 * log(distpos_i / distneg_i)</script><script type="math/tex; mode=display">IV =\sum_{i=1}^k(dispos_i - disneg_i)*log(dispos_i/disneg_i)</script></li></ol></li></ul><ul><li><p><strong>逻辑回归</strong></p><p>纵向逻辑回归用加法同态，因为加法同态没有逆，因此在公式里不能有<code>exp</code>，采用的解决方法是在零点附近进行泰勒展开，使其<strong>只有加法和乘法</strong></p></li></ul><h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><p>  <img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302113755110.png" alt="image-20220302113755110"></p><h3 id="联邦学习关键技术—加解密"><a href="#联邦学习关键技术—加解密" class="headerlink" title="联邦学习关键技术—加解密"></a>联邦学习关键技术—加解密</h3><h4 id="保护隐私和安全方法"><a href="#保护隐私和安全方法" class="headerlink" title="保护隐私和安全方法"></a>保护隐私和安全方法</h4><ul><li><p><strong>同态加密</strong></p><p>加密情况下的运算结果和在明文情况下的运算结果完全一致，而且每一次加密的结果是不一样的</p></li><li><p>多方安全计算</p></li><li><p>姚式混淆电路</p></li><li><p>差分隐私</p></li></ul><p>Fate库中主要用的是<strong>加法同态加密</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;联邦学习基础的行业背景、基本特点、分类等。&lt;/p&gt;</summary>
    
    
    
    <category term="隐私计算" scheme="http://example.com/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="隐私计算" scheme="http://example.com/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    <category term="联邦学习" scheme="http://example.com/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>垃圾邮件分类</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB/</id>
    <published>2022-03-03T11:40:44.000Z</published>
    <updated>2022-03-03T11:44:43.643Z</updated>
    
    <content type="html"><![CDATA[<p>通过概率论中学的贝叶斯公式来推断一封新收到的邮件是否为垃圾邮件。</p><span id="more"></span><h1 id="垃圾邮件分类"><a href="#垃圾邮件分类" class="headerlink" title="垃圾邮件分类"></a>垃圾邮件分类</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>了解垃圾邮件分类的基本技术路线与方法。</li><li>了解如何提取邮件中的关键字，并运用统计学中的贝叶斯公式来推断一封新收到的邮件是否为垃圾邮件。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="邮件解析"><a href="#邮件解析" class="headerlink" title="邮件解析"></a>邮件解析</h3><p>我在网上找到了一个8000封正常邮件和8000封垃圾邮件的邮件史料，同时也通过网上邮件下载的python文件，即<code>mailDownload.py</code>添加了邮箱的一些邮件，作为训练集，然后提取邮件中的中文词汇。</p><p>这里使用的提取中文词汇的方法是：先将中文文本切成最小的单位汉字，然后再=从词典里找词，将字按照最左最长原则，合并成以词为单位的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_wordslist</span>(<span class="params">self, fn=<span class="string">r&quot;./words.txt&quot;</span></span>):</span><br><span class="line">    f = <span class="built_in">open</span>(fn)</span><br><span class="line">    lines = <span class="built_in">sorted</span>(f.readlines())</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">words_2_trie</span>(<span class="params">self, wordslist</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将单词表存入字典树</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> wordslist:</span><br><span class="line">        ref = d</span><br><span class="line">        chars = self.regex.findall(word)</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">            ref[char] = ref.has_key(char) <span class="keyword">and</span> ref[char] <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">            ref = ref[char]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_in_trie</span>(<span class="params">self, chars, trie, res</span>):</span><br><span class="line">    ref = trie</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        <span class="keyword">if</span> ref.has_key(char):</span><br><span class="line">            temp += char</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            ref = ref[char]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> temp != <span class="number">0</span>:                                <span class="comment">#表示上一个单词已经分离出</span></span><br><span class="line">                res.append(temp)</span><br><span class="line">                temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span>:                               <span class="comment">#字典中没有以上一个char结尾的单词</span></span><br><span class="line">                index = <span class="number">1</span></span><br><span class="line">                res.append(char)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                chars = chars[index:]</span><br><span class="line">                self.search_in_trie(chars, trie, res)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span>:                                       <span class="comment">#最后一个词</span></span><br><span class="line">        res.append(temp);</span><br></pre></td></tr></table></figure><p>做完以后发现，python有结巴分词这个第三方扩展库来实现中文分词，好像直接调用那个库可以更加方便，但是我已经写完了就没有再使用了。</p><h3 id="邮件分析"><a href="#邮件分析" class="headerlink" title="邮件分析"></a>邮件分析</h3><p>做完这些后就要对信息进行汇总了，即统计邮件中每个词汇分别在垃圾邮件和正常邮件中出现的频率，</p><ol><li><p>当收到一封未知邮件时，在不知道的前提下，我们假定它是垃圾邮件和正常邮件的概率各 为50%，p(s) = p(n) = 50%</p></li><li><p>解析该邮件，提取每个词，计算该词的p(s|w)，也就是受该词影响，该邮件是垃圾邮件的概率</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p<span class="comment">(sw)</span>             p<span class="comment">(w|s)</span>p<span class="comment">(s)</span></span><br><span class="line">p<span class="comment">(s|w)</span> = -----------  =   ----------------------</span><br><span class="line">p<span class="comment">(w)</span>        p<span class="comment">(s)</span>p<span class="comment">(w|s)</span> + p<span class="comment">(n)</span>p<span class="comment">(w|n)</span></span><br></pre></td></tr></table></figure><p>此处的解析邮件还是类似于前面的邮件分词，对应实现是splitsingle()</p></li><li><p>提取该邮件中p(s|w)最高的15个词，计算联合概率。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p(s|<span class="type">w1</span>)p(s|<span class="type">w2</span>)...p(s|<span class="type">w15</span>)</span><br><span class="line">p = ---------------------------------------------------------------</span><br><span class="line">p(s|<span class="type">w1</span>)p(s|<span class="type">w2</span>)...p(s|<span class="type">w15</span>) + (<span class="number">1</span>-p(s|<span class="type">w1</span>))(<span class="number">1</span>-p(s|<span class="type">w2</span>)...(<span class="number">1</span>-p(s|<span class="type">w15</span>)))</span><br></pre></td></tr></table></figure></li><li><p>设定阈值 p &gt; 0.9 :垃圾邮件<br>p &lt; 0.9 :正常邮件</p></li></ol><p>整个过程的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JudgeMail</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    判断接收到的邮件是否为垃圾邮件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">self, init, trie, email</span>):</span><br><span class="line">        res = init.splitsingle(trie, email)                  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;。&#x27;</span>, <span class="string">&#x27;：&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;（&#x27;</span>, <span class="string">&#x27;）&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;！&#x27;</span>,<span class="string">&#x27;、&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> res:</span><br><span class="line">                res.remove(i)                                <span class="comment">#剔除标点字符</span></span><br><span class="line">        ratio_of_words = [] <span class="comment">#记录邮件中每个词在垃圾邮件史料库(init.ratio[key][1])中出现的概率</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> init.ratio:</span><br><span class="line">                ratio_of_words.append((word, init.ratio[word][<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                init.ratio[word] = [<span class="number">0.6</span>, <span class="number">0.4</span>] <span class="comment">#如果邮件中的词是第一次出现，那么就假定</span></span><br><span class="line">                                                             <span class="comment">#p(s|w)=0.4</span></span><br><span class="line">            ratio_of_words.append((word, <span class="number">0.4</span>))</span><br><span class="line">        ratio_of_words = <span class="built_in">sorted</span>(ratio_of_words, key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:<span class="number">15</span>]</span><br><span class="line">        P = <span class="number">1.0</span> </span><br><span class="line">        rest_P = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> ratio_of_words:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">print</span> word[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>), word[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span> word[<span class="number">0</span>], word[<span class="number">1</span>]</span><br><span class="line">            P *= word[<span class="number">1</span>]</span><br><span class="line">            rest_P = rest_P * (<span class="number">1.0</span> - word[<span class="number">1</span>])</span><br><span class="line">         </span><br><span class="line">        trash_p = P / (P + rest_P)</span><br><span class="line">        typ = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> trash_p &gt; <span class="number">0.9</span>:</span><br><span class="line">            typ = <span class="string">&#x27;trash&#x27;</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            typ = <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">        init.flush(typ, res)</span><br><span class="line">        <span class="keyword">return</span> trash_p</span><br></pre></td></tr></table></figure><h3 id="建立通信"><a href="#建立通信" class="headerlink" title="建立通信"></a>建立通信</h3><p>这学期的计算机网络学习socket通信，这里拿来实践一下，过简单地socket通信模拟邮件收发。</p><ul><li><p>server端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> analysisEmail</span><br><span class="line"><span class="keyword">import</span> splitEmail</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#加载历史邮件资料库，即建立判断条件</span></span><br><span class="line">    init = splitEmail.SplitEmail()</span><br><span class="line">    words = init.init_wordslist()</span><br><span class="line">    trie = init.words_2_trie(words)</span><br><span class="line">    init.split(trie, [<span class="string">&#x27;./data/&#x27;</span>])</span><br><span class="line">    init.ratio = init.getRatio()</span><br><span class="line">    <span class="comment">#for key in dic_of_ratio:</span></span><br><span class="line">    <span class="comment">#    print key, dic_of_ratio[key]</span></span><br><span class="line">    <span class="comment">####################################################################</span></span><br><span class="line"></span><br><span class="line">    host = <span class="string">&#x27;&#x27;</span>   </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.bind((host, port))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Waiting for clients...&quot;</span></span><br><span class="line">        conn, addr = s.accept()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Connected by&#x27;</span>, addr</span><br><span class="line">        msg = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(data):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            msg += data</span><br><span class="line">        conn.close()</span><br><span class="line">        P = analysisEmail.JudgeMail().judge(init, trie, msg)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;P(spam) = &quot;</span>, P</span><br></pre></td></tr></table></figure></li><li><p>client端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">port = <span class="number">8888</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">fi = <span class="built_in">str</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">msg = <span class="built_in">open</span>(fi).read()</span><br><span class="line">s.connect((host, port))</span><br><span class="line">s.sendall(msg)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;error: Input the email location&quot;</span></span><br></pre></td></tr></table></figure><p>整个过程：server端运行，首先建立splitemail对象，然后调用init_wordlist()加载字典，之后调用words_2_trie()将<br>字典转换为字典树，再之后将史料库中的邮件分词，统计各个单词在正常和垃圾邮件中出现的概率。</p><p> client发来邮件，server接收后调用<code>analysisEmail.py</code>中的<code>judge()</code>函数来判断其是否为垃圾邮件。</p></li></ul><h2 id="实验中出现的问题"><a href="#实验中出现的问题" class="headerlink" title="实验中出现的问题"></a>实验中出现的问题</h2><ul><li>实验过程当中开始遇到的问题是训练数据集的搜集问题，开始找不到对应的邮件史料库，后来通过CSDN下载到了一个比较大的数据集（虽然邮件比较老旧）</li><li>提取中文分词时遇到了一些问题，后来找到了字典树与最左最长匹配的方法实现了简单的分词功能，结果做完后发现python有第三方扩展库可以完美实现中文分词。</li></ul><h2 id="实验结果展示及分析"><a href="#实验结果展示及分析" class="headerlink" title="实验结果展示及分析"></a>实验结果展示及分析</h2><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p>我从邮件库中选取了一封典型的垃圾邮件：</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124141327426.png" alt="image-20211124141327426"></p><p>通过分析后我们得到为垃圾邮件的概率为0.9538…</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124141251659.png" alt="image-20211124141251659"></p><h4 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h4><p>测试邮件集合中部分邮件，正常邮件中正确识别的为Nc，错误识别的为Ne，垃圾邮件中正确识别的为Mc，错误识别的为Me。</p><div class="table-container"><table><thead><tr><th></th><th>准确度</th><th>召回率</th></tr></thead><tbody><tr><td>贝叶斯</td><td>88.8%</td><td>89.5%</td></tr></tbody></table></div><p>（召回率=$Nc/(Nc+Ne) *100%$）</p><p>通过数据我们可以看到使用贝叶斯的分类算法准确度和召回率处于中游水平，应该还有更好的分类方法比如支持向量机等可以提高准确度和召回率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过概率论中学的贝叶斯公式来推断一封新收到的邮件是否为垃圾邮件。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="信息安全环境与工具" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Socket" scheme="http://example.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>PAXOS共识算法</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/PAXOS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/PAXOS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-03T11:37:59.000Z</published>
    <updated>2022-03-03T11:59:31.192Z</updated>
    
    <content type="html"><![CDATA[<p>实现共识算法中比较古老且复杂的共识算法PAXOS，几乎没有应用于区块链了。</p><span id="more"></span><h1 id="PAXOS共识算法"><a href="#PAXOS共识算法" class="headerlink" title="PAXOS共识算法"></a>PAXOS共识算法</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>了解区块链的基本共识算法，体会PAXOS共识算法与其他共识算法的异同。</li><li>了解PAXOS算法的基本过程，并实现PAXOS算法。</li><li>体会分析Basic-PAXOS算法的缺陷，并提出改进方案。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>Paxos算法中有四个角色Client（议题产生者）、Proposer（正式提议者）、Acceptor（投票决策者）和Learner（最终结果学习者），这四个角色中Client和Learner角色是两个广义的概念，而真正完成算法的是<strong>Proposer和Acceptor</strong>，因此该算法我将通过两部分来实现。</p><ul><li><p>Prepare</p><p>该阶段是proposer提出一个提案，编号为N，然后该编号如果大于proposer之前提出的编号，则请求acceptors接收。</p><p>因为是一个模拟过程，所以提案的内容我采用的是随机生成的方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v = PROPOSALS[rand() % ARRAY_LENGTH(PROPOSALS)];                <span class="comment">//提议的内容</span></span><br><span class="line">        <span class="keyword">if</span> ((!<span class="built_in">queue</span>.empty()) &amp;&amp; rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.5</span> &gt; <span class="number">0</span>) &#123;<span class="comment">//如果提案满足多数派</span></span><br><span class="line">            b = <span class="built_in">queue</span>.front();              <span class="comment">//拿出第一个提案并出列</span></span><br><span class="line">            <span class="built_in">queue</span>.pop();                    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = last_prepare_b + <span class="number">1</span>;             <span class="comment">//将prepare的提案入队</span></span><br><span class="line">            last_prepare_b ++;</span><br><span class="line">            <span class="keyword">if</span> (rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.7</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(b);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在这里我借助了队列的数据结构来实现提案的准备过程。</p></li><li><p>Promise</p><p>Promise阶段所做的工作是如果N大于此acceptor之前接收的任何提案的编号，则acceptor将对其进行批准，否则就拒绝。</p><p>Acceptor需要存储的内容：①已接受的编号最大的提案。②已响应的请求的最大编号。</p><p>两个承诺：</p><ol><li><p>不再接受N小于等于当前请求的Prepare请求。</p></li><li><p>不再接受N小于当前请求的Propose请求。</p></li></ol><p>一个应答：</p><p>不违背以前作出的承诺下，回复已经Accept过的提案中N最大的那个提案的Value和N，没有则返回空值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Promise* <span class="title function_">onPrepare</span><span class="params">(<span class="type">long</span> b)</span> &#123;        </span><br><span class="line">        <span class="comment">//假设这个过程有50%的几率失败</span></span><br><span class="line">        <span class="keyword">if</span> (rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.5</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; prepare no response&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b &gt;= this-&gt;pb) &#123;</span><br><span class="line">            pb = b;</span><br><span class="line">            Promise *response = new Promise(<span class="literal">true</span>, this-&gt;ab, this-&gt;av);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; prepare ok&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; prepare rejected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> new Promise(<span class="literal">false</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该阶段是由acceptor来具体实现的，为了使其更加实用，我定义了一个<code>promise.h</code>的头文件，将<code>promise</code>封装成了一个类，在第二阶段将其返回给proposer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">bool</span> ack;</span><br><span class="line">    <span class="type">long</span> ab;</span><br><span class="line">    <span class="built_in">string</span> av;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Promise(<span class="type">bool</span> ack, <span class="type">long</span> ab, <span class="built_in">string</span> av) &#123;</span><br><span class="line">        this-&gt;ack = ack;</span><br><span class="line">        this-&gt;ab = ab;</span><br><span class="line">        this-&gt;av = av;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isAck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getAb</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getAv</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> av;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Accept</p><p>第三阶段是Accept阶段，由Proposer来完成，即如果proposer收到了过半人数的回应，Proposer将会发出accept的回应<code>(N,V)</code>，该回应包含了提案编号及提案的内容。如果响应中不包含任何提案，那么V就由Proposer自己决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; acceptors.size(); i ++) &#123;  </span><br><span class="line">            Promise *promise = acceptors[i]-&gt;onPrepare(b);</span><br><span class="line">            <span class="keyword">if</span> (promise &amp;&amp; promise-&gt;isAck()) &#123;</span><br><span class="line">                count_pre_ok ++;</span><br><span class="line">                <span class="keyword">if</span> (promise-&gt;getAb() &gt; maxb &amp;&amp; promise-&gt;getAv() != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                    maxb = promise-&gt;getAb();</span><br><span class="line">                    v = promise-&gt;getAv();</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vote    : v change &lt; maxb : &quot;</span> &lt;&lt; maxb &lt;&lt; <span class="string">&quot; v : &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count_pre_ok &lt; quorum) &#123;        <span class="comment">//quorum为法定人数</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;prepare : end &lt;&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;&gt; : vote &lt; not accepted &gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count_accept_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; acceptors.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (acceptors[i]-&gt;onAccept(b, v)) &#123;</span><br><span class="line">                count_accept_ok ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count_accept_ok &lt; quorum) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;accept  : end &lt;&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&gt; : vote &lt; not accepted &gt;&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Accepted</p><p> 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">onAccept</span><span class="params">(<span class="type">long</span> b, <span class="built_in">string</span> v)</span> &#123;</span><br><span class="line">        <span class="comment">//假设这个过程有50%的几率失败</span></span><br><span class="line">        <span class="keyword">if</span> (rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.5</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; accept no response&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b == this-&gt;pb) &#123;</span><br><span class="line">            ab = b;</span><br><span class="line">            av = v;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; accept ok &lt; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; accept rejected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了模拟更真实的情况，在acceptor进行的两个阶段当中，都假设过程有50%的概率失败。</p><h3 id="实验中出现的问题"><a href="#实验中出现的问题" class="headerlink" title="实验中出现的问题"></a>实验中出现的问题</h3><p>在做该实验时我最大的困扰是边界问题。在Promise阶段，</p><ol><li>不再接受N<strong>小于等于</strong>当前请求的Prepare请求;</li><li>不再接受N<strong>小于</strong>当前请求的Propose请求。</li></ol><p>开始很多次都没做对，后来发现是这里的边界问题没处理好。</p></li></ul><h2 id="实验结果展示及分析"><a href="#实验结果展示及分析" class="headerlink" title="实验结果展示及分析"></a>实验结果展示及分析</h2><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124121028688.png" alt="image-20211124121028688"></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124121038481.png" alt="image-20211124121038481"></p><p>这是整个实验的一次随机生成的提案过程，最后达成共识得到提案成功。</p><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><ul><li><p>Liveness</p><p>经过资料查找后，我了解到Basic-Paxos可能会出现Liveness问题，但是在我多次尝试的过程中还没有出现过。</p><p>出现活锁的情况如下：两个承诺之一，Acceptor不再应答N小于等于当前请求的Prepare请求，意味着需要应答N大于当前请求的Prepare请求，若两个Proposers交替Prepare成功，而Accept失败，则形成活锁，使得提案一直不成功。</p><p>解决该问题的方案有两个，第一个就是加上时延，每次提案都等上次提案处理完再进行，这样不会形成活锁问题，但是这样处理会降低处理的效率，从而导致程序运行过慢。</p><p>后来提出的方案还有Multi-Paxos的处理方案，即选则一个Leader，只有Leader提交提案，这样就不会造成活锁问题。</p></li><li><p>实用性</p><p>Paxos算法认为，在信道不可信的前提下，通过消息传递的方式达成一致性，是不可能的。因此，Paxos算法的前提是不存在拜占庭将军问题。也就是，认为信道是可信的，集群间传递的消息，不会被篡改。因此，虽然它是共识算法的基础，中的但是它在区块链中其实是不太实用的，它达到了CAP定理中的C（一致性）、P（分区容忍性），但是牺牲了A（可用性）。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现共识算法中比较古老且复杂的共识算法PAXOS，几乎没有应用于区块链了。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="共识算法" scheme="http://example.com/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="信息安全环境与工具" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于QR码的防伪电子票数字水印方法</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E5%9F%BA%E4%BA%8EQR%E7%A0%81%E7%9A%84%E9%98%B2%E4%BC%AA%E7%94%B5%E5%AD%90%E7%A5%A8%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E5%9F%BA%E4%BA%8EQR%E7%A0%81%E7%9A%84%E9%98%B2%E4%BC%AA%E7%94%B5%E5%AD%90%E7%A5%A8%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%B3%95/</id>
    <published>2022-03-03T11:34:18.000Z</published>
    <updated>2022-03-04T12:10:53.432Z</updated>
    
    <content type="html"><![CDATA[<p>《信息安全环境与工具》的课程实验，实现在二维码上加暗水印的电子票，应用广泛，鲁棒性强。</p><span id="more"></span><h1 id="基于QR码的防伪电子票数字水印方法"><a href="#基于QR码的防伪电子票数字水印方法" class="headerlink" title="基于QR码的防伪电子票数字水印方法"></a>基于QR码的防伪电子票数字水印方法</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>比较防伪电子票数字水印算法和通常多媒体数字水印算法之间的差异，体会其实现方法的异同。</li><li><p>了解常见的二值图像数字水印算法在电子票中的性能，并体会该实验算法的优势。</p></li><li><p>实现防伪电子票的数字水印并体会其在安全方面的作用。</p></li><li>体会混沌密钥自适应调整策略，在确保条码信息可识别的情况下，最大限度提高嵌入的容量和鲁棒性。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>对于电子票防伪检测流程的整个过程如下：</p><p><img src="https://s2.loli.net/2022/03/03/En7fULzD9vQGopc.png" alt="image-20211124122310247"></p><p>接下来我将实现的是对其嵌入水印和提取水印的过程。</p><h3 id="处理嵌入水印"><a href="#处理嵌入水印" class="headerlink" title="处理嵌入水印"></a>处理嵌入水印</h3><p>因为电子票是二值图像，所以首先使用matlab中自带的函数<code>unicode2native()</code>将要嵌入的字符串转换成UTF-8编码，然后通过<code>dec2bin</code>函数将其转化为二值编码，并将其连接。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg_origin = unicode2native(<span class="string">&#x27;hahahahayouaremymoney1234564878998987:1176.71&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>); </span><br><span class="line">msg_bin = dec2bin(msg_origin, <span class="number">8</span>); </span><br><span class="line">msg = strjoin(cellstr(msg_bin)&#x27;,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="嵌入图像处理"><a href="#嵌入图像处理" class="headerlink" title="嵌入图像处理"></a>嵌入图像处理</h3><ul><li><p>二维映射转一维映射</p><p>电子票是二维的图像，所以首先我们应当将图像处理为一维的映射，然后再将水印嵌入。</p><p><img src="https://s2.loli.net/2022/03/03/z2divtoqGhreCNE.png" alt="image-20211124102755270"></p><p>通过二维矩阵转一维矩阵的方式，我们就成功实现了由维映射到一维映射的转换，代码实现如下：</p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reflect=[];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : width</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span> : high</span><br><span class="line">        reflect(<span class="built_in">i</span>+width*<span class="built_in">j</span>)=image(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>水印嵌入</p><p>水印嵌入使用的是Logistic混沌映射，以混沌密钥k为初始值产生混沌序列{$k_i$}，并由此产生坐标$x_i=[(M^2-1)k_i],i=0,1,2…$，取互相不重合的前N个位置$x_i$为水印嵌入位置，代码实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">size</span>(msg,<span class="number">2</span>);</span><br><span class="line">position=[];</span><br><span class="line">k=[];</span><br><span class="line">k(<span class="number">1</span>)=<span class="number">0.2</span>;</span><br><span class="line">u=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : N<span class="number">-1</span>    </span><br><span class="line">    k(<span class="built_in">i</span>+<span class="number">1</span>)=u*k(<span class="built_in">i</span>)*(<span class="number">1</span>-k(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接着，将这N个位置嵌入水印，其算法如下：</p><p><img src="https://s2.loli.net/2022/03/03/5QjmDpona26gYKz.png" alt="image-20211124103559112"></p><p>代码实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : N</span><br><span class="line">    position(<span class="built_in">i</span>)=<span class="built_in">fix</span>((width*width<span class="number">-1</span>)*k(<span class="built_in">i</span>))+width;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">j</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=position</span><br><span class="line">    msg_tmp=msg(<span class="built_in">j</span>);</span><br><span class="line">    reflect(<span class="built_in">i</span>)=msg_tmp;</span><br><span class="line">    <span class="built_in">disp</span>(reflect(<span class="built_in">i</span>));</span><br><span class="line">    <span class="built_in">j</span>=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>一维映射还原成二维图像</p><p>按照二维映射转一维映射的逆过程，我们可以将得到的水印嵌入后的二维图像，其代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : width</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span> : high</span><br><span class="line">        image_end(<span class="built_in">i</span>,<span class="built_in">j</span>)=reflect(<span class="built_in">i</span>+width*<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="提取水印"><a href="#提取水印" class="headerlink" title="提取水印"></a>提取水印</h3></li></ul><p>提取水印是嵌入水印的一个逆过程，此处不再重复上述过程。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">reflect=[];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : width</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:high</span><br><span class="line">             reflect(<span class="built_in">i</span>+width*<span class="built_in">j</span>)=image(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    k(<span class="number">1</span>)=key;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:lenth<span class="number">-1</span></span><br><span class="line">        k(<span class="built_in">i</span>+<span class="number">1</span>)=u*k(<span class="built_in">i</span>)*(<span class="number">1</span>-k(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : lenth</span><br><span class="line">        position(<span class="built_in">i</span>)=<span class="built_in">fix</span>((width*width<span class="number">-1</span>)*k(<span class="built_in">i</span>))+width;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    watermarking=[];</span><br><span class="line">    index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=position</span><br><span class="line">        msg_num=reflect(<span class="built_in">i</span>)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">disp</span>(reflect(<span class="built_in">i</span>));</span><br><span class="line">        watermarking(index)=msg_num;</span><br><span class="line">        index=index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    msg=blanks(<span class="number">104</span>);</span><br><span class="line">    len=<span class="built_in">size</span>(watermarking,<span class="number">2</span>);</span><br><span class="line">    msg=num2str(watermarking);<span class="comment">%将提取出的数字转化为字符串</span></span><br><span class="line">    msg_bin=strrep(msg,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>);<span class="comment">%串替换</span></span><br><span class="line">    index=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>提取出来以后，同样通过字符编码转换的方式得到我们最开始输入的字符串：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msg_origin=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">8</span>:<span class="built_in">size</span>(watermarking,<span class="number">2</span>)<span class="number">-7</span></span><br><span class="line">        rgb(index) = bin2dec(msg_bin(<span class="built_in">i</span> : <span class="built_in">i</span>+<span class="number">7</span>));</span><br><span class="line">        msg_origin =native2unicode(rgb, <span class="string">&#x27;UTF-8&#x27;</span>);</span><br><span class="line">        index=index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(msg_origin);</span><br></pre></td></tr></table></figure><p>至此为止，实验的过程大致完毕。</p><h2 id="实验中出现的问题"><a href="#实验中出现的问题" class="headerlink" title="实验中出现的问题"></a>实验中出现的问题</h2><p>由于对matlab的函数不够熟悉，在实现字符串转化成二进制时开始出现了问题，后来通过加入先转换为<code>utf-8</code>编码将问题解决，即：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg_origin = unicode2native(<span class="string">&#x27;hahahahayouaremymoney1234564878998987:1176.71&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>); </span><br><span class="line">msg_bin = dec2bin(msg_origin, <span class="number">8</span>); </span><br><span class="line">msg = strjoin(cellstr(msg_bin)&#x27;,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="实验结果展示及分析"><a href="#实验结果展示及分析" class="headerlink" title="实验结果展示及分析"></a>实验结果展示及分析</h2><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p>我使用二维码生成器生成了一个网页的二维码来替代电子票，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/03/GSZbeWtlThFEvCA.png" alt="QR"></p><p>通过<code>embed</code>处理后，得到的结果为：</p><p><img src="https://s2.loli.net/2022/03/03/ScGx8Crb3QHihfu.png" alt="result"></p><p>从肉眼看上去，会多出一些小点点，但是并不影响机器的扫描，接着我们使用<code>extract</code>成功从中提取了我们之前嵌入的字符串水印：</p><p><img src="https://s2.loli.net/2022/03/03/gwdzN54UqYDlQSH.png" alt="image-20211124104848894"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><div class="table-container"><table><thead><tr><th>水印长度/bits</th><th><strong>平均自适应调准次数</strong></th><th><strong>识别率/%</strong></th><th><strong>鲁棒性</strong></th></tr></thead><tbody><tr><td>32</td><td>0.2</td><td>100</td><td>很强</td></tr><tr><td>62</td><td>2.7</td><td>100</td><td>很强</td></tr><tr><td>128</td><td>21.5</td><td>100</td><td>很强</td></tr><tr><td>160</td><td>49.8</td><td>63.68</td><td>较强</td></tr></tbody></table></div><p>通过多次实验可以得到如上的表格，从表格中我们可以看出当嵌入水印达到128bits时，本算法仍然能够完全正确地识别出电子票，当水印长度增加到160bits时，只有63.68%的试验能够完成自适应水印嵌入，并且自适应调整的次数较多。鲁棒性越强，电子票的伪造难度就越大。在实际应用中，128bits的水印已经足够防伪系统的使用，因此，该系统是比较完善的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《信息安全环境与工具》的课程实验，实现在二维码上加暗水印的电子票，应用广泛，鲁棒性强。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="信息安全环境与工具" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
    <category term="数字水印" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>本地差分隐私研究综述</title>
    <link href="http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E6%9C%AC%E5%9C%B0%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/"/>
    <id>http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E6%9C%AC%E5%9C%B0%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/</id>
    <published>2022-03-03T11:32:32.000Z</published>
    <updated>2022-03-03T11:33:29.569Z</updated>
    
    <content type="html"><![CDATA[<p>对2018年软件学报论文的翻译。</p><span id="more"></span><h1 id="本地化差分隐私研究综述"><a href="#本地化差分隐私研究综述" class="headerlink" title="本地化差分隐私研究综述"></a>本地化差分隐私研究综述</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本地化差分隐私技术应用场景：</p><ul><li><p>众包数据采集</p><p>数据收集者将数据采集任务分配给不同用户进行。当用户参与众包数据采集时，不可避免存在泄露个人敏感信息的风险，这时就需要隐私保护技术为其保驾护航。</p></li><li><p>敏感图像特征提取</p><p>很多来自个人的形象蕴含很多敏感信息，如人脸、指纹等，对此类图像的存储和分析过程进行相应的隐私保护。本地化差分隐私技术在用户端完成对图像的扰动处理，保证无论是数据收集者或者数据传输过程中的攻击者均无法窃取图像中的隐私信息。（可以改？</p></li></ul><p>研究时考虑的问题：</p><ul><li>如何设计满足ε-本地化差分隐私的数据扰动算法，以保护其中敏感信息</li><li>数据收集者如何对查询结果进行求精处理，以提高统计结果的可用性</li></ul><p>本文内容：</p><ul><li>最新进展，研究背景，基本定义，实现机制，与中心化差分隐私技术区别</li><li>研究方向分析，着重介绍数据扰动机制以及两种基本数据发布形式：频数统计，均值统计</li><li>提出未来研究方向并分析</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对数据进行隐私化处理—&gt;将处理后的数据发给数据收集者—&gt;收集者对采集到的数据进行统计并得到分析结果</p><p>即在对数据进行统计分析的同时，保证个体的隐私信息不被泄露</p><blockquote><p>定义1：</p></blockquote><p>控制任意两条记录输出结果的相似性，确保算法M满足ε-本地化差分隐私。</p><p>根据M的输出结果，几乎无法推理出输入数据为哪一条记录。</p><h3 id="扰动机制"><a href="#扰动机制" class="headerlink" title="扰动机制"></a>扰动机制</h3><p>随机相应技术(W-RR)是本地化差分隐私的主流扰动机制。</p><p>W-RR是利用对敏感问题响应的不确定性对原始数据进行隐私保护，主要包括两个步骤：扰动性统计和校正。</p><ul><li><p>扰动性统计</p><p>举例（艾滋病患者的例子）按想法求比例-&gt;构造似然函数-&gt;得到极大似然估计（保证其无偏）-&gt;根据定义计算ε</p></li><li><p>离散型数据的W-RR</p><p>W-RR仅对包含两种取值的离散型数据进行响应，对具有超过两种取值的数据并不适用，因此有两种思路</p><ul><li><p>对变量的不同取值进行编码转化，使其满足W-RR对二值变量的要求。k个候选值，将每一个都编码成logk取上界的0/1串，然后对每一位上的0/1进行随机响应。</p><p>缺点：logk并非刚好取整，因此存在某些0/1串未能匹配到相应候选值，由此造成匹配误差以及随机相应技术本身的扰动误差，使得数据发布的可用性降低。因此技术难点在属性候选值的编码和匹配策略上。</p></li><li><p>改进W-RR技术，使其能够直接适用于超过两种取值的变量。具体来说，就是保证概率的分布能够覆盖到k种取值中的任意一种。（k-RR和O-RR）</p></li></ul></li><li><p>连续型数据的W-RR</p><p>将连续型数据离散化，然后用离散型数据下的随机响应方法对其进行扰动。</p><p>难点：合理设置离散化的两个数值，如何保证统计结果无偏性</p></li></ul><h3 id="本地化与中心化差分隐私的异同点"><a href="#本地化与中心化差分隐私的异同点" class="headerlink" title="本地化与中心化差分隐私的异同点"></a>本地化与中心化差分隐私的异同点</h3><p>本地化继承中心化的组合特性，同时又对其进行了扩展，利用W-RR的扰动机制抵抗不可信第三方数据收集者带来的隐私攻击。</p><ul><li><p>组合特性</p><ul><li><p>序列组合性</p><p>隐私预算ε可以在方法的不同步骤进行分配，n个隐私算法{$M_1…M_n$}满足$ε_i$-本地化差分隐私，则在数据集合D上的序列组合满足ε-本地化差分隐私，ε为$ε_i$的和</p></li><li><p>并行组合性</p><p>保证满足差分隐私的算法在数据集的不相交子集上的隐私性。M在{$D_1,…,D_n$}都满足ε本地化差分隐私</p></li></ul></li><li><p>可信与不可信第三方</p><p>中心化：有可信第三方数据收集者，每个用户将真实数据记录发送给数据收集者，并假定其可信，不会泄露个人敏感信息。数据收集者用隐私算法对数据分析者的查询进行响应。</p><p>本地化：第三方数据收集者不可信，将数据扰动功能从数据收集方转移到了客户端，即每个用户处。每个用户按照隐私算法对数据进行扰动，然后把数据上传数据收集者，数据收集者接受数据分析者的查询请求，并进行响应。</p></li><li><p>噪声机制</p><p>中心化：有全局敏感性，需要噪声机制介入。</p><p>本地化：任意两个用户之间并不知晓对方数据记录，没有全局敏感性，用W-RR技术。</p></li><li><p>应用场景</p><p>中心化：对统计数据量不作特别要求。</p><p>本地化：噪声随机，要保证统计结果的无偏性，需要海量数据集来实现满足数据可用性的统计精度。</p></li></ul><h2 id="数据保护框架"><a href="#数据保护框架" class="headerlink" title="数据保护框架"></a>数据保护框架</h2><ul><li><p>交互式</p><p>第$i$个输出$Z<em>i$依赖于第i个输入$X_i$，以及前i个输出$Z</em>{1:i-1}$，但与前i个输入$X_{1：i-1}$无依赖关系</p><p>交互式通常应用于家族遗传病，性状等</p></li><li><p>非交互式</p><p>第$i$个输出$Z_i$仅依赖于第$i$个输入$X_i$</p><p>非交互式通常应用于商场购物数量等</p></li></ul><p>这两者最大区别在于输出结果之间的关联性。</p><h2 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h2><ul><li><p>本地化差分隐私的扰动机制研究</p><p>主要包括随机响应、信息压缩和扭曲</p></li><li><p>基于本地化差分隐私的单值频数发布</p></li><li><p>基于本地化差分隐私的多值频数发布</p></li><li><p>基于本地化差分隐私的均值发布</p></li></ul><h2 id="方法对比与分析"><a href="#方法对比与分析" class="headerlink" title="方法对比与分析"></a>方法对比与分析</h2><h3 id="基于本地化差分隐私的频数统计"><a href="#基于本地化差分隐私的频数统计" class="headerlink" title="基于本地化差分隐私的频数统计"></a>基于本地化差分隐私的频数统计</h3><ul><li><p>单值频数统计</p><p>单值频数统计是指每个用户只发送一个变量取值的情形。用户把数据发送给收集者，收集者根据已有的或统计得到的候选值列表，统计其中每个候选值的频数并发布。</p><p>代表方法：RAPPOR</p><p>其中变量以字符串的形式表示（Bloom Filter）</p><p>第一次扰动，用W-RR对向量B的每一个位进行扰动，得到PRR（永久性随机响应）结果B’</p><p>然后对B’的每一个位进行第二次扰动，得到IRR（瞬时性随机响应）结果S</p><p>将S发送给第三方数据收集者，数据收集者统计每一位上1出现的次数并进行校正，然后结合映射矩阵通过Lasso回归方法完成每个年龄值对应的频数统计</p><p>误差：1）Bloom Filter进行编码，在解码过程中可能存在属性候选值冲突问题————&gt;RAPPOR调整相应参数降低候选值冲突带来的误差；2）W-RR对数据扰动产生的误差问题，数据扰动带来的渐进误差边界为$O(k/ε\sqrt{n})$，这是算法本身固有误差。</p><p>缺陷：<strong>1）传输代价较高，每个用户都要传输长度为h的向量给数据收集者；</strong></p><p>解决方案：S-Hist中每个用户对字符串进行编码后，随机选择其中一个比特位，利用W-RR扰动，将其发送给数据收集者。</p><p>同时，假设列表中字符串候选值个数k超过了用户数量n，利用随机投影技术将每个字符串表示成m=O(n)维二值变量，生成一个随机投影矩阵，其中每个元素的取值集合为{$1/\sqrt{m},-1/\sqrt{m}$}，以使得矩阵中每个列向量的内积为1，而任意不同两个列向量的内积为0。渐进误差边界：$O(\sqrt{logk}/ε\sqrt{n})$</p><p>优点：极大降低通信代价</p><p><strong>2）数据收集者需预先采集候选字符串列表以进行频数统计；</strong></p><p>解决方案：O-RAPPOR</p><p>在RAPPOR的基础上引入哈希映射和分组操作。对于每个字符串，先用哈希函数进行一次值的映射，后续的扰动步骤直接对哈希值进行处理，这样就不需要预知候选字符串的列表</p></li><li><p>多值频数统计</p><p>每个用户发送多个变量取值的情形，用户将数据发送给数据收集者后，数据收集者根据已有的或统计得到的候选值列表，统计其中每一个候选值的频数并进行发布。</p><p>需要考虑隐私预算的分割问题。可以将单值频数统计方法重复地用在多值情形中的每一个变量上，但是如此可能导致两个问题：</p><p>1）根据变量的数量分割隐私预算，当变量较多时，数据可用性急剧降低</p><p>2）忽略了变量之间的关联关系，损失部分信息———-&gt;&gt;预先采集候选字符串列表</p><p>针对2）有一个方法，</p><ul><li><p>RAPPOR-unknown。</p><p>它基于n-gram（字符串长度为n的子串）的思想，得到扰动结果后，从字符串中抽取r个长度相同的子串，然后将扰动结果和子串相关信息一起发给第三方数据收集者。</p><p>RAPPOR-unknown是将隐私预算ε进行（r+1)等分，分别分配给扰动结果和r个子串的计算过程。</p><p>采集数据后，数据收集者通过共现技术还原字符串，以得到字符串列表。针对多值的情形，RAPPOR-unknown利用期望最大化算法，估计多个变量的联合概率分布，以进行列联表的查询。</p><p>该方法要将子串及其位置信息一起传输给数据收集者用于统计候选值列表，比RAPPOR方法多出O(r)的传输代价，不适合字串较多的情形。</p></li><li><p>Harmony-frequency</p><p>S-Hist方法虽然极大降低了通信代价，但在实际应用中稳定性不确定，因为随机投影矩阵中每个元素的正负取值具有随机性，要使任意两个列向量的内积为0，前提是字符串的候选值k足够大。</p><p>针对关系型数据，又提出了Harmony方法，可用于连续型数据的均值统计和离散型数据的频数统计两种查询。</p><p>其运用于频数统计的方法叫做Harmony-frequency，该方法改进了随机投影矩阵，用迭代的方式生成一个k×k的随机投影矩阵，其中保证了矩阵任意两个列向量正交（内积为0），渐进误差边界：$O(\sqrt{dlogk}/ε\sqrt{n})$，<strong>有更高的发布精度</strong>。</p></li><li><p>LDPMiner</p><p>是集值数据下的频数发布方法，针对Heavy hitter查询。1）数据收集者采集数据，确定Heavy hitter集合并将其返回给用户；2）用户发送集合中k’个项所对应的数据。</p><p>LDPMiner是基于RAPPOR和S-Hist方法实现的一个组合方法。因为每个用户需要发送多个数据项，通信代价较高，因此用随机采样技术令每个用户只发送其中一个数据项，然后用RAPPOR和S-Hist方法来进行数据扰动。</p><p>采样+RAPPOR—&gt;sampling RAPPOR</p><p>采样+S-Hist—&gt;sampling SH</p><p>LDPMiner的两个阶段：</p><p>阶段1：sampling SH：用户通过sampling SH将扰动后的数据发送给数据收集者，数据收集者统计每个数据项的频数，确定频数最高的k’个项的集合，并将该集合返回给用户</p><p>阶段2：sampling RAPPOR：用户通过sampling RAPPOR将阶段一返回的数据项所对应的数据再次发送给数据收集者，数据收集者统计每个数据项的频数，得到k’个数据项的频数</p><p>从两个方面的数据处理提高数据可用性：</p><p>1）通过采样技术避免了隐私预算在不同数据项上的分割；</p><p>2）频繁项集合的确定和频数统计两个操作分离，缩小了需要扰动的数据项集合，增大了k‘个数据项所分配到的隐私预算</p></li><li><p>Lopub</p><p>结合RAPPOR和概率图模型的多值频数统计方法。</p><p>思路：</p><p>1）用户的数据扰动；==&gt;RAPPOR</p><p>2）数据收集者估计联合概率分布并进行数据降维；==&gt;构建马尔科夫网络，利用属性之间的关联性得到极大团，并将属性的联合概率分布以极大团的形式来表示，以达到数据降维的目的。</p><p>3）合成数据集。==&gt;通过联合概率分布重新合成一个数据集进行数据发布</p></li><li><p>多值频数统计方法对比分析</p></li></ul></li></ul><h3 id="基于本地化差分隐私的均值统计"><a href="#基于本地化差分隐私的均值统计" class="headerlink" title="基于本地化差分隐私的均值统计"></a>基于本地化差分隐私的均值统计</h3><p>  主要思想：对个体值添加正向和负向的噪声，最终通过聚合大量扰动结果将其抵消，从而使统计结果满足一定的可用性要求。</p><p>  代表方法：MeanEst，Harmony-mean</p><ul><li><p>MeanEst</p><p>将包含n个元组的d维数据集中的第i个元组按照一定概率分布，并结合随机响应技术，转变成一个仅含二值变量的元组，同时保证最终的统计结果是一个无偏估计量，其中B的计算仅与隐私预算ε和数据维度d有关。</p><p>该方法的值与数据集的维度d呈指数关系，当数据集的维度比较高时，所需的时间和空间代价都比较高，使得B值的计算受到限制。因此，<strong>不适用于维度d较高的数据集</strong>。</p></li><li><p>Harmony-mean</p><p>简化了MeanEst方法，从d个数据维度中随机抽取一个维度j，最终输出的元组中仅一个维度上的变量有相应的取值，而其他维度上变量的取值为0。通信代价为MeanEst的1/d，渐进误差边界与其相同，有相近的发布精度。</p></li><li><p>均值统计方法对比分析</p></li></ul><h3 id="基于信息压缩和扭曲的扰动机制"><a href="#基于信息压缩和扭曲的扰动机制" class="headerlink" title="基于信息压缩和扭曲的扰动机制"></a>基于信息压缩和扭曲的扰动机制</h3><ul><li><p>Compression</p><p>每个用户对应一个d维的元组X，对输入域进行压缩，得到X’，压缩过程保证元组X与X‘的对应关系满足本地化差分隐私保护。</p><p>进行压缩会产生偏差，引入扭曲度对偏差的期望进行约束</p><p>==&gt;把问题转化为给定扭曲度δ和压缩率ρ，求最小ε的凸优化 \==&gt; 二分法求解</p><p>其中ε表示隐私的保护程度，δ表示数据统计结果的可用性，通过压缩率将两者直接联系起来。</p></li><li><p>Distortion</p><p>通过扰动函数对X进行扰动得到X’，然后定义信息扭曲度约束其偏差，保证数据具有一定的可用性。</p></li></ul><h3 id="本地化差分隐私技术的实验特性分析"><a href="#本地化差分隐私技术的实验特性分析" class="headerlink" title="本地化差分隐私技术的实验特性分析"></a>本地化差分隐私技术的实验特性分析</h3><p>  本地化差分隐私技术主要依赖于ε的设定，ε的取值决定了隐私化处理后数据的可用性高低。但同时，对数据集的数据量有一定的要求，数据量也是影响数据可用性的一个重要因素。</p><ul><li><p>隐私预算对数据可用性的影响</p><p>隐私保护程度与数据可用性呈负相关。当给定较多的隐私预算时，统计结果比较接近真实值。</p></li><li><p>数据量对数据可用性的影响</p><p>同样的隐私预算的情况下，统计的数据量小时，偏差较大；统计的数据量大时，偏差较小。</p></li></ul><h2 id="研究挑战"><a href="#研究挑战" class="headerlink" title="研究挑战"></a>研究挑战</h2><p>目前的研究主要集中在两个方面：</p><p>1）理论上，设计满足本地化差分隐私的保护机制；</p><p>2）方法上，对频数和均值两种统计结果进行保护</p><p>现在还有很多挑战性的问题未解决：</p><h3 id="复杂数据类型的本地化差分隐私保护"><a href="#复杂数据类型的本地化差分隐私保护" class="headerlink" title="复杂数据类型的本地化差分隐私保护"></a>复杂数据类型的本地化差分隐私保护</h3><p>e.g.</p><p>键值对：需要对键和值都进行隐私化处理，且仍需保证“键”和“值”之间的对应性</p><p>图数据：全局敏感性极高，本地化差分隐私技术虽然不存在敏感性过大的问题，但每个用户对数据扰动过程相互独立，数据收集者如何根据扰动后的数据构建可用性高的图结构，即如何保证原始数据之间的关联性是一大挑战。</p><h3 id="不同查询和分析任务的本地化差分隐私保护"><a href="#不同查询和分析任务的本地化差分隐私保护" class="headerlink" title="不同查询和分析任务的本地化差分隐私保护"></a>不同查询和分析任务的本地化差分隐私保护</h3><p>本地化差分隐私下，不仅要求能够支持不同的查询类型，还要求扰动后的数据能够同时支持多种不同的查询。本地化差分隐私通过抵消添加在数据中的正向和负向噪声来得到比较准确的统计结果，就单条数据而言通常扰动前后数据偏差较大，加大了查询难度。</p><p>因此主要考虑以下三种实现方法：</p><p>1）提供对除计数查询和均值查询外的多种查询方式的支持；</p><p>2）数据扰动方式与查询类型的解绑，使得扰动后的数据给、能够同时支持多种查询；</p><p>3）提高数据分析结果的可用性。</p><h3 id="基于本地化差分隐私的高维数据发布"><a href="#基于本地化差分隐私的高维数据发布" class="headerlink" title="基于本地化差分隐私的高维数据发布"></a>基于本地化差分隐私的高维数据发布</h3><p>属性个数较多==&gt;数据维度较高\==&gt;数据规模变大，信噪比降低，增加通信代价（线性/指数增长）</p><p>目前的解决方案：属性划分</p><p>在满足本地化差分隐私的基础上，将高维数据的联合概率分布分解为多个低维的边缘概率分布形式，然后将其通过某种推理机制近似估计联合概率分布。</p><p>但是该方法在高维数据的情况下会带来很大噪声，使得推理结果准确性大大降低。</p><p>因此考虑三个问题：</p><p>1）如何在一定隐私预算内衡量属性之间的关联性，从而进行降维处理；</p><p>2）如何设计推理模型，最小化边缘分布到联合分布的近似误差，提高数据可用性；</p><p>3）如何控制高维数据在用户和数据收集者之间的通信代价</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对2018年软件学报论文的翻译。&lt;/p&gt;</summary>
    
    
    
    <category term="隐私计算" scheme="http://example.com/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="隐私计算" scheme="http://example.com/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="差分隐私" scheme="http://example.com/tags/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>静态分析基础</title>
    <link href="http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-03T11:30:15.000Z</published>
    <updated>2022-03-03T12:03:08.545Z</updated>
    
    <content type="html"><![CDATA[<p>恶意代码分析的基础——静态分析，分析程序指令与结构来确定功能。</p><span id="more"></span><h1 id="静态分析基础"><a href="#静态分析基础" class="headerlink" title="静态分析基础"></a>静态分析基础</h1><p>[toc]</p><p>静态分析指的是分析程序指令与结构来确定功能的过程。</p><h2 id="1-1-反病毒引擎扫描：实用的第一步"><a href="#1-1-反病毒引擎扫描：实用的第一步" class="headerlink" title="1.1 反病毒引擎扫描：实用的第一步"></a>1.1 反病毒引擎扫描：实用的第一步</h2><p>分析可疑的恶意代码样本时，第一步就是拿多个反病毒软件扫描这个文件，看是否有哪个引擎已经能够识别它。</p><p>反病毒软件=&gt;依靠一个已知恶意代码可识别片段的特征数据库，以及基于行为与模式匹配的分析来识别可疑文件。</p><p>编写者=&gt;修改代码，改变特征，躲避反病毒引擎的检测。</p><p>而且一些罕见的恶意代码根本不在特征数据库里。</p><p>启发式检测经常也能识别一些未知的恶意代码，但仍然可以被一些新型的恶意代码绕过。</p><p>不同的反病毒软件特征库和启发式检测不一样，因此对一个恶意代码样本，要运行多个进行扫描检测。</p><p><a href="https://www.virustotal.com/gui/home/upload">VirrusTotal</a>可以上传一个文件，调用多个引擎扫描生成一个报告。</p><h2 id="1-2-哈希值：恶意代码的指纹"><a href="#1-2-哈希值：恶意代码的指纹" class="headerlink" title="1.2 哈希值：恶意代码的指纹"></a>1.2 哈希值：恶意代码的指纹</h2><p>哈希是一种用来唯一标识恶意代码的常用方法。恶意代码样本通过一个哈希程序，会产生出一段用于唯一标识这个样本的独特哈希值。</p><p>常用于恶意代码分析的哈希函数：</p><ul><li>MD5算法</li><li>SHA-1算法</li></ul><p><code>md5deep</code>可以计算Windows自带的Solitaire程序哈希值</p><p>当对一段恶意代码样本有了一段独特的哈希值之后，可以将其用于：</p><ul><li>作为标签使用</li><li>与其他人分享，以帮助他们识别恶意代码</li><li>在线搜索这段哈希值，看这个文件是否已经被识别</li></ul><h2 id="1-3-查找字符串"><a href="#1-3-查找字符串" class="headerlink" title="1.3 查找字符串"></a>1.3 查找字符串</h2><p>一个程序会包含一些字符串，如：打印出的消息，连接的URL，或是复制文件到某个特定位置。</p><p>从字符串中进行搜索是获得程序功能提示的一种简单方法。比如程序访问了一个URL，访问的URL就存储为程序中的一个字符串。可以使用<a href="technet.microsoft.com/en-us/sysinternals/bb897439">String</a>来搜索可执行文件中可打印的字符串，通常以ASCII或Unicode格式存储。</p><p>这两种格式都以NULL结束符表示字符串已经终结。一个NULL结束符表示该字符串是完整的。ASCII码每个字符用1B，Unicode用2B。</p><p>Strings程序从可执行程序中搜索ASCII和Unicode字符串时，忽略上下文和格式，所以它将分析任何文件类型，并从中检测出可以打印的字符串，<strong>可能会识别出实际上并非真正字符串的一些字符序列</strong>。它搜索三个及三个以上的连续ASCII和Unicode字符，并以终结符结尾的字符串。</p><p>但是一般检测出来，如果是无效的字符串，肉眼是很容易判断的，因为他们并不代表一些合法的文字。</p><p>DLL文件中包含着一个应用程序中共享的可执行代码。</p><h2 id="1-4-加壳与混淆恶意代码"><a href="#1-4-加壳与混淆恶意代码" class="headerlink" title="1.4 加壳与混淆恶意代码"></a>1.4 加壳与混淆恶意代码</h2><p><strong>混淆程序是恶意代码编写者尝试去隐藏其执行过程的代码。</strong></p><p>加壳程序是混淆程序中的一类，加壳后的恶意程序会被压缩，难以分析。</p><h3 id="1-4-1-文件加壳"><a href="#1-4-1-文件加壳" class="headerlink" title="1.4.1 文件加壳"></a>1.4.1 文件加壳</h3><p>加壳程序运行：运行一小段脱壳代码=&gt;解压缩加壳的文件=&gt;运行脱壳后的文件</p><p>进行静态分析时，只有一小段脱壳代码可以被解析。</p><h3 id="1-4-2-使用PEiD检测加壳"><a href="#1-4-2-使用PEiD检测加壳" class="headerlink" title="1.4.2 使用PEiD检测加壳"></a>1.4.2 使用PEiD检测加壳</h3><p>检测加壳软件的一种方法是使用PEiD工具。</p><p>使用UPX加壳的恶意代码比较容易进行脱壳处理，下载UPX工具就行，然后输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -d PackedProgram.exe</span><br></pre></td></tr></table></figure><h2 id="1-5-PE文件格式"><a href="#1-5-PE文件格式" class="headerlink" title="1.5 PE文件格式"></a>1.5 PE文件格式</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;恶意代码分析的基础——静态分析，分析程序指令与结构来确定功能。&lt;/p&gt;</summary>
    
    
    
    <category term="恶意代码分析实战" scheme="http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="恶意代码" scheme="http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析入门</title>
    <link href="http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-03T11:28:13.000Z</published>
    <updated>2022-03-03T11:29:28.103Z</updated>
    
    <content type="html"><![CDATA[<p>恶意代码分析入门概念。</p><span id="more"></span><h1 id="恶意代码分析技术入门"><a href="#恶意代码分析技术入门" class="headerlink" title="恶意代码分析技术入门"></a>恶意代码分析技术入门</h1><h2 id="0-1-恶意代码分析目标"><a href="#0-1-恶意代码分析目标" class="headerlink" title="0.1 恶意代码分析目标"></a>0.1 恶意代码分析目标</h2><ul><li>定位受感染的主机和文件</li><li>编写相应特征码=&gt;检测感染主机</li><li>基于特征码，检测恶意代码</li><li>网络特征码=&gt;监测网络流量检测恶意代码</li><li>弄清恶意代码如何工作</li></ul><h2 id="0-2-恶意代码分析技术"><a href="#0-2-恶意代码分析技术" class="headerlink" title="0.2 恶意代码分析技术"></a>0.2 恶意代码分析技术</h2><p>恶意代码分析有两种技术：静态分析，动态分析。静态分析是指没有运行代码时对其进行分析，动态分析则需要运行代码。</p><h3 id="0-2-1-静态分析基础技术"><a href="#0-2-1-静态分析基础技术" class="headerlink" title="0.2.1 静态分析基础技术"></a>0.2.1 静态分析基础技术</h3><ul><li>检查可执行文件但不查看具体命令</li><li>可以确认一个文件是否是恶意的</li><li>可能提供一些信息可以生成网络特征码</li><li>很快速，但大多数时候无效</li></ul><h3 id="0-2-2-动态分析基础技术"><a href="#0-2-2-动态分析基础技术" class="headerlink" title="0.2.2 动态分析基础技术"></a>0.2.2 动态分析基础技术</h3><ul><li>运行恶意代码并观察系统上的行为，以移除感染，产生有效的检测特征码</li><li>前提是建立一个安全环境，能够避免对系统和网络带来风险</li></ul><h3 id="0-2-3-静态分析高级技术"><a href="#0-2-3-静态分析高级技术" class="headerlink" title="0.2.3 静态分析高级技术"></a>0.2.3 静态分析高级技术</h3><ul><li>对恶意代码内部机制的逆向工程</li><li>将可执行文件装入反汇编器中，通过查看程序指令来发现恶意代码做了什么</li></ul><h3 id="0-2-4-动态分析高级技术"><a href="#0-2-4-动态分析高级技术" class="headerlink" title="0.2.4 动态分析高级技术"></a>0.2.4 动态分析高级技术</h3><ul><li>使用调试器来检查一个恶意可执行程序运行时刻的内部状态</li><li>可以从可执行文件中抽取详细的信息</li></ul><h2 id="0-3-恶意代码类型"><a href="#0-3-恶意代码类型" class="headerlink" title="0.3 恶意代码类型"></a>0.3 恶意代码类型</h2><ul><li><strong>后门</strong>：将自身安装到一台计算机来允许攻击者访问。通常让攻击者只需很少的认证或无须认证便可连接到远程计算机，并在本地系统执行命令。</li><li><strong>僵尸网络</strong>：允许攻击者访问系统，和后门类似。所有被同一个僵尸网络感染的计算机将会从一台控制命令服务器接收到相同的命令。</li><li><strong>下载器</strong>：下载其他恶意代码的恶意代码。在攻击者获得系统访问时首先进行安装的，下载器程序会下载和安装其他的恶意代码。</li><li><strong>间谍软件</strong>：从受害计算机上收集信息并发送给攻击者的恶意代码。</li><li><strong>启动器</strong>：启动其他恶意程序的恶意代码。一般使用一些非传统技术来启动其他恶意程序，以确保隐蔽性或以更高的权限访问系统。</li><li><strong>内核套件</strong>：隐藏其他恶意代码的恶意代码。通常和其他恶意代码组合成工具套装，来允许为攻击者提供远程访问，并且使其很难被受害者发现。</li><li><strong>勒索软件</strong>：吓唬受感染用户，勒索他们购买某些东西的恶意代码。（一般长得像杀毒软件，通知用户系统中有恶意代码，需要出钱买，然而事实上功能只是将勒索软件进行移除）</li><li><strong>发送垃圾邮件的恶意代码</strong>：感染计算机后使用系统和网络资源来发送大量垃圾邮件。（通过为攻击者出售垃圾邮件发送服务获益）</li><li><strong>蠕虫、计算机病毒</strong>：可以自我复制和感染其他计算机的恶意代码。</li></ul><p>恶意代码分为大众性的和针对性的，大众性的更容易被检测和防御，而针对性的比较难。</p><h2 id="0-4-恶意代码分析通用原则"><a href="#0-4-恶意代码分析通用原则" class="headerlink" title="0.4 恶意代码分析通用原则"></a>0.4 恶意代码分析通用原则</h2><ul><li>不要过于陷入细节。要先关注最关键的主要功能，先有一个概要性的了解。</li><li>对于不同的 任务使用不同的工具和方法。</li><li>不断更新技术。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;恶意代码分析入门概念。&lt;/p&gt;</summary>
    
    
    
    <category term="恶意代码分析实战" scheme="http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="恶意代码" scheme="http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>

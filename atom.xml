<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhong Kangwei&#39;s Blog</title>
  
  <subtitle>Learn and Live.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-03T03:02:39.585Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zhong Kangwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git使用&amp;多人开发</title>
    <link href="http://example.com/Tools/Git%E4%BD%BF%E7%94%A8-%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/Tools/Git%E4%BD%BF%E7%94%A8-%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91/</id>
    <published>2022-03-03T02:50:05.000Z</published>
    <updated>2022-03-03T03:02:39.585Z</updated>
    
    <content type="html"><![CDATA[<p>最近系统地学习了Git的使用方法和多人开发技术，这里是一些比较通俗易懂的记录，还有更进阶的部分还有待学习……</p><span id="more"></span><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h4><ul><li>工作区：仓库的目录，独立于各个分支</li><li>暂存区：数据暂时存放的区域，是工作区写入版本库之前的缓存区，独立于各个分支</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中的每个节点代表一个代码版本</li></ul><h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><ul><li><p>设置全局用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name xxx</span><br></pre></td></tr></table></figure><p>信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p>设置全局邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email xxx@xxx</span><br></pre></td></tr></table></figure><p>信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p>初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中（<code>ls -a</code>可以显示隐藏的文件夹）</p></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p><strong>文件-&gt;暂存区</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xx</span><br></pre></td></tr></table></figure><p>将xx文件添加到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>将所有待加入暂存区的文件加入暂存区</p></li><li><p><strong>暂存区&#x3D;&gt;版本库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;备注信息&quot;</span><br></pre></td></tr></table></figure><p>将暂存区的内容全部提交到当前分支</p><ul><li><p>提交修改的<strong>部分</strong>文件</p><p>在add到暂存区里的时候只加需要提交的几个文件，则提交的时候新的版本只会修改这几个文件</p></li></ul></li><li><p><strong>查看仓库状态</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前分支的所有版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p><strong>将当前分支推送到远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u (第一次需要-u以后不需要)</span><br></pre></td></tr></table></figure></li><li><p><strong>克隆</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxxx@xxxxxx</span><br></pre></td></tr></table></figure></li><li><p><strong>查看所有分支和当前所处分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li></ul><h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><ul><li><p><strong>查看状态</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看仓库状态</p></li><li><p><strong>查看对比</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看相对于暂存区修改了哪些内容</p></li><li><p><strong>查看版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>查看当前分支的所有版本(从下到上显示)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><p>每个版本用一行来显示</p></li><li><p><strong>查看HEAD指针的移动历史（包括回滚）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li><li><p><strong>查看所有分支和当前分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><ul><li><p><strong>把文件从暂存区去除</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached xx</span><br></pre></td></tr></table></figure><p>在暂存区中将该文件删除，取消跟踪（类似于工作区中刚创建该文件还没有add到暂存区），工作区没有任何变化，将文件从仓库索引目录中删掉，<strong>不希望管理这个文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git restore xx</span><br><span class="line">git checkout — XX# 等价于restore</span><br></pre></td></tr></table></figure><p>将filename 从暂存区恢复到工作区，其中 – 可以不加，<strong>工作区的文件会被暂存区的文件覆盖</strong>（即将上一步对代码的修改取消，回滚到上一版本）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. git restore --staged filename</span><br></pre></td></tr></table></figure><p>会把暂存区的文件撤回到工作区,但工作区的文件不会被修改,可以理解为<strong>只是撤回了暂存区的文件</strong></p></li><li><p><strong>删除文件</strong></p><ul><li><p>在本地删除文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm xxx xxx</span><br></pre></td></tr></table></figure></li><li><p>将该修改添加到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx xxx</span><br></pre></td></tr></table></figure><p>注意：<code>git add</code>的<code>add</code>是将修改添加到暂存区的意思，所以删除文件也是用<code>add filename </code></p></li><li><p>从暂存区提交到版本库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;comment&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h4><ul><li><p><strong>回滚到上一版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~</span><br></pre></td></tr></table></figure></li><li><p><strong>往上回滚多次（次数较少）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure><p>一个<code>^</code>代表一次，以此类推</p></li><li><p><strong>往上回滚多次（次数较大）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~100</span><br></pre></td></tr></table></figure><p><code>~</code>后面的数字代表往上回滚多少个版本</p></li><li><p><strong>往上回滚到某个版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>版本号可在<code>git log</code>中查看，是其哈希值的<strong>前7位</strong></p><p>找不到要回滚的版本？要回滚的版本已经不存在了？<strong>用<code>git reflog</code>查看！</strong></p></li></ul><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><ul><li><p><strong>将本地仓库关联远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxx@xxxxxxx</span><br></pre></td></tr></table></figure><p><code>origin</code>为默认远程版本库名称（<code>master</code>为默认主分支名称），后面<code>xxx@xxxxxxx</code>为远程仓库的地址</p></li><li><p><strong>将当前分支推送到远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u</span><br></pre></td></tr></table></figure><p>(第一次需要加<code>-u</code>，后面不需要)</p><ul><li><p>将本地的<strong>某个分支</strong>推送到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch_name</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>将远程仓库克隆到当前目录下</strong></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx@xxxxxxx</span><br></pre></td></tr></table></figure><p>​    <code>xxx@xxxxxxx</code>为远程仓库的地址</p><p>​    只是把仓库克隆下来了，但是<code>reflog</code>就没有了</p><h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><p>注意：暂存区和分支是独立的，暂存区是共用的，在<code>commit</code>时，当前在哪个分支就会提交到哪个分支里</p><ul><li><p><strong>创建新分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch branch_name</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：创建分支时只有一个往新分支走的箭头，不会产生新的节点，只有<code>commit</code>才会产生新的节点</p></li><li><p><strong>查看所有分支和当前所在的分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p><strong>创建并切换到<code>branch_name</code>这个分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name</span><br></pre></td></tr></table></figure></li><li><p><strong>切换到某个分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch_name</span><br></pre></td></tr></table></figure></li><li><p><strong>将<code>branch_name</code>分支合并到当前分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge branch_name</span><br></pre></td></tr></table></figure><p>这种快速合并是直接改变<code>HEAD</code>的位置，如果需要强行复制一遍的话可以在后面加<code>--no-ff</code></p><ul><li><p><strong>合并冲突</strong></p><p>当两个分支对同一个文件修改等情况，会出现冲突（不知道先后顺序是怎样的）</p><p>解决办法：手动进入该文件修改冲突（打开以后会分别显示两个分支的代码修改），然后提交暂存区，版本库【<strong>解决冲突也会产生新的节点！</strong>】</p></li></ul></li><li><p><strong>设置本地<code>branch_name</code>（当前分支）对应的远程仓库的<code>branch_name</code>分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin branch_name</span><br></pre></td></tr></table></figure></li><li><p><strong>删除分支</strong></p><p>本地的分支和远程仓库的分支虽然能够同步，但还是相对独立，删除本地的，云端的不会直接被删除，反之亦然</p><ul><li><p><strong>删除本地<code>branch_name</code>分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_name</span><br></pre></td></tr></table></figure></li><li><p><strong>删除远程仓库<code>branch_name</code>分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -d origin branch_name</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>将远程的<code>branch_name1</code>分支对应到本地<code>branch_name2</code>分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/branch_name1 branch_name2</span><br></pre></td></tr></table></figure></li><li><p><strong>将远程仓库的当前分支与本地仓库的当前分支合并</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li><p>将远程仓库<code>branch_name</code>分支与本地仓库的当前分支合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin branch_name</span><br></pre></td></tr></table></figure><p>(一般操作是，拉下来以后合并到master分支，然后把本地和远程的该分支删掉，然后又push同步到云端)</p></li></ul></li></ul><blockquote><p><strong><code>git clone</code>和<code>git pull</code>的区别：</strong></p><p><strong><code>git clone</code></strong>:是在本地没有版本库的时候，从远程服务器克隆整个版本库到本地，是一个本地<strong>从无到有</strong>的过程</p><p><strong><code>git pull</code></strong>:在本地有版本库的情况下，从远程库获取最新commit数据（如果有的话），并merge（合并）到本地</p><p>​                <code>git pull = git fetch + git merge</code></p><p>通常情况下，远程操作的第一步，是使用<code>git clone</code>从远程主机克隆一个版本库到本地</p><p>本地修改代码后，每次从本地仓库push到远程仓库之前都要先进行git pull操作，保证push到远程仓库时<strong>没有版本冲突</strong></p></blockquote><h4 id="Stash暂存"><a href="#Stash暂存" class="headerlink" title="Stash暂存"></a>Stash暂存</h4><p>应用场景：【只在本地用，和远程仓库无关】e.g.本地本来在写一些东西，但是突然服务器崩了，此时工作区和暂存区都有一些修改过的内容，但是又不想把内容<code>commit</code>上去，可以用stash暂存</p><ul><li><p><strong>将工作区和暂存区中尚未提交的修改存入栈中</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></li><li><p><strong>看当前栈里的所有内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></li><li><p><strong>将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li><li><p><strong>将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></li><li><p><strong>删除栈顶存储的修改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure></li></ul><h4 id="多人开发"><a href="#多人开发" class="headerlink" title="多人开发"></a>多人开发</h4><p>多人开发的时候一般都不在<code>master</code>分支开发，一般在<code>dev</code>(自己创建的分支)开发</p><hr><p>一个简单的两人合作过程：</p><ul><li><p>A在Github中加上对方开发服务器的SSH公钥，使B也可以<code>clone</code>该仓库</p></li><li><p>B clone该仓库到本地（clone只会有master分支）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxxxx@xxxxxxx</span><br></pre></td></tr></table></figure></li><li><p>B在本地创建一个新分支，并与远程要开发的那个分支对应起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/branch_name1 branch_name2</span><br></pre></td></tr></table></figure></li><li><p>B把云端的分支拉下来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  git pull</span><br><span class="line"></span><br><span class="line">此时A和B在开发同一个分支...</span><br><span class="line"></span><br><span class="line">- A和B都创建了新结点，B先`push`了</span><br><span class="line"></span><br><span class="line">  再当A `push`时，会提示当前云端的版本已经和本地的版本不一致，需要先解决冲突：</span><br><span class="line"></span><br><span class="line">  ```shell</span><br><span class="line">  git pull</span><br></pre></td></tr></table></figure><p>将云端的分支拉到本地，此时拉到本地的内容是包含了云端的版本和A改的版本两个版本的内容，需要手动解决冲突</p></li><li><p>A解决冲突，并<code>commit</code>，然后<code>push</code>到云端</p></li></ul><hr><p>一个私有项目，是可以分配分支权限的，一般开发不会给分配<code>master</code>权限</p><p>在项目中，<code>master</code>只有leader有权限管，因此可以在<strong>云端</strong>发出<code>pull</code>请求，提交时可以选定审核人等等内容，然后发出合并请求。</p><p>Leader：可以查看合并请求的信息，可以知道对方在里面干了什么，也可以先pull到本地检查，然后通过审查后，同意合并请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近系统地学习了Git的使用方法和多人开发技术，这里是一些比较通俗易懂的记录，还有更进阶的部分还有待学习……&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
</feed>

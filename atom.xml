<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhong Kangwei&#39;s Blog</title>
  
  <subtitle>Learn and Live.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-04T09:37:11.163Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zhong Kangwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trie</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/Trie/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/Trie/</id>
    <published>2022-03-04T09:31:55.000Z</published>
    <updated>2022-03-04T09:37:11.163Z</updated>
    
    <content type="html"><![CDATA[<p>一个高效存储和查找字符串集合的数据结构。</p><span id="more"></span><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>用途：高效存储和查找字符串集合的数据结构</p><p>使用情况：一般出现的字符串较短，或全为大写，或全为小写，或全为数字。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>先建立一个根节点，然后开始存储单词，并在每个单词结尾处<strong>标记</strong>，重复的前缀可以利用。</p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220228100904429.png" alt="image-20220228100904429" style="zoom:50%;" /><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>按路径查找，不存在的两种可能：</p><ol><li>有该字符串，但结束时没有结尾标记</li><li>沿路径找不到该字符串</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;    <span class="comment">// 下标为0的点既是根节点，又是空节点</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;   <span class="comment">//idx表示指针指向的点（每一个点最多26个子节点）</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//情况1：没有匹配的字符</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];   <span class="comment">//情况2：若没有结尾，则cnt[p]为0，也属于匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个高效存储和查找字符串集合的数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>基础STL使用</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80STL%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80STL%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-04T09:27:51.000Z</published>
    <updated>2022-03-04T09:30:41.853Z</updated>
    
    <content type="html"><![CDATA[<p>Vector,pair,string,queue,priority_queue,stack,deque等基本容器的使用方法。</p><span id="more"></span><h3 id="基础STL的使用"><a href="#基础STL的使用" class="headerlink" title="基础STL的使用"></a>基础STL的使用</h3><p>每个容器都有的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">size</span>()<span class="comment">//返回元素个数， 时间复杂度O(1)</span></span><br><span class="line">a.<span class="built_in">empty</span>()<span class="comment">//返回元素是否为空，空则返回True，时间复杂度O(1)</span></span><br></pre></td></tr></table></figure><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector是变长数组，是<strong>倍增</strong>的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;<span class="comment">//定义一个vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//定义一个长度为10的vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;<span class="comment">//定义一个长度为10的vector,每一个都初始化为3</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[<span class="number">10</span>];<span class="comment">//vector数组，即定义10个vector</span></span><br><span class="line"><span class="comment">/*------- 输出 -------*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//范围遍历，效率高，auto自动推断变量类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator i = a.begin; i != a.<span class="built_in">end</span>(); i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">// 迭代遍历</span></span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">a.<span class="built_in">size</span>()<span class="comment">//返回元素个数， 时间复杂度O(1)</span></span><br><span class="line">a.<span class="built_in">empty</span>()<span class="comment">//返回元素是否为空，空则返回True，时间复杂度O(1)</span></span><br><span class="line">a.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line">a.<span class="built_in">front</span>()<span class="comment">//返回第一个数</span></span><br><span class="line">a.<span class="built_in">back</span>()<span class="comment">//返回最后一个数</span></span><br><span class="line">a.<span class="built_in">push_back</span>()<span class="comment">//在最后插入一个数</span></span><br><span class="line">a.<span class="built_in">pop_back</span>()<span class="comment">//把最后一个数删掉</span></span><br><span class="line">a.<span class="built_in">begin</span>()<span class="comment">//vector的第0个数</span></span><br><span class="line">a.<span class="built_in">end</span>()<span class="comment">//vector最后一个数的后面那个数</span></span><br><span class="line">a[x]<span class="comment">//和数组一样，支持随机选址</span></span><br><span class="line"><span class="comment">/*------- 支持比较运算 -------*/</span></span><br><span class="line"><span class="comment">//按字典顺序比大小,即从第一位开始比较，如果第一个数小于则小于，如果相等则比较下一位</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) <span class="built_in">puts</span>(<span class="string">&quot;a &lt; b&quot;</span>);</span><br></pre></td></tr></table></figure><p>底层实现原理：</p><p>系统为某一程序分配空间时，所需时间与空间无关，与<strong>申请次数</strong>有关。</p><p>vector的优化目标是减少申请次数，但可以浪费空间&#x3D;&gt;倍增思想</p><p>e.g. 先分配32B，满了之后申请长度为64B的空间，并把前面的元素copy过来。</p><p>申请长度为n，则申请次数为logn，额外copy次数为O(1)</p><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以定义任意两个类型的组合</span></span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt; p;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;turbo&quot;</span>);</span><br><span class="line">p = (<span class="number">10</span>, <span class="string">&quot;turbo&quot;</span>);</span><br><span class="line"><span class="comment">// 取数</span></span><br><span class="line">p.first</span><br><span class="line">p.second  </span><br><span class="line"><span class="comment">//支持大小比较，按字典序（先比first，再比second）</span></span><br><span class="line">p1 &lt; p2</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line">pari&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; p;<span class="comment">//存储三个属性</span></span><br></pre></td></tr></table></figure><p>应用：某一个东西有两个属性，则可以用pair来存，按照其中一个属性排序很方便</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">a.<span class="built_in">size</span>()<span class="comment">//返回字符串长度</span></span><br><span class="line">a.<span class="built_in">empty</span>()<span class="comment">//返回字符串是否为空，空则返回True</span></span><br><span class="line">a.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line">a.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//返回字串，string本来的下标是从0开始，前一个参数为起始位置，后一个参数为长度；若第二个参数超过了最大长度，则输出到最大长度就截止；省略第二个参数，则返回从第一个参数开始的整个子串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.<span class="built_in">c_str</span>());<span class="comment">//这里的c_str()返回的是字符串存储的起始地址</span></span><br><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">string a = <span class="string">&quot;turbo&quot;</span></span><br><span class="line"><span class="comment">/*------- 常用运算 -------*/</span></span><br><span class="line">a += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">a += <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">q.<span class="built_in">size</span>()<span class="comment">// 返回元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>()<span class="comment">// 返回元素是否为空</span></span><br><span class="line"><span class="comment">//没有clear 函数！如果要清空，直接初始化</span></span><br><span class="line">q = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">q.<span class="built_in">push</span>()<span class="comment">// 向队尾插入一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>()<span class="comment">// 返回队头元素</span></span><br><span class="line">q.<span class="built_in">back</span>()<span class="comment">// 返回队尾元素</span></span><br><span class="line">q.<span class="built_in">pop</span>()<span class="comment">// 弹出队头元素</span></span><br></pre></td></tr></table></figure><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>优先队列（堆），<strong>默认大根堆</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">//如果要用小根堆？</span></span><br><span class="line"><span class="comment">//法1：将要用的数取负，然后再反过来</span></span><br><span class="line"><span class="comment">//法2：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">heap.<span class="built_in">size</span>()<span class="comment">// 返回元素个数</span></span><br><span class="line">heap.<span class="built_in">empty</span>()<span class="comment">// 返回元素是否为空</span></span><br><span class="line">heap.<span class="built_in">clear</span>()</span><br><span class="line">heap.<span class="built_in">push</span>()<span class="comment">// 插入一个元素</span></span><br><span class="line">heap.<span class="built_in">top</span>()<span class="comment">// 返回堆顶元素</span></span><br><span class="line">heap.<span class="built_in">pop</span>()<span class="comment">// 弹出堆顶元素</span></span><br></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>栈，<code>push()</code>， <code>top()</code>， <code>pop()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">s.<span class="built_in">size</span>()<span class="comment">// 返回元素个数</span></span><br><span class="line">s.<span class="built_in">empty</span>()<span class="comment">// 返回元素是否为空</span></span><br><span class="line">s.<span class="built_in">push</span>()<span class="comment">// 栈顶插入一个元素</span></span><br><span class="line">s.<span class="built_in">top</span>()<span class="comment">// 返回栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>()<span class="comment">// 弹出栈顶元素</span></span><br></pre></td></tr></table></figure><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">q.<span class="built_in">size</span>()</span><br><span class="line">q.<span class="built_in">empty</span>()</span><br><span class="line">q.<span class="built_in">clear</span>()</span><br><span class="line">q.<span class="built_in">front</span>()<span class="comment">// 返回第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>()<span class="comment">// 返回最后一个元素</span></span><br><span class="line">q.<span class="built_in">push_back</span>()<span class="comment">// 最后插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop_back</span>()<span class="comment">// 最后删除一个元素</span></span><br><span class="line">q.<span class="built_in">push_front</span>()<span class="comment">// 最前插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop_front</span>()<span class="comment">// 最后插入一个元素</span></span><br><span class="line">q.<span class="built_in">begin</span>()<span class="comment">// 指向第一个数</span></span><br><span class="line">q.<span class="built_in">end</span>()<span class="comment">// 指向最后一个数的后面</span></span><br></pre></td></tr></table></figure><p>功能很全但是效率比较慢</p><h4 id="set，map，multiset，multimap"><a href="#set，map，multiset，multimap" class="headerlink" title="set，map，multiset，multimap"></a>set，map，multiset，multimap</h4><p>基于平衡二叉树实现（红黑树），动态维护有序序列</p><p><strong>set&amp;multiset</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; MS;</span><br><span class="line"><span class="comment">//set中不能有重复元素，multiset可以有重复元素</span></span><br><span class="line"><span class="comment">//set所有操作的时间复杂度是O(logn),size()和empty是O(1)</span></span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">S.<span class="built_in">size</span>()</span><br><span class="line">S.<span class="built_in">empty</span>()</span><br><span class="line">S.<span class="built_in">clear</span>()</span><br><span class="line">S.<span class="built_in">insert</span>(x)<span class="comment">//插入一个数，若重复则会被忽略</span></span><br><span class="line">S.<span class="built_in">find</span>(x)<span class="comment">//查找一个数，若不存在则返回and迭代器    </span></span><br><span class="line">S.<span class="built_in">count</span>(x)<span class="comment">// 返回一个数的个数，set中只有0/1，multiset中则可以是多个</span></span><br><span class="line">S.<span class="built_in">erase</span>(x)<span class="comment">// 1.输入一个数x，删除所有x，O(k + logn)，k为x的个数；2.输入一个迭代器，删除这个迭代器</span></span><br><span class="line">S.<span class="built_in">lower_bound</span>(x)<span class="comment">//返回大于等于x的最小的数的迭代器</span></span><br><span class="line">S.<span class="built_in">upper_bound</span>(x)<span class="comment">// 返回大于x的最小的数的迭代器</span></span><br><span class="line">s.<span class="built_in">begin</span>()<span class="comment">// 指向第一个数</span></span><br><span class="line">s.<span class="built_in">end</span>()<span class="comment">// 指向最后一个数的后面</span></span><br></pre></td></tr></table></figure><p><strong>map&amp;multimap</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; a;</span><br><span class="line">multimap&lt;string, <span class="type">int</span>&gt; ma;<span class="comment">// 可以有重复元素</span></span><br><span class="line">a[<span class="string">&quot;turbo&quot;</span>] = <span class="number">1</span>;<span class="comment">//&quot;turbo&quot;映射到了1</span></span><br><span class="line"><span class="comment">/*------- 常用函数 -------*/</span></span><br><span class="line">cout &lt;&lt; a[<span class="string">&quot;turbo&quot;</span>] &lt;&lt; endl;<span class="comment">// 可以直接找到映射到的1，像数组一样用，但是时间复杂度为O(logn), multimap不支持该操作</span></span><br><span class="line">a.<span class="built_in">size</span>()</span><br><span class="line">a.<span class="built_in">empty</span>()</span><br><span class="line">a.<span class="built_in">clear</span>()</span><br><span class="line">a.<span class="built_in">insert</span>(x)<span class="comment">// 插入的是一个pair</span></span><br><span class="line">a.<span class="built_in">erase</span>(x)  <span class="comment">// 插入的参数是pair或迭代器</span></span><br><span class="line">a.<span class="built_in">find</span>(x) <span class="comment">// 查找一个pair</span></span><br><span class="line">a.<span class="built_in">lower_bound</span>(x)<span class="comment">//返回大于等于x的最小的数的迭代器</span></span><br><span class="line">a.<span class="built_in">upper_bound</span>(x)<span class="comment">// 返回大于x的最小的数的迭代器</span></span><br></pre></td></tr></table></figure><h4 id="unodered-set，unordered-map，unordered-multiset，unordered-multimap"><a href="#unodered-set，unordered-map，unordered-multiset，unordered-multimap" class="headerlink" title="unodered_set，unordered_map，unordered_multiset，unordered_multimap"></a>unodered_set，unordered_map，unordered_multiset，unordered_multimap</h4><p>通过哈希表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和上面有序的类似，但增删改查的时间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// 不支持lower_bound()/upper_bound()，不支持迭代器的++,--（即不支持和排序有关的所有操作）</span></span><br></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>压位，可以省8位空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------- 初始化 -------*/</span></span><br><span class="line">bitset&lt;10000&gt; s;<span class="comment">//尖括号里写的是个数</span></span><br><span class="line"><span class="comment">/*------- 常用运算 -------*/</span></span><br><span class="line"><span class="comment">// 支持所有位运算</span></span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt; , &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line">s.<span class="built_in">count</span>()    <span class="comment">// 总共有多少个1</span></span><br><span class="line">s.<span class="built_in">any</span>()<span class="comment">// 判断是否至少有一个1</span></span><br><span class="line">s.<span class="built_in">none</span>()<span class="comment">// 判断是否全为0  </span></span><br><span class="line">s.<span class="built_in">set</span>()<span class="comment">// 把所有位置1</span></span><br><span class="line">s.<span class="built_in">reset</span>()    <span class="comment">// 把所有位置0</span></span><br><span class="line">s.<span class="built_in">reset</span>(k)    <span class="comment">// 把第k位置0</span></span><br><span class="line">s.<span class="built_in">set</span>(k, v)   <span class="comment">// 把k位置v </span></span><br><span class="line">s.<span class="built_in">flip</span>()<span class="comment">//等价于~</span></span><br><span class="line">s.<span class="built_in">flip</span>(k)<span class="comment">//第k位取反    </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vector,pair,string,queue,priority_queue,stack,deque等基本容器的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="编程基础" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/</id>
    <published>2022-03-04T09:26:11.000Z</published>
    <updated>2022-03-04T09:26:59.405Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表的基本使用和解决冲突的办法。</p><span id="more"></span><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h4><p>将比较庞大的数据映射到比较小的一个区间内</p><p>算法题中一般只有<strong>增加</strong>和<strong>查找</strong>两个操作（如果要实现删除，就开一个数组，然后打标记表示删除）</p><h4 id="一般情况的哈希（按冲突处理方式分）"><a href="#一般情况的哈希（按冲突处理方式分）" class="headerlink" title="一般情况的哈希（按冲突处理方式分）"></a>一般情况的哈希（按冲突处理方式分）</h4><ul><li>怎么实现哈希？<strong>直接取模最方便</strong>（mod的数一般要取质数，冲突概率最小）！</li></ul><h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p>为确保所有值都有坑，需要将哈希表长度开到需存的数的数量的<strong>2-3</strong>倍</p><p>方法：计算出的哈希值的位置已经有值占用就往后推，直到找到空的位置为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">// 如果x已经存在，返回x的下标；若x不存在，返回x应该存的位置</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)&#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;<span class="comment">//到最后没找到的话又从第一个开始找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">find</span>(x);</span><br><span class="line">h[k] = x;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><ol><li>计算哈希值，看哈希值的位置是不是该数，若为空则没有该数；</li><li>若为该数，则找到；</li><li>若不是该数，则按规则继续往后找，直到找到该数或找到空的位置（没有该数）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">if</span>(h[k] != null) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>映射到同一个位置的时候，用链表串起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">h(11) = 3</span></span><br><span class="line"><span class="comment">h(23) = 3</span></span><br><span class="line"><span class="comment">[0 1 2 3 4 5 ... 10^5-1]</span></span><br><span class="line"><span class="comment">       |</span></span><br><span class="line"><span class="comment">       11</span></span><br><span class="line"><span class="comment">       |</span></span><br><span class="line"><span class="comment">       23</span></span><br></pre></td></tr></table></figure><p>一般情况下，冲突的情况很少，时间复杂度可以看成<code>O(1)</code></p><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//h[N]为哈希表值为k的地方指向的第一个数，e[N]存储数，ne[N]存储指向下一个数的指针，idx为当前指针的位置</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;     <span class="comment">// C++中 负数的模还是负数，为了统一转化为正数，采用这种写法</span></span><br><span class="line">    e[idx] = x;     <span class="comment">// 单链表的插入</span></span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><p>计算出哈希值以后沿着链表查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == e[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串的哈希"><a href="#字符串的哈希" class="headerlink" title="字符串的哈希"></a>字符串的哈希</h4><p><strong>应用：</strong>快速判断两个字符串是否相等（O(1)就能做）</p><p>除了循环节，在其他方面KMP就不如HASH算法了</p><hr><p>字符串<strong>前缀</strong>哈希法</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;ABCABCD&quot;</span></span><br><span class="line">h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">h[<span class="number">1</span>] = <span class="string">&quot;A&quot;</span>的hash值</span><br><span class="line">h[<span class="number">2</span>] = <span class="string">&quot;AB&quot;</span>的hash值</span><br><span class="line">h[<span class="number">3</span>] = <span class="string">&quot;ABC&quot;</span>的hash值</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="如何得到前缀子串哈希值（预处理）？"><a href="#如何得到前缀子串哈希值（预处理）？" class="headerlink" title="如何得到前缀子串哈希值（预处理）？"></a><strong>如何得到前缀子串哈希值（预处理）？</strong></h5><ol><li><p>把字符串的每个字符都转换成数字，如<code>char - &#39;A&#39; + 1</code>（<strong>不能映射成0！！！</strong>）</p><blockquote><p>如“A”映射成0，那“AA”也是0</p></blockquote></li><li><p>把字符串看成p进制的数（p一般取131或13331）</p></li><li><p>把p进制转换成十进制数，并<code>mod Q</code>即可映射到哈希表（Q一般取$2^{64}$）</p></li></ol><p>按这种方法取P，Q，99%不会出现冲突（直接假定不会出现冲突做题）</p><p>用<code>unsigned long long</code>存储，直接溢出，则不需要取模了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[i] = h[i - <span class="number">1</span>] * p + str[i];</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//预处理得前缀哈希值</span></span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h5 id="字符串-L-R-区间的哈希值计算"><a href="#字符串-L-R-区间的哈希值计算" class="headerlink" title="字符串[L,R]区间的哈希值计算"></a>字符串[L,R]区间的哈希值计算</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = h[R] - h[L - <span class="number">1</span>] * p^(R - L + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>预处理完前缀哈希值以后，可以在<code>O(1)</code>时间算出任意子段的哈希值了</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>哈希和离散化有什么区别？</p><p>离散化是一种比较特殊的方式，它需要<strong>保序</strong>，而哈希不需要保序。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表的基本使用和解决冲突的办法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%A0%86/</id>
    <published>2022-03-04T09:24:30.000Z</published>
    <updated>2022-03-04T09:25:18.120Z</updated>
    
    <content type="html"><![CDATA[<p>堆的基础算法，用数组实现。</p><span id="more"></span><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>堆是一个<strong>完全二叉树</strong></p><p>小根堆：每一个结点小于等于左右儿子</p><p>大根堆：每一个结点大于等于左右儿子</p><hr><h4 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h4><p>用<strong>一维数组</strong>存，第一个点为根结点（<strong>下标从1开始！</strong>），$x$的左儿子为$2x$，$x$的右儿子为$2x+1$</p><hr><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h5><p>法1：O(nlogn)直接每一个插入</p><p>法2：**O(n)**从n&#x2F;2【非叶子结点】开始down，一直down到1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i; i --) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h5 id="down-x"><a href="#down-x" class="headerlink" title="down(x)"></a>down(x)</h5><p><strong>这里的x表示的是结点的下标！！</strong></p><p>时间复杂度：O(logn)</p><p>往下调整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;   <span class="comment">// down编号为u的结点</span></span><br><span class="line">    <span class="type">int</span> t = u;  <span class="comment">// t记录一个结点和两个子节点中的最小值的编号</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= arr_size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= arr_size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);   <span class="comment">// 换的是值</span></span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="up-x"><a href="#up-x" class="headerlink" title="up(x)"></a>up(x)</h5><p>O(logn)</p><p>往上调整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])&#123;<span class="comment">// 只要和父结点比，可以写成迭代的形式</span></span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="STL可实现的操作"><a href="#STL可实现的操作" class="headerlink" title="STL可实现的操作"></a>STL可实现的操作</h4><h5 id="插入一个数"><a href="#插入一个数" class="headerlink" title="插入一个数"></a>插入一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heap[++size] = x;</span><br><span class="line"><span class="built_in">up</span>(size);</span><br></pre></td></tr></table></figure><h5 id="求集合当中的最小值"><a href="#求集合当中的最小值" class="headerlink" title="求集合当中的最小值"></a>求集合当中的最小值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h5 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h5><p>一维数组删除头结点很难，删除尾结点比较简单，所以先把最后一个点覆盖第一个点，然后调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="STL实现不了的操作"><a href="#STL实现不了的操作" class="headerlink" title="STL实现不了的操作"></a>STL实现不了的操作</h4><h5 id="删除任意一个元素"><a href="#删除任意一个元素" class="headerlink" title="删除任意一个元素"></a>删除任意一个元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);<span class="comment">//虽然down和up两个都写，但是只会执行一个</span></span><br></pre></td></tr></table></figure><h5 id="修改任意一个元素"><a href="#修改任意一个元素" class="headerlink" title="修改任意一个元素"></a>修改任意一个元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);<span class="comment">//虽然down和up两个都写，但是只会执行一个</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆的基础算法，用数组实现。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-03-04T09:22:12.000Z</published>
    <updated>2022-03-04T09:23:43.193Z</updated>
    
    <content type="html"><![CDATA[<p>并查集的基本使用和优化。</p><span id="more"></span><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a><strong>支持操作</strong></h4><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合中</li></ol><p>近乎O(1)的时间内完成（不是完全O(1))</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每个集合用一棵树来表示，<strong>树根的编号就是整个集合的编号</strong>。每个节点存储它的父节点，p[x]表示x的父结点。</p><ul><li><p>如何判断树根？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[x] == x)</span><br></pre></td></tr></table></figure></li><li><p>如何求x的集合编号？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p[x] != x) x = p[x];</span><br></pre></td></tr></table></figure><p>只要x不是树根就一直往上走，一直走到树根为止</p></li><li><p>如何合并两个集合？</p><p>把Set1当作Set2的儿子或者把Set2当作Set1的儿子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[x] = y;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>【<strong>路径压缩</strong>】一旦往上走找到了根节点，则把路径上所有的点都指向根节点，这样就只需要扫一遍。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">//实现集合的查找和路径压缩，返回的是祖宗节点</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) p[i] = i;  <span class="comment">//每个数各自在一个集合中</span></span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);    <span class="comment">//尽管只有一个字符，但还是用字符串读入，可以自动过滤很多空格换行符等，防止被坑</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = p[<span class="built_in">find</span>(b)];   <span class="comment">//把a所在的集合插入b所在的集合</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="built_in">find</span>(a)] == p[<span class="built_in">find</span>(b)]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;并查集的基本使用和优化。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前缀和与差分</title>
    <link href="http://example.com/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <id>http://example.com/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</id>
    <published>2022-03-04T09:18:59.000Z</published>
    <updated>2022-03-04T09:21:17.989Z</updated>
    
    <content type="html"><![CDATA[<p>一维、二维的前缀和与差分算法。</p><span id="more"></span><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和$s_i&#x3D;a_1+a_2+…+a_i$</p><ul><li><p>求法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//important</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] +a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组a的下标一定要从1开始！！！</strong>&#x3D;&gt;为了定义$s_0$，处理边界问题</p></li><li><p>作用：</p><p>能快速求出原数组中一段数的和（区间和的计算）</p></li><li><p>扩展到二维：求子矩阵的和</p><p><strong>两个方向的前缀</strong></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211130193812461.png" alt="image-20211130193812461"></p><p><code>s[i,j]</code>求的是左上部分的前缀和。</p><p>初始化：<code>s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]</code></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211130194139172.png" alt="image-20211130194139172"></p><p>求红色矩阵的前缀和，使用求面积的方法，即<code>sum=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]-s[x1-1][y1-1]</code></p></li></ul><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分是前缀和的逆运算(相邻元素之差)</p><p>使得a[]是b[]的前缀和，则b是a的差分。</p><ul><li>求法</li></ul><p>​    $a_i &#x3D; b_1+b_2+…+b_i$</p><p>​    $b_1&#x3D;a_1$</p><p>​    $b_2&#x3D;a_2-a_1$</p><p>​    …</p><ul><li><p>作用</p><p>对b数组求一遍前缀和即可得到原数组a</p><p>O(n)时间内可得到a</p><p>使用场景：[l,r]的每个元素都要加上数c，用差分可以由O(n)降到O(1)</p></li></ul><p>​    即，<code>b[l]+c</code>，则<code>a[l],a[l+1]...</code>都会加c，因为是通过前缀和求的。</p><p>​    在后面<code>b[r+1]-c</code>，则实现了<code>a[l,r]</code>都加c</p><ul><li><p>二维差分</p><p>给一个子矩阵的每个元素加一个值</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211130201000274.png" alt="image-20211130201000274"></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[x1][y1]+=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一维、二维的前缀和与差分算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="基础算法" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++中sort函数的使用总结</title>
    <link href="http://example.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E4%B8%ADsort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E4%B8%ADsort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-04T09:15:19.000Z</published>
    <updated>2022-03-04T09:17:29.494Z</updated>
    
    <content type="html"><![CDATA[<p>C++中sort函数使用方法的总结和举例。</p><span id="more"></span><h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><h2 id="如何使用sort函数"><a href="#如何使用sort函数" class="headerlink" title="如何使用sort函数"></a>如何使用sort函数</h2><p>头文件：<code>include &lt;iostream&gt;</code>以及<code>using namespace std;</code></p><p><code>sort(首元素地址(必填)，尾元素地址的下一个地址（必填），比较函数（选填）)</code></p><p>对尾元素下一个地址的理解：也可以是从首元素地址开始，给几个数进行排序，就第二个参数加几</p><p>如果不写比较函数则默认对前面给出的区间进行递增排序</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对char进行排序是默认按字典序</p><p>如果没有可比性，则需要人为制定比较规则，sort函数中第三个参数就是用来制定规则的</p><h2 id="如何实现比较函数cmp"><a href="#如何实现比较函数cmp" class="headerlink" title="如何实现比较函数cmp"></a>如何实现比较函数cmp</h2><h3 id="基本数据类型数组的排序"><a href="#基本数据类型数组的排序" class="headerlink" title="基本数据类型数组的排序"></a>基本数据类型数组的排序</h3><p>如果要从大到小排序，则用cmp函数告诉sort()，何时要交换元素(让大小比较关系反过来）,是一个<strong>bool类型</strong>的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;<span class="comment">//当a大于b时，a放在前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体数组的排序"><a href="#结构体数组的排序" class="headerlink" title="结构体数组的排序"></a>结构体数组的排序</h3><p>定义一个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>一级排序：按x从大到小进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按照x从大到小排序 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级排序：当x相等的情况下，按照y的大小从小到大进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按照x从大到小排序 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ssd[<span class="number">0</span>].x=<span class="number">2</span>;</span><br><span class="line">ssd[<span class="number">0</span>].y=<span class="number">2</span>;</span><br><span class="line">ssd[<span class="number">1</span>].x=<span class="number">1</span>;</span><br><span class="line">ssd[<span class="number">1</span>].y=<span class="number">3</span>;</span><br><span class="line">ssd[<span class="number">2</span>].x=<span class="number">3</span>;</span><br><span class="line">ssd[<span class="number">2</span>].y=<span class="number">1</span>;</span><br><span class="line">ssd[<span class="number">3</span>].x=<span class="number">1</span>;</span><br><span class="line">ssd[<span class="number">3</span>].y=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">sort</span>(ssd,ssd+<span class="number">3</span>,cmp1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;ssd[i].x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ssd[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ssd,ssd+<span class="number">4</span>,cmp2);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;ssd[i].x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ssd[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="容器排序"><a href="#容器排序" class="headerlink" title="容器排序"></a>容器排序</h3><p>在STL标准容器中，只有vector，string，deque可以用排序</p><p>vector：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">sort</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;vi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">321</span></span><br></pre></td></tr></table></figure><p>string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str1.<span class="built_in">length</span>()&lt;str2.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string str[<span class="number">3</span>]=&#123;<span class="string">&quot;babb&quot;</span>,<span class="string">&quot;bc&quot;</span>,<span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(str,str+<span class="number">3</span>);<span class="comment">//按字典序从小到大排序(一个一个字母比） </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(str,str+<span class="number">3</span>,cmp);<span class="comment">//按字符串长度排序 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">babb</span><br><span class="line">bc</span><br><span class="line">bc</span><br><span class="line">aaa</span><br><span class="line">babb</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中sort函数使用方法的总结和举例。&lt;/p&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程基础" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>用Docker部署KubeFate</title>
    <link href="http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E7%94%A8Docker%E9%83%A8%E7%BD%B2KubeFate/"/>
    <id>http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E7%94%A8Docker%E9%83%A8%E7%BD%B2KubeFate/</id>
    <published>2022-03-03T11:48:32.000Z</published>
    <updated>2022-03-03T11:49:40.342Z</updated>
    
    <content type="html"><![CDATA[<p>使用FATE开源库，通过Docker部署KubeFate集群。</p><span id="more"></span><h1 id="用Docker部署KubeFate"><a href="#用Docker部署KubeFate" class="headerlink" title="用Docker部署KubeFate"></a>用Docker部署KubeFate</h1><hr><p>工具：CentOS7 虚拟机或物理机</p><p><a href="https://github.com/FederatedAI/KubeFATE/blob/master/docker-deploy/README_zh.md">官方中文文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/121738171">单机部署KubeFate</a></p><hr><h3 id="安装Docker容器"><a href="#安装Docker容器" class="headerlink" title="安装Docker容器"></a>安装Docker容器</h3><ul><li><p>安装系统依赖工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>yum的配置管理，添加docker的软件源地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>(通过阿里云镜像)</p></li><li><p>更新yum缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure></li><li><p>查看docker的所有版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure></li><li><p>选一个进行安装</p><p>fate官方文档要求所有主机安装Docker 版本 : 18+；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce-18.03.1.ce</span><br></pre></td></tr></table></figure></li><li><p>启动docker服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>加入开机启动项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li><li><p>查看docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker version</span><br></pre></td></tr></table></figure></li><li><p>测试docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/03/EGCOzy7LjwFvB8M.png" alt="image-20220226100155056"></p><p>测试成功！</p></li></ul><h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker-Compose"></a>安装Docker-Compose</h3><p><strong>官方要求所有主机安装Docker-Compose 版本: 1.24+；</strong></p><ul><li>安装指定版本Docker-Compose</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>github访问太慢，可以用daocloud安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ul><li><p>添加可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/03/OD5usTZPvGWi8xX.png" alt="image-20220226101152561"></p></li><li><p>检查端口是否被占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -apln|grep 8080                                                                               </span><br><span class="line">netstat -apln|grep 9360                                                                    </span><br><span class="line">netstat -apln|grep 9380</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220226101331899.png" alt="image-20220226101331899"></p><p>这表示都没有占用，若有占用则要先kill占用端口的进程</p></li></ul><h3 id="部署KubeFATE"><a href="#部署KubeFATE" class="headerlink" title="部署KubeFATE"></a>部署KubeFATE</h3><ul><li>创建文件夹<code>fate</code></li></ul><hr><ul><li><p>在文件夹中下载fate镜像(只有1.4.0)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://webank-ai-1251170195.cos.ap-guangzhou.myqcloud.com/fate_1.4.0-images.tar.gz</span><br></pre></td></tr></table></figure><p>国内用户从此处下载速度较快</p></li><li><p>加载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker load -i fate_1.4.0-images.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>验证镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ul><hr><p>  或者直接根据官方文档手动下载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version=1.7.2          </span><br><span class="line">version_server=2.1.5   </span><br><span class="line">docker pull federatedai/eggroll:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/fateboard:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/python:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/client:<span class="variable">$version</span>-release</span><br><span class="line">docker pull federatedai/serving-server:<span class="variable">$version_server</span>-release</span><br><span class="line">docker pull federatedai/serving-proxy:<span class="variable">$version_server</span>-release</span><br><span class="line">docker pull redis:5</span><br><span class="line">docker pull mysql:8</span><br></pre></td></tr></table></figure><p>版本号从<code>release</code>里查看最新的版本号</p><hr><ul><li><p>下载KubeFate</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/FederatedAI/KubeFATE/releases/download/v1.7.0-a/kubefate-docker-compose.tar.gz</span><br></pre></td></tr></table></figure><p>版本号可在官方文档中查看</p></li><li><p>将KubeFate放入<code>/home</code>目录进行解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf kubefate-docker-compose-v1.7.1-a.tar.gz </span><br></pre></td></tr></table></figure></li><li><p>准备两台主机，修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user=root                                  # 运行FATE容器的用户</span><br><span class="line">dir=/data/projects/fate                     # docker-compose部署目录</span><br><span class="line">partylist=(10000 9999)                      # 组织id</span><br><span class="line">partyiplist=(192.168.126.166 192.168.126.167)       # id对应训练集群ip</span><br><span class="line">servingiplist=(192.168.126.166 192.168.126.167)     # id对应在线预测集群ip</span><br><span class="line"><span class="meta"># </span><span class="language-bash">computing_backend could be eggroll or spark.</span></span><br><span class="line">computing_backend=eggroll</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="literal">true</span> <span class="keyword">if</span> you need python-nn <span class="keyword">else</span> <span class="literal">false</span>, the default value will be <span class="literal">false</span></span></span><br><span class="line">enabled_nn=false</span><br><span class="line"></span><br><span class="line">fateboard_username=admin                    # 访问fateboard的用户名</span><br><span class="line">fateboard_password=admin                    # 访问fateboard的密码</span><br></pre></td></tr></table></figure><p>user一般要用root，如果不是root则要有<code>/data/projects/fate</code>文件夹权限和docker权限。</p><p><code>party 10000</code>的集群将部署在<em>192.168.126.166</em>上，而<code>party 9999</code>的集群将部署在<em>192.168.126.167</em>上。为了减少所需拉取镜像的大小，KubeFATE在默认情况下，会使用不带神经网络的“python”容器，若需要跑神经网络的算法则需把“parties.conf”中的<code>enabled_nn</code>设置成<code>true</code></p><ul><li><p>执行部署脚本（host）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./generate_config.sh          # 生成部署文件</span><br><span class="line">./docker_deploy.sh all        # 在各个party上部署FATE</span><br></pre></td></tr></table></figure></li><li><p>通过SSH登录其中一个主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.7.1</span><br></pre></td></tr></table></figure></li><li><p>验证实例状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>若各个组件都是运行（up）状态，说明部署成功。</p></li><li><p>验证部署</p><p>docker-compose上的FATE启动成功之后需要验证各个服务是否都正常运行，我们可以通过验证toy_example示例来检测。</p><p>选择192.168.126.167这个节点验证，使用以下命令验证：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">在192.168.126.167上执行下列命令</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it confs-10000_client_1 bash                        <span class="comment">#进入python组件容器内部</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">flow <span class="built_in">test</span> toy --guest-party-id 10000 --host-party-id 9999        <span class="comment">#验证</span></span></span><br></pre></td></tr></table></figure><p>至此，基本部署完毕。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用FATE开源库，通过Docker部署KubeFate集群。&lt;/p&gt;</summary>
    
    
    
    <category term="隐私计算" scheme="http://example.com/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="隐私计算" scheme="http://example.com/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    <category term="联邦学习" scheme="http://example.com/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>联邦学习概述</title>
    <link href="http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/</id>
    <published>2022-03-03T11:45:02.000Z</published>
    <updated>2022-03-03T11:47:05.115Z</updated>
    
    <content type="html"><![CDATA[<p>联邦学习基础的行业背景、基本特点、分类等。</p><span id="more"></span><h2 id="联邦学习概述"><a href="#联邦学习概述" class="headerlink" title="联邦学习概述"></a>联邦学习概述</h2><h3 id="行业背景"><a href="#行业背景" class="headerlink" title="行业背景"></a>行业背景</h3><p>数据分布不均衡，对数据使用监管趋于严格&#x3D;&#x3D;&gt;<strong>数据孤岛</strong></p><p>联邦学习就可以来解决数据孤岛问题。</p><h3 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h3><ul><li>数据隔离：数据不泄露到外部</li><li>无损：联邦模型效率等同或接近全量数据模型</li><li>对等：参与者的地位对等</li><li>共同获益：参与者能够共同获益</li></ul><h3 id="联邦学习分类"><a href="#联邦学习分类" class="headerlink" title="联邦学习分类"></a>联邦学习分类</h3><h4 id="横向联邦学习"><a href="#横向联邦学习" class="headerlink" title="横向联邦学习"></a>横向联邦学习</h4><p>数据方：特征维度相同，通过联邦学习有更多的数据样本</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>A与B联合建模，双方都有X，Y，但样本不够多</p><p><img src="https://s2.loli.net/2022/03/03/65zDKWXnUvaHtBk.png" alt="image-20220302114121917"></p><p><strong>假设</strong>：双方都有X,Y；双方不暴露自己的X,Y</p><p><strong>传统建模</strong>：各自样本不够多</p><p><strong>期望</strong>：保护隐私的条件下，建立联合模型，且效果超过单边数据建模</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>常用方法：<strong>FedAvg</strong>【是<strong>无损</strong>的，也可以跟差分隐私结合一起用】</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302114504380.png" alt="image-20220302114504380"></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302114615724.png" alt="image-20220302114615724"></p><h4 id="纵向联邦学习"><a href="#纵向联邦学习" class="headerlink" title="纵向联邦学习"></a>纵向联邦学习</h4><p>数据方：样本ID相同，通过联邦学习丰富样本特征，更精准地刻画样本</p><h5 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h5><p>A与B联合建模，B有Y（表现），期望优化Y的预测模型</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302103142501.png" alt="image-20220302103142501"></p><p><strong>假设</strong>：只有B拥有“Y”，合作的A无法暴露含有隐私的“X”</p><p><strong>传统建模方法</strong>：B的隐私数据“X”不能全量传到“Y”，A缺乏“Y”，无法独立建模</p><p><strong>期望</strong>：保护隐私的条件下，建立联合模型，且效果超过单边数据建模</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li><p><strong>数据对齐</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Party A: </span><br><span class="line">ID set X:[u1, u2, u3, u4]</span><br><span class="line">Party B: </span><br><span class="line">ID set Y:[u1, u2, u3, u5]</span><br><span class="line">要求寻找X∩Y = [u1, u2, u3]</span><br><span class="line">且PartyA不知道PartyB有u5</span><br><span class="line">PartyB不知道PartyA有u4</span><br></pre></td></tr></table></figure><p>解决方案：<strong>RSA+哈希的安全求交</strong></p><ol><li>PartyB通过RSA产生n,e,d并将公钥(n,e)发送给Party A</li><li>PartyA对于每条样本产生随机数$r_i$并将id哈希得到<code>H(u)</code>，将$Y_A&#x3D;{r_1^eH(u1),r_2^eH(u2),r_3^eH(u3),r_4^eH(u4)}$发送给PartyB【$r_i$相当于PartyA给自己上的锁，RSA相当于PartyB给自己上的锁，因此双方都未泄露数据】</li><li>PartyB对每一个$r_i^eH(u_i)$求$d$次幂，并mod n，相当于对其进行二次加密，即$r_i*(H(u_i))^d$，其集合定义为$Z_A$；同时PartyB对自己的数据求$H((H(u_i))^d)$，其集合定义为$Z_B$，将$Z_A,Z_B$发给PartyA</li><li>PartyA对$r_i*(H(u_i))^d$进行处理，$r_i$在PartyA手中，所以直接求$H(r_i*(H(u_i))^d&#x2F;r_i) &#x3D; H((H(u_i))^d)$，将该集合定义为$D_A$</li><li><strong>求交</strong>：$I &#x3D; D_A ∩ Z_B&#x3D;{H((H(u_1))^d), H((H(u_2))^d), H((H(u_3))^d)}$，并将I发送给B</li></ol><p>通过这5步，PartyA和PartyB没有泄露其他ID，并且找到了相同的ID</p></li><li><p><strong>联邦特征工程</strong></p><p> 求WoE(Weight of Evidence)和IV(Information Value)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题：在保护双方隐私的前提下，A(含X)，B（含X，Y）特征，如何计算Woe和IV？</span><br><span class="line">难点：</span><br><span class="line">1.A只有特征X，没有Y；计算Woe和IV依靠X和Y（B侧特征Woe&amp;IV可以本地计算）</span><br><span class="line">2.A不能对B暴露X，B不能对A暴露Y</span><br><span class="line">最终只能让B获得所有特征Woe&amp;IV</span><br></pre></td></tr></table></figure><p>解决方案：<strong>加法同态加密</strong></p><p><code>Encry(x)</code>：x的加法同态加密</p><p><code>Encode(x)</code>：本地编码</p><ol><li><p>PartyB对每个ID的$y_i，1-y_i$进行加密，发送给PartyA，即{$ID_i, Encry(y_i),Encry(1-y_i)$}</p></li><li><p>PartyA统计每个数据集中$Encry(y_i)$的和以及$Encry(1-y_i)$的和，并发送给PartyB，即{$Encode(id_set_i), sum(Encry(y_i)),sum(Encry(1-y_i))$}</p></li><li><p>B方即可本地计算Woe和IV<br>$$<br>npos_i&#x3D;Decry(sum(Encry(yi)))<br>$$</p><p>$$<br>nneg_i&#x3D;Decry(sum(Encry(1 - yi)))<br>$$</p><p>$$<br>distpos_i &#x3D; npos_i &#x2F; pos_total<br>$$</p><p>$$<br>distneg_i &#x3D; nneg_i &#x2F; neg_total<br>$$</p><p>$$<br>Woe_i &#x3D; 100 * log(distpos_i &#x2F; distneg_i)<br>$$</p><p>$$<br>IV &#x3D;\sum_{i&#x3D;1}^k(dispos_i - disneg_i)*log(dispos_i&#x2F;disneg_i)<br>$$</p></li></ol><ul><li><p><strong>逻辑回归</strong></p><p>纵向逻辑回归用加法同态，因为加法同态没有逆，因此在公式里不能有<code>exp</code>，采用的解决方法是在零点附近进行泰勒展开，使其<strong>只有加法和乘法</strong></p></li></ul></li></ul><h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><p>  <img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20220302113755110.png" alt="image-20220302113755110"></p><h3 id="联邦学习关键技术–加解密"><a href="#联邦学习关键技术–加解密" class="headerlink" title="联邦学习关键技术–加解密"></a>联邦学习关键技术–加解密</h3><h4 id="保护隐私和安全方法"><a href="#保护隐私和安全方法" class="headerlink" title="保护隐私和安全方法"></a>保护隐私和安全方法</h4><ul><li><p><strong>同态加密</strong></p><p>加密情况下的运算结果和在明文情况下的运算结果完全一致，而且每一次加密的结果是不一样的</p></li><li><p>多方安全计算</p></li><li><p>姚式混淆电路</p></li><li><p>差分隐私</p></li></ul><p>Fate库中主要用的是<strong>加法同态加密</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;联邦学习基础的行业背景、基本特点、分类等。&lt;/p&gt;</summary>
    
    
    
    <category term="隐私计算" scheme="http://example.com/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="隐私计算" scheme="http://example.com/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    <category term="联邦学习" scheme="http://example.com/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>垃圾邮件分类</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB/</id>
    <published>2022-03-03T11:40:44.000Z</published>
    <updated>2022-03-03T11:44:43.643Z</updated>
    
    <content type="html"><![CDATA[<p>通过概率论中学的贝叶斯公式来推断一封新收到的邮件是否为垃圾邮件。</p><span id="more"></span><h1 id="垃圾邮件分类"><a href="#垃圾邮件分类" class="headerlink" title="垃圾邮件分类"></a>垃圾邮件分类</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>了解垃圾邮件分类的基本技术路线与方法。</li><li>了解如何提取邮件中的关键字，并运用统计学中的贝叶斯公式来推断一封新收到的邮件是否为垃圾邮件。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="邮件解析"><a href="#邮件解析" class="headerlink" title="邮件解析"></a>邮件解析</h3><p>我在网上找到了一个8000封正常邮件和8000封垃圾邮件的邮件史料，同时也通过网上邮件下载的python文件，即<code>mailDownload.py</code>添加了邮箱的一些邮件，作为训练集，然后提取邮件中的中文词汇。</p><p>这里使用的提取中文词汇的方法是：先将中文文本切成最小的单位汉字，然后再&#x3D;从词典里找词，将字按照最左最长原则，合并成以词为单位的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_wordslist</span>(<span class="params">self, fn=<span class="string">r&quot;./words.txt&quot;</span></span>):</span><br><span class="line">    f = <span class="built_in">open</span>(fn)</span><br><span class="line">    lines = <span class="built_in">sorted</span>(f.readlines())</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">words_2_trie</span>(<span class="params">self, wordslist</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将单词表存入字典树</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> wordslist:</span><br><span class="line">        ref = d</span><br><span class="line">        chars = self.regex.findall(word)</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">            ref[char] = ref.has_key(char) <span class="keyword">and</span> ref[char] <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">            ref = ref[char]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_in_trie</span>(<span class="params">self, chars, trie, res</span>):</span><br><span class="line">    ref = trie</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        <span class="keyword">if</span> ref.has_key(char):</span><br><span class="line">            temp += char</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            ref = ref[char]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> temp != <span class="number">0</span>:                                <span class="comment">#表示上一个单词已经分离出</span></span><br><span class="line">                res.append(temp)</span><br><span class="line">                temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span>:                               <span class="comment">#字典中没有以上一个char结尾的单词</span></span><br><span class="line">                index = <span class="number">1</span></span><br><span class="line">                res.append(char)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                chars = chars[index:]</span><br><span class="line">                self.search_in_trie(chars, trie, res)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span>:                                       <span class="comment">#最后一个词</span></span><br><span class="line">        res.append(temp);</span><br></pre></td></tr></table></figure><p>做完以后发现，python有结巴分词这个第三方扩展库来实现中文分词，好像直接调用那个库可以更加方便，但是我已经写完了就没有再使用了。</p><h3 id="邮件分析"><a href="#邮件分析" class="headerlink" title="邮件分析"></a>邮件分析</h3><p>做完这些后就要对信息进行汇总了，即统计邮件中每个词汇分别在垃圾邮件和正常邮件中出现的频率，</p><ol><li><p>当收到一封未知邮件时，在不知道的前提下，我们假定它是垃圾邮件和正常邮件的概率各 为50%，p(s) &#x3D; p(n) &#x3D; 50%</p></li><li><p>解析该邮件，提取每个词，计算该词的p(s|w)，也就是受该词影响，该邮件是垃圾邮件的概率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p(sw)             p(w|s)p(s)</span><br><span class="line">p(s|w) = -----------  =   ----------------------</span><br><span class="line">p(w)        p(s)p(w|s) + p(n)p(w|n)</span><br></pre></td></tr></table></figure><p>此处的解析邮件还是类似于前面的邮件分词，对应实现是splitsingle()</p></li><li><p>提取该邮件中p(s|w)最高的15个词，计算联合概率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p(s|w1)p(s|w2)...p(s|w15)</span><br><span class="line">p = ---------------------------------------------------------------</span><br><span class="line">p(s|w1)p(s|w2)...p(s|w15) + (1-p(s|w1))(1-p(s|w2)...(1-p(s|w15)))</span><br></pre></td></tr></table></figure></li><li><p>设定阈值 p &gt; 0.9 :垃圾邮件<br>p &lt; 0.9 :正常邮件</p></li></ol><p>整个过程的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JudgeMail</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    判断接收到的邮件是否为垃圾邮件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">self, init, trie, email</span>):</span><br><span class="line">        res = init.splitsingle(trie, email)                  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;。&#x27;</span>, <span class="string">&#x27;：&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;（&#x27;</span>, <span class="string">&#x27;）&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;！&#x27;</span>,<span class="string">&#x27;、&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> res:</span><br><span class="line">                res.remove(i)                                <span class="comment">#剔除标点字符</span></span><br><span class="line">        ratio_of_words = [] <span class="comment">#记录邮件中每个词在垃圾邮件史料库(init.ratio[key][1])中出现的概率</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> init.ratio:</span><br><span class="line">                ratio_of_words.append((word, init.ratio[word][<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                init.ratio[word] = [<span class="number">0.6</span>, <span class="number">0.4</span>] <span class="comment">#如果邮件中的词是第一次出现，那么就假定</span></span><br><span class="line">                                                             <span class="comment">#p(s|w)=0.4</span></span><br><span class="line">            ratio_of_words.append((word, <span class="number">0.4</span>))</span><br><span class="line">        ratio_of_words = <span class="built_in">sorted</span>(ratio_of_words, key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:<span class="number">15</span>]</span><br><span class="line">        P = <span class="number">1.0</span> </span><br><span class="line">        rest_P = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> ratio_of_words:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">print</span> word[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>), word[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span> word[<span class="number">0</span>], word[<span class="number">1</span>]</span><br><span class="line">            P *= word[<span class="number">1</span>]</span><br><span class="line">            rest_P = rest_P * (<span class="number">1.0</span> - word[<span class="number">1</span>])</span><br><span class="line">         </span><br><span class="line">        trash_p = P / (P + rest_P)</span><br><span class="line">        typ = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> trash_p &gt; <span class="number">0.9</span>:</span><br><span class="line">            typ = <span class="string">&#x27;trash&#x27;</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            typ = <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">        init.flush(typ, res)</span><br><span class="line">        <span class="keyword">return</span> trash_p</span><br></pre></td></tr></table></figure><h3 id="建立通信"><a href="#建立通信" class="headerlink" title="建立通信"></a>建立通信</h3><p>这学期的计算机网络学习socket通信，这里拿来实践一下，过简单地socket通信模拟邮件收发。</p><ul><li><p>server端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> analysisEmail</span><br><span class="line"><span class="keyword">import</span> splitEmail</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#加载历史邮件资料库，即建立判断条件</span></span><br><span class="line">    init = splitEmail.SplitEmail()</span><br><span class="line">    words = init.init_wordslist()</span><br><span class="line">    trie = init.words_2_trie(words)</span><br><span class="line">    init.split(trie, [<span class="string">&#x27;./data/&#x27;</span>])</span><br><span class="line">    init.ratio = init.getRatio()</span><br><span class="line">    <span class="comment">#for key in dic_of_ratio:</span></span><br><span class="line">    <span class="comment">#    print key, dic_of_ratio[key]</span></span><br><span class="line">    <span class="comment">####################################################################</span></span><br><span class="line"></span><br><span class="line">    host = <span class="string">&#x27;&#x27;</span>   </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.bind((host, port))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Waiting for clients...&quot;</span></span><br><span class="line">        conn, addr = s.accept()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Connected by&#x27;</span>, addr</span><br><span class="line">        msg = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(data):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            msg += data</span><br><span class="line">        conn.close()</span><br><span class="line">        P = analysisEmail.JudgeMail().judge(init, trie, msg)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;P(spam) = &quot;</span>, P</span><br></pre></td></tr></table></figure></li><li><p>client端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">port = <span class="number">8888</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">fi = <span class="built_in">str</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">msg = <span class="built_in">open</span>(fi).read()</span><br><span class="line">s.connect((host, port))</span><br><span class="line">s.sendall(msg)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;error: Input the email location&quot;</span></span><br></pre></td></tr></table></figure><p>整个过程：server端运行，首先建立splitemail对象，然后调用init_wordlist()加载字典，之后调用words_2_trie()将<br>字典转换为字典树，再之后将史料库中的邮件分词，统计各个单词在正常和垃圾邮件中出现的概率。</p><p> client发来邮件，server接收后调用<code>analysisEmail.py</code>中的<code>judge()</code>函数来判断其是否为垃圾邮件。</p></li></ul><h2 id="实验中出现的问题"><a href="#实验中出现的问题" class="headerlink" title="实验中出现的问题"></a>实验中出现的问题</h2><ul><li>实验过程当中开始遇到的问题是训练数据集的搜集问题，开始找不到对应的邮件史料库，后来通过CSDN下载到了一个比较大的数据集（虽然邮件比较老旧）</li><li>提取中文分词时遇到了一些问题，后来找到了字典树与最左最长匹配的方法实现了简单的分词功能，结果做完后发现python有第三方扩展库可以完美实现中文分词。</li></ul><h2 id="实验结果展示及分析"><a href="#实验结果展示及分析" class="headerlink" title="实验结果展示及分析"></a>实验结果展示及分析</h2><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p>我从邮件库中选取了一封典型的垃圾邮件：</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124141327426.png" alt="image-20211124141327426"></p><p>通过分析后我们得到为垃圾邮件的概率为0.9538…</p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124141251659.png" alt="image-20211124141251659"></p><h4 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h4><p>测试邮件集合中部分邮件，正常邮件中正确识别的为Nc，错误识别的为Ne，垃圾邮件中正确识别的为Mc，错误识别的为Me。</p><table><thead><tr><th></th><th>准确度</th><th>召回率</th></tr></thead><tbody><tr><td>贝叶斯</td><td>88.8%</td><td>89.5%</td></tr></tbody></table><p>（召回率&#x3D;$Nc&#x2F;(Nc+Ne) *100%$）</p><p>通过数据我们可以看到使用贝叶斯的分类算法准确度和召回率处于中游水平，应该还有更好的分类方法比如支持向量机等可以提高准确度和召回率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过概率论中学的贝叶斯公式来推断一封新收到的邮件是否为垃圾邮件。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="信息安全环境与工具" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Socket" scheme="http://example.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>PAXOS共识算法</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/PAXOS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/PAXOS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-03T11:37:59.000Z</published>
    <updated>2022-03-03T11:59:31.192Z</updated>
    
    <content type="html"><![CDATA[<p>实现共识算法中比较古老且复杂的共识算法PAXOS，几乎没有应用于区块链了。</p><span id="more"></span><h1 id="PAXOS共识算法"><a href="#PAXOS共识算法" class="headerlink" title="PAXOS共识算法"></a>PAXOS共识算法</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>了解区块链的基本共识算法，体会PAXOS共识算法与其他共识算法的异同。</li><li>了解PAXOS算法的基本过程，并实现PAXOS算法。</li><li>体会分析Basic-PAXOS算法的缺陷，并提出改进方案。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>Paxos算法中有四个角色Client（议题产生者）、Proposer（正式提议者）、Acceptor（投票决策者）和Learner（最终结果学习者），这四个角色中Client和Learner角色是两个广义的概念，而真正完成算法的是<strong>Proposer和Acceptor</strong>，因此该算法我将通过两部分来实现。</p><ul><li><p>Prepare</p><p>该阶段是proposer提出一个提案，编号为N，然后该编号如果大于proposer之前提出的编号，则请求acceptors接收。</p><p>因为是一个模拟过程，所以提案的内容我采用的是随机生成的方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v = PROPOSALS[rand() % ARRAY_LENGTH(PROPOSALS)];                <span class="comment">//提议的内容</span></span><br><span class="line">        <span class="keyword">if</span> ((!<span class="built_in">queue</span>.empty()) &amp;&amp; rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.5</span> &gt; <span class="number">0</span>) &#123;<span class="comment">//如果提案满足多数派</span></span><br><span class="line">            b = <span class="built_in">queue</span>.front();              <span class="comment">//拿出第一个提案并出列</span></span><br><span class="line">            <span class="built_in">queue</span>.pop();                    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = last_prepare_b + <span class="number">1</span>;             <span class="comment">//将prepare的提案入队</span></span><br><span class="line">            last_prepare_b ++;</span><br><span class="line">            <span class="keyword">if</span> (rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.7</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(b);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在这里我借助了队列的数据结构来实现提案的准备过程。</p></li><li><p>Promise</p><p>Promise阶段所做的工作是如果N大于此acceptor之前接收的任何提案的编号，则acceptor将对其进行批准，否则就拒绝。</p><p>Acceptor需要存储的内容：①已接受的编号最大的提案。②已响应的请求的最大编号。</p><p>两个承诺：</p><ol><li><p>不再接受N小于等于当前请求的Prepare请求。</p></li><li><p>不再接受N小于当前请求的Propose请求。</p></li></ol><p>一个应答：</p><p>不违背以前作出的承诺下，回复已经Accept过的提案中N最大的那个提案的Value和N，没有则返回空值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Promise* <span class="title function_">onPrepare</span><span class="params">(<span class="type">long</span> b)</span> &#123;        </span><br><span class="line">        <span class="comment">//假设这个过程有50%的几率失败</span></span><br><span class="line">        <span class="keyword">if</span> (rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.5</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; prepare no response&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b &gt;= this-&gt;pb) &#123;</span><br><span class="line">            pb = b;</span><br><span class="line">            Promise *response = new Promise(<span class="literal">true</span>, this-&gt;ab, this-&gt;av);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; prepare ok&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; prepare rejected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> new Promise(<span class="literal">false</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该阶段是由acceptor来具体实现的，为了使其更加实用，我定义了一个<code>promise.h</code>的头文件，将<code>promise</code>封装成了一个类，在第二阶段将其返回给proposer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">bool</span> ack;</span><br><span class="line">    <span class="type">long</span> ab;</span><br><span class="line">    <span class="built_in">string</span> av;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Promise(<span class="type">bool</span> ack, <span class="type">long</span> ab, <span class="built_in">string</span> av) &#123;</span><br><span class="line">        this-&gt;ack = ack;</span><br><span class="line">        this-&gt;ab = ab;</span><br><span class="line">        this-&gt;av = av;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isAck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getAb</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getAv</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> av;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Accept</p><p>第三阶段是Accept阶段，由Proposer来完成，即如果proposer收到了过半人数的回应，Proposer将会发出accept的回应<code>(N,V)</code>，该回应包含了提案编号及提案的内容。如果响应中不包含任何提案，那么V就由Proposer自己决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; acceptors.size(); i ++) &#123;  </span><br><span class="line">            Promise *promise = acceptors[i]-&gt;onPrepare(b);</span><br><span class="line">            <span class="keyword">if</span> (promise &amp;&amp; promise-&gt;isAck()) &#123;</span><br><span class="line">                count_pre_ok ++;</span><br><span class="line">                <span class="keyword">if</span> (promise-&gt;getAb() &gt; maxb &amp;&amp; promise-&gt;getAv() != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                    maxb = promise-&gt;getAb();</span><br><span class="line">                    v = promise-&gt;getAv();</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vote    : v change &lt; maxb : &quot;</span> &lt;&lt; maxb &lt;&lt; <span class="string">&quot; v : &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count_pre_ok &lt; quorum) &#123;        <span class="comment">//quorum为法定人数</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;prepare : end &lt;&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;&gt; : vote &lt; not accepted &gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count_accept_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; acceptors.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (acceptors[i]-&gt;onAccept(b, v)) &#123;</span><br><span class="line">                count_accept_ok ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count_accept_ok &lt; quorum) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;accept  : end &lt;&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&gt; : vote &lt; not accepted &gt;&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Accepted</p><p> 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">onAccept</span><span class="params">(<span class="type">long</span> b, <span class="built_in">string</span> v)</span> &#123;</span><br><span class="line">        <span class="comment">//假设这个过程有50%的几率失败</span></span><br><span class="line">        <span class="keyword">if</span> (rand() / <span class="type">double</span>(RAND_MAX) - <span class="number">0.5</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; accept no response&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b == this-&gt;pb) &#123;</span><br><span class="line">            ab = b;</span><br><span class="line">            av = v;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; accept ok &lt; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accepter: &quot;</span> &lt;&lt; this-&gt;name &lt;&lt; <span class="string">&quot; accept rejected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了模拟更真实的情况，在acceptor进行的两个阶段当中，都假设过程有50%的概率失败。</p><h3 id="实验中出现的问题"><a href="#实验中出现的问题" class="headerlink" title="实验中出现的问题"></a>实验中出现的问题</h3><p>在做该实验时我最大的困扰是边界问题。在Promise阶段，</p><ol><li>不再接受N<strong>小于等于</strong>当前请求的Prepare请求;</li><li>不再接受N<strong>小于</strong>当前请求的Propose请求。</li></ol><p>开始很多次都没做对，后来发现是这里的边界问题没处理好。</p></li></ul><h2 id="实验结果展示及分析"><a href="#实验结果展示及分析" class="headerlink" title="实验结果展示及分析"></a>实验结果展示及分析</h2><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124121028688.png" alt="image-20211124121028688"></p><p><img src="https://gitee.com/zhong-kangwei/picbed/raw/master/pic/image-20211124121038481.png" alt="image-20211124121038481"></p><p>这是整个实验的一次随机生成的提案过程，最后达成共识得到提案成功。</p><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><ul><li><p>Liveness</p><p>经过资料查找后，我了解到Basic-Paxos可能会出现Liveness问题，但是在我多次尝试的过程中还没有出现过。</p><p>出现活锁的情况如下：两个承诺之一，Acceptor不再应答N小于等于当前请求的Prepare请求，意味着需要应答N大于当前请求的Prepare请求，若两个Proposers交替Prepare成功，而Accept失败，则形成活锁，使得提案一直不成功。</p><p>解决该问题的方案有两个，第一个就是加上时延，每次提案都等上次提案处理完再进行，这样不会形成活锁问题，但是这样处理会降低处理的效率，从而导致程序运行过慢。</p><p>后来提出的方案还有Multi-Paxos的处理方案，即选则一个Leader，只有Leader提交提案，这样就不会造成活锁问题。</p></li><li><p>实用性</p><p>Paxos算法认为，在信道不可信的前提下，通过消息传递的方式达成一致性，是不可能的。因此，Paxos算法的前提是不存在拜占庭将军问题。也就是，认为信道是可信的，集群间传递的消息，不会被篡改。因此，虽然它是共识算法的基础，中的但是它在区块链中其实是不太实用的，它达到了CAP定理中的C（一致性）、P（分区容忍性），但是牺牲了A（可用性）。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现共识算法中比较古老且复杂的共识算法PAXOS，几乎没有应用于区块链了。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实验" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="共识算法" scheme="http://example.com/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="信息安全环境与工具" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于QR码的防伪电子票数字水印方法</title>
    <link href="http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E7%8E%B0/%E5%9F%BA%E4%BA%8EQR%E7%A0%81%E7%9A%84%E9%98%B2%E4%BC%AA%E7%94%B5%E5%AD%90%E7%A5%A8%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E7%8E%B0/%E5%9F%BA%E4%BA%8EQR%E7%A0%81%E7%9A%84%E9%98%B2%E4%BC%AA%E7%94%B5%E5%AD%90%E7%A5%A8%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%B3%95/</id>
    <published>2022-03-03T11:34:18.000Z</published>
    <updated>2022-03-03T11:42:49.983Z</updated>
    
    <content type="html"><![CDATA[<p>《信息安全环境与工具》的课程实验，实现在二维码上加暗水印的电子票，应用广泛，鲁棒性强。</p><span id="more"></span><h1 id="基于QR码的防伪电子票数字水印方法"><a href="#基于QR码的防伪电子票数字水印方法" class="headerlink" title="基于QR码的防伪电子票数字水印方法"></a>基于QR码的防伪电子票数字水印方法</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li><p>比较防伪电子票数字水印算法和通常多媒体数字水印算法之间的差异，体会其实现方法的异同。</p></li><li><p>了解常见的二值图像数字水印算法在电子票中的性能，并体会该实验算法的优势。</p></li><li><p>实现防伪电子票的数字水印并体会其在安全方面的作用。</p></li><li><p>体会混沌密钥自适应调整策略，在确保条码信息可识别的情况下，最大限度提高嵌入的容量和鲁棒性。</p></li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>对于电子票防伪检测流程的整个过程如下：</p><p><img src="https://s2.loli.net/2022/03/03/En7fULzD9vQGopc.png" alt="image-20211124122310247"></p><p>接下来我将实现的是对其嵌入水印和提取水印的过程。</p><h3 id="处理嵌入水印"><a href="#处理嵌入水印" class="headerlink" title="处理嵌入水印"></a>处理嵌入水印</h3><p>因为电子票是二值图像，所以首先使用matlab中自带的函数<code>unicode2native()</code>将要嵌入的字符串转换成UTF-8编码，然后通过<code>dec2bin</code>函数将其转化为二值编码，并将其连接。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg_origin = unicode2native(<span class="string">&#x27;hahahahayouaremymoney1234564878998987:1176.71&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>); </span><br><span class="line">msg_bin = dec2bin(msg_origin, <span class="number">8</span>); </span><br><span class="line">msg = strjoin(cellstr(msg_bin)&#x27;,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="嵌入图像处理"><a href="#嵌入图像处理" class="headerlink" title="嵌入图像处理"></a>嵌入图像处理</h3><ul><li><p>二维映射转一维映射</p><p>电子票是二维的图像，所以首先我们应当将图像处理为一维的映射，然后再将水印嵌入。</p><p><img src="https://s2.loli.net/2022/03/03/z2divtoqGhreCNE.png" alt="image-20211124102755270"></p><p>通过二维矩阵转一维矩阵的方式，我们就成功实现了由维映射到一维映射的转换，代码实现如下：</p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reflect=[];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : width</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span> : high</span><br><span class="line">        reflect(<span class="built_in">i</span>+width*<span class="built_in">j</span>)=image(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>水印嵌入</p><p>水印嵌入使用的是Logistic混沌映射，以混沌密钥k为初始值产生混沌序列{$k_i$}，并由此产生坐标$x_i&#x3D;[(M^2-1)k_i],i&#x3D;0,1,2…$，取互相不重合的前N个位置$x_i$为水印嵌入位置，代码实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">size</span>(msg,<span class="number">2</span>);</span><br><span class="line">position=[];</span><br><span class="line">k=[];</span><br><span class="line">k(<span class="number">1</span>)=<span class="number">0.2</span>;</span><br><span class="line">u=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : N<span class="number">-1</span>    </span><br><span class="line">    k(<span class="built_in">i</span>+<span class="number">1</span>)=u*k(<span class="built_in">i</span>)*(<span class="number">1</span>-k(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接着，将这N个位置嵌入水印，其算法如下：</p><p><img src="https://s2.loli.net/2022/03/03/5QjmDpona26gYKz.png" alt="image-20211124103559112"></p><p>代码实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : N</span><br><span class="line">    position(<span class="built_in">i</span>)=<span class="built_in">fix</span>((width*width<span class="number">-1</span>)*k(<span class="built_in">i</span>))+width;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">j</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=position</span><br><span class="line">    msg_tmp=msg(<span class="built_in">j</span>);</span><br><span class="line">    reflect(<span class="built_in">i</span>)=msg_tmp;</span><br><span class="line">    <span class="built_in">disp</span>(reflect(<span class="built_in">i</span>));</span><br><span class="line">    <span class="built_in">j</span>=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>一维映射还原成二维图像</p><p>按照二维映射转一维映射的逆过程，我们可以将得到的水印嵌入后的二维图像，其代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : width</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span> : high</span><br><span class="line">        image_end(<span class="built_in">i</span>,<span class="built_in">j</span>)=reflect(<span class="built_in">i</span>+width*<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="提取水印"><a href="#提取水印" class="headerlink" title="提取水印"></a>提取水印</h3></li></ul><p>提取水印是嵌入水印的一个逆过程，此处不再重复上述过程。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">reflect=[];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : width</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:high</span><br><span class="line">             reflect(<span class="built_in">i</span>+width*<span class="built_in">j</span>)=image(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    k(<span class="number">1</span>)=key;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:lenth<span class="number">-1</span></span><br><span class="line">        k(<span class="built_in">i</span>+<span class="number">1</span>)=u*k(<span class="built_in">i</span>)*(<span class="number">1</span>-k(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span> : lenth</span><br><span class="line">        position(<span class="built_in">i</span>)=<span class="built_in">fix</span>((width*width<span class="number">-1</span>)*k(<span class="built_in">i</span>))+width;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    watermarking=[];</span><br><span class="line">    index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=position</span><br><span class="line">        msg_num=reflect(<span class="built_in">i</span>)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">disp</span>(reflect(<span class="built_in">i</span>));</span><br><span class="line">        watermarking(index)=msg_num;</span><br><span class="line">        index=index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    msg=blanks(<span class="number">104</span>);</span><br><span class="line">    len=<span class="built_in">size</span>(watermarking,<span class="number">2</span>);</span><br><span class="line">    msg=num2str(watermarking);<span class="comment">%将提取出的数字转化为字符串</span></span><br><span class="line">    msg_bin=strrep(msg,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>);<span class="comment">%串替换</span></span><br><span class="line">    index=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>提取出来以后，同样通过字符编码转换的方式得到我们最开始输入的字符串：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msg_origin=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">8</span>:<span class="built_in">size</span>(watermarking,<span class="number">2</span>)<span class="number">-7</span></span><br><span class="line">        rgb(index) = bin2dec(msg_bin(<span class="built_in">i</span> : <span class="built_in">i</span>+<span class="number">7</span>));</span><br><span class="line">        msg_origin =native2unicode(rgb, <span class="string">&#x27;UTF-8&#x27;</span>);</span><br><span class="line">        index=index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(msg_origin);</span><br></pre></td></tr></table></figure><p>至此为止，实验的过程大致完毕。</p><h2 id="实验中出现的问题"><a href="#实验中出现的问题" class="headerlink" title="实验中出现的问题"></a>实验中出现的问题</h2><p>由于对matlab的函数不够熟悉，在实现字符串转化成二进制时开始出现了问题，后来通过加入先转换为<code>utf-8</code>编码将问题解决，即：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg_origin = unicode2native(<span class="string">&#x27;hahahahayouaremymoney1234564878998987:1176.71&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>); </span><br><span class="line">msg_bin = dec2bin(msg_origin, <span class="number">8</span>); </span><br><span class="line">msg = strjoin(cellstr(msg_bin)&#x27;,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="实验结果展示及分析"><a href="#实验结果展示及分析" class="headerlink" title="实验结果展示及分析"></a>实验结果展示及分析</h2><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p>我使用二维码生成器生成了一个网页的二维码来替代电子票，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/03/GSZbeWtlThFEvCA.png" alt="QR"></p><p>通过<code>embed</code>处理后，得到的结果为：</p><p><img src="https://s2.loli.net/2022/03/03/ScGx8Crb3QHihfu.png" alt="result"></p><p>从肉眼看上去，会多出一些小点点，但是并不影响机器的扫描，接着我们使用<code>extract</code>成功从中提取了我们之前嵌入的字符串水印：</p><p><img src="https://s2.loli.net/2022/03/03/gwdzN54UqYDlQSH.png" alt="image-20211124104848894"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><table><thead><tr><th>水印长度&#x2F;bits</th><th><strong>平均自适应调准次数</strong></th><th><strong>识别率&#x2F;%</strong></th><th><strong>鲁棒性</strong></th></tr></thead><tbody><tr><td>32</td><td>0.2</td><td>100</td><td>很强</td></tr><tr><td>62</td><td>2.7</td><td>100</td><td>很强</td></tr><tr><td>128</td><td>21.5</td><td>100</td><td>很强</td></tr><tr><td>160</td><td>49.8</td><td>63.68</td><td>较强</td></tr></tbody></table><p>通过多次实验可以得到如上的表格，从表格中我们可以看出当嵌入水印达到128bits时，本算法仍然能够完全正确地识别出电子票，当水印长度增加到160bits时，只有63.68%的试验能够完成自适应水印嵌入，并且自适应调整的次数较多。鲁棒性越强，电子票的伪造难度就越大。在实际应用中，128bits的水印已经足够防伪系统的使用，因此，该系统是比较完善的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《信息安全环境与工具》的课程实验，实现在二维码上加暗水印的电子票，应用广泛，鲁棒性强。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记及实现" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="信息安全环境与工具" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
    <category term="数字水印" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>本地差分隐私研究综述</title>
    <link href="http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E6%9C%AC%E5%9C%B0%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/"/>
    <id>http://example.com/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/%E6%9C%AC%E5%9C%B0%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/</id>
    <published>2022-03-03T11:32:32.000Z</published>
    <updated>2022-03-03T11:33:29.569Z</updated>
    
    <content type="html"><![CDATA[<p>对2018年软件学报论文的翻译。</p><span id="more"></span><h1 id="本地化差分隐私研究综述"><a href="#本地化差分隐私研究综述" class="headerlink" title="本地化差分隐私研究综述"></a>本地化差分隐私研究综述</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本地化差分隐私技术应用场景：</p><ul><li><p>众包数据采集</p><p>数据收集者将数据采集任务分配给不同用户进行。当用户参与众包数据采集时，不可避免存在泄露个人敏感信息的风险，这时就需要隐私保护技术为其保驾护航。</p></li><li><p>敏感图像特征提取</p><p>很多来自个人的形象蕴含很多敏感信息，如人脸、指纹等，对此类图像的存储和分析过程进行相应的隐私保护。本地化差分隐私技术在用户端完成对图像的扰动处理，保证无论是数据收集者或者数据传输过程中的攻击者均无法窃取图像中的隐私信息。（可以改？</p></li></ul><p>研究时考虑的问题：</p><ul><li>如何设计满足ε-本地化差分隐私的数据扰动算法，以保护其中敏感信息</li><li>数据收集者如何对查询结果进行求精处理，以提高统计结果的可用性</li></ul><p>本文内容：</p><ul><li>最新进展，研究背景，基本定义，实现机制，与中心化差分隐私技术区别</li><li>研究方向分析，着重介绍数据扰动机制以及两种基本数据发布形式：频数统计，均值统计</li><li>提出未来研究方向并分析</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对数据进行隐私化处理–&gt;将处理后的数据发给数据收集者–&gt;收集者对采集到的数据进行统计并得到分析结果</p><p>即在对数据进行统计分析的同时，保证个体的隐私信息不被泄露</p><blockquote><p>定义1：</p></blockquote><p>控制任意两条记录输出结果的相似性，确保算法M满足ε-本地化差分隐私。</p><p>根据M的输出结果，几乎无法推理出输入数据为哪一条记录。</p><h3 id="扰动机制"><a href="#扰动机制" class="headerlink" title="扰动机制"></a>扰动机制</h3><p>随机相应技术(W-RR)是本地化差分隐私的主流扰动机制。</p><p>W-RR是利用对敏感问题响应的不确定性对原始数据进行隐私保护，主要包括两个步骤：扰动性统计和校正。</p><ul><li><p>扰动性统计</p><p>举例（艾滋病患者的例子）按想法求比例-&gt;构造似然函数-&gt;得到极大似然估计（保证其无偏）-&gt;根据定义计算ε</p></li><li><p>离散型数据的W-RR</p><p>W-RR仅对包含两种取值的离散型数据进行响应，对具有超过两种取值的数据并不适用，因此有两种思路</p><ul><li><p>对变量的不同取值进行编码转化，使其满足W-RR对二值变量的要求。k个候选值，将每一个都编码成logk取上界的0&#x2F;1串，然后对每一位上的0&#x2F;1进行随机响应。</p><p>缺点：logk并非刚好取整，因此存在某些0&#x2F;1串未能匹配到相应候选值，由此造成匹配误差以及随机相应技术本身的扰动误差，使得数据发布的可用性降低。因此技术难点在属性候选值的编码和匹配策略上。</p></li><li><p>改进W-RR技术，使其能够直接适用于超过两种取值的变量。具体来说，就是保证概率的分布能够覆盖到k种取值中的任意一种。（k-RR和O-RR）</p></li></ul></li><li><p>连续型数据的W-RR</p><p>将连续型数据离散化，然后用离散型数据下的随机响应方法对其进行扰动。</p><p>难点：合理设置离散化的两个数值，如何保证统计结果无偏性</p></li></ul><h3 id="本地化与中心化差分隐私的异同点"><a href="#本地化与中心化差分隐私的异同点" class="headerlink" title="本地化与中心化差分隐私的异同点"></a>本地化与中心化差分隐私的异同点</h3><p>本地化继承中心化的组合特性，同时又对其进行了扩展，利用W-RR的扰动机制抵抗不可信第三方数据收集者带来的隐私攻击。</p><ul><li><p>组合特性</p><ul><li><p>序列组合性</p><p>隐私预算ε可以在方法的不同步骤进行分配，n个隐私算法{$M_1…M_n$}满足$ε_i$-本地化差分隐私，则在数据集合D上的序列组合满足ε-本地化差分隐私，ε为$ε_i$的和</p></li><li><p>并行组合性</p><p>保证满足差分隐私的算法在数据集的不相交子集上的隐私性。M在{$D_1,…,D_n$}都满足ε本地化差分隐私</p></li></ul></li><li><p>可信与不可信第三方</p><p>中心化：有可信第三方数据收集者，每个用户将真实数据记录发送给数据收集者，并假定其可信，不会泄露个人敏感信息。数据收集者用隐私算法对数据分析者的查询进行响应。</p><p>本地化：第三方数据收集者不可信，将数据扰动功能从数据收集方转移到了客户端，即每个用户处。每个用户按照隐私算法对数据进行扰动，然后把数据上传数据收集者，数据收集者接受数据分析者的查询请求，并进行响应。</p></li><li><p>噪声机制</p><p>中心化：有全局敏感性，需要噪声机制介入。</p><p>本地化：任意两个用户之间并不知晓对方数据记录，没有全局敏感性，用W-RR技术。</p></li><li><p>应用场景</p><p>中心化：对统计数据量不作特别要求。</p><p>本地化：噪声随机，要保证统计结果的无偏性，需要海量数据集来实现满足数据可用性的统计精度。</p></li></ul><h2 id="数据保护框架"><a href="#数据保护框架" class="headerlink" title="数据保护框架"></a>数据保护框架</h2><ul><li><p>交互式</p><p>第$i$个输出$Z_i$依赖于第i个输入$X_i$，以及前i个输出$Z_{1:i-1}$，但与前i个输入$X_{1：i-1}$无依赖关系</p><p>交互式通常应用于家族遗传病，性状等</p></li><li><p>非交互式</p><p>第$i$个输出$Z_i$仅依赖于第$i$个输入$X_i$</p><p>非交互式通常应用于商场购物数量等</p></li></ul><p>这两者最大区别在于输出结果之间的关联性。</p><h2 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h2><ul><li><p>本地化差分隐私的扰动机制研究</p><p>主要包括随机响应、信息压缩和扭曲</p></li><li><p>基于本地化差分隐私的单值频数发布</p></li><li><p>基于本地化差分隐私的多值频数发布</p></li><li><p>基于本地化差分隐私的均值发布</p></li></ul><h2 id="方法对比与分析"><a href="#方法对比与分析" class="headerlink" title="方法对比与分析"></a>方法对比与分析</h2><h3 id="基于本地化差分隐私的频数统计"><a href="#基于本地化差分隐私的频数统计" class="headerlink" title="基于本地化差分隐私的频数统计"></a>基于本地化差分隐私的频数统计</h3><ul><li><p>单值频数统计</p><p>单值频数统计是指每个用户只发送一个变量取值的情形。用户把数据发送给收集者，收集者根据已有的或统计得到的候选值列表，统计其中每个候选值的频数并发布。</p><p>代表方法：RAPPOR</p><p>其中变量以字符串的形式表示（Bloom Filter）</p><p>第一次扰动，用W-RR对向量B的每一个位进行扰动，得到PRR（永久性随机响应）结果B’</p><p>然后对B’的每一个位进行第二次扰动，得到IRR（瞬时性随机响应）结果S</p><p>将S发送给第三方数据收集者，数据收集者统计每一位上1出现的次数并进行校正，然后结合映射矩阵通过Lasso回归方法完成每个年龄值对应的频数统计</p><p>误差：1）Bloom Filter进行编码，在解码过程中可能存在属性候选值冲突问题——–&gt;RAPPOR调整相应参数降低候选值冲突带来的误差；2）W-RR对数据扰动产生的误差问题，数据扰动带来的渐进误差边界为$O(k&#x2F;ε\sqrt{n})$，这是算法本身固有误差。</p><p>缺陷：<strong>1）传输代价较高，每个用户都要传输长度为h的向量给数据收集者；</strong></p><p>解决方案：S-Hist中每个用户对字符串进行编码后，随机选择其中一个比特位，利用W-RR扰动，将其发送给数据收集者。</p><p>同时，假设列表中字符串候选值个数k超过了用户数量n，利用随机投影技术将每个字符串表示成m&#x3D;O(n)维二值变量，生成一个随机投影矩阵，其中每个元素的取值集合为{$1&#x2F;\sqrt{m},-1&#x2F;\sqrt{m}$}，以使得矩阵中每个列向量的内积为1，而任意不同两个列向量的内积为0。渐进误差边界：$O(\sqrt{logk}&#x2F;ε\sqrt{n})$</p><p>优点：极大降低通信代价</p><p><strong>2）数据收集者需预先采集候选字符串列表以进行频数统计；</strong></p><p>解决方案：O-RAPPOR</p><p>在RAPPOR的基础上引入哈希映射和分组操作。对于每个字符串，先用哈希函数进行一次值的映射，后续的扰动步骤直接对哈希值进行处理，这样就不需要预知候选字符串的列表</p></li><li><p>多值频数统计</p><p>每个用户发送多个变量取值的情形，用户将数据发送给数据收集者后，数据收集者根据已有的或统计得到的候选值列表，统计其中每一个候选值的频数并进行发布。</p><p>需要考虑隐私预算的分割问题。可以将单值频数统计方法重复地用在多值情形中的每一个变量上，但是如此可能导致两个问题：</p><p>1）根据变量的数量分割隐私预算，当变量较多时，数据可用性急剧降低</p><p>2）忽略了变量之间的关联关系，损失部分信息——-&gt;&gt;预先采集候选字符串列表</p><p>针对2）有一个方法，</p><ul><li><p>RAPPOR-unknown。</p><p>它基于n-gram（字符串长度为n的子串）的思想，得到扰动结果后，从字符串中抽取r个长度相同的子串，然后将扰动结果和子串相关信息一起发给第三方数据收集者。</p><p>RAPPOR-unknown是将隐私预算ε进行（r+1)等分，分别分配给扰动结果和r个子串的计算过程。</p><p>采集数据后，数据收集者通过共现技术还原字符串，以得到字符串列表。针对多值的情形，RAPPOR-unknown利用期望最大化算法，估计多个变量的联合概率分布，以进行列联表的查询。</p><p>该方法要将子串及其位置信息一起传输给数据收集者用于统计候选值列表，比RAPPOR方法多出O(r)的传输代价，不适合字串较多的情形。</p></li><li><p>Harmony-frequency</p><p>S-Hist方法虽然极大降低了通信代价，但在实际应用中稳定性不确定，因为随机投影矩阵中每个元素的正负取值具有随机性，要使任意两个列向量的内积为0，前提是字符串的候选值k足够大。</p><p>针对关系型数据，又提出了Harmony方法，可用于连续型数据的均值统计和离散型数据的频数统计两种查询。</p><p>其运用于频数统计的方法叫做Harmony-frequency，该方法改进了随机投影矩阵，用迭代的方式生成一个k×k的随机投影矩阵，其中保证了矩阵任意两个列向量正交（内积为0），渐进误差边界：$O(\sqrt{dlogk}&#x2F;ε\sqrt{n})$，<strong>有更高的发布精度</strong>。</p></li><li><p>LDPMiner</p><p>是集值数据下的频数发布方法，针对Heavy hitter查询。1）数据收集者采集数据，确定Heavy hitter集合并将其返回给用户；2）用户发送集合中k’个项所对应的数据。</p><p>LDPMiner是基于RAPPOR和S-Hist方法实现的一个组合方法。因为每个用户需要发送多个数据项，通信代价较高，因此用随机采样技术令每个用户只发送其中一个数据项，然后用RAPPOR和S-Hist方法来进行数据扰动。</p><p>采样+RAPPOR–&gt;sampling RAPPOR</p><p>采样+S-Hist–&gt;sampling SH</p><p>LDPMiner的两个阶段：</p><p>阶段1：sampling SH：用户通过sampling SH将扰动后的数据发送给数据收集者，数据收集者统计每个数据项的频数，确定频数最高的k’个项的集合，并将该集合返回给用户</p><p>阶段2：sampling RAPPOR：用户通过sampling RAPPOR将阶段一返回的数据项所对应的数据再次发送给数据收集者，数据收集者统计每个数据项的频数，得到k’个数据项的频数</p><p>从两个方面的数据处理提高数据可用性：</p><p>1）通过采样技术避免了隐私预算在不同数据项上的分割；</p><p>2）频繁项集合的确定和频数统计两个操作分离，缩小了需要扰动的数据项集合，增大了k‘个数据项所分配到的隐私预算</p></li><li><p>Lopub</p><p>结合RAPPOR和概率图模型的多值频数统计方法。</p><p>思路：</p><p>1）用户的数据扰动；&#x3D;&#x3D;&gt;RAPPOR</p><p>2）数据收集者估计联合概率分布并进行数据降维；&#x3D;&#x3D;&gt;构建马尔科夫网络，利用属性之间的关联性得到极大团，并将属性的联合概率分布以极大团的形式来表示，以达到数据降维的目的。</p><p>3）合成数据集。&#x3D;&#x3D;&gt;通过联合概率分布重新合成一个数据集进行数据发布</p></li><li><p>多值频数统计方法对比分析</p></li></ul></li></ul><h3 id="基于本地化差分隐私的均值统计"><a href="#基于本地化差分隐私的均值统计" class="headerlink" title="基于本地化差分隐私的均值统计"></a>基于本地化差分隐私的均值统计</h3><p>  主要思想：对个体值添加正向和负向的噪声，最终通过聚合大量扰动结果将其抵消，从而使统计结果满足一定的可用性要求。</p><p>  代表方法：MeanEst，Harmony-mean</p><ul><li><p>MeanEst</p><p>将包含n个元组的d维数据集中的第i个元组按照一定概率分布，并结合随机响应技术，转变成一个仅含二值变量的元组，同时保证最终的统计结果是一个无偏估计量，其中B的计算仅与隐私预算ε和数据维度d有关。</p><p>该方法的值与数据集的维度d呈指数关系，当数据集的维度比较高时，所需的时间和空间代价都比较高，使得B值的计算受到限制。因此，<strong>不适用于维度d较高的数据集</strong>。</p></li><li><p>Harmony-mean</p><p>简化了MeanEst方法，从d个数据维度中随机抽取一个维度j，最终输出的元组中仅一个维度上的变量有相应的取值，而其他维度上变量的取值为0。通信代价为MeanEst的1&#x2F;d，渐进误差边界与其相同，有相近的发布精度。</p></li><li><p>均值统计方法对比分析</p></li></ul><h3 id="基于信息压缩和扭曲的扰动机制"><a href="#基于信息压缩和扭曲的扰动机制" class="headerlink" title="基于信息压缩和扭曲的扰动机制"></a>基于信息压缩和扭曲的扰动机制</h3><ul><li><p>Compression</p><p>每个用户对应一个d维的元组X，对输入域进行压缩，得到X’，压缩过程保证元组X与X‘的对应关系满足本地化差分隐私保护。</p><p>进行压缩会产生偏差，引入扭曲度对偏差的期望进行约束</p><p>&#x3D;&#x3D;&gt;把问题转化为给定扭曲度δ和压缩率ρ，求最小ε的凸优化 =&#x3D;&gt; 二分法求解</p><p>其中ε表示隐私的保护程度，δ表示数据统计结果的可用性，通过压缩率将两者直接联系起来。</p></li><li><p>Distortion</p><p>通过扰动函数对X进行扰动得到X’，然后定义信息扭曲度约束其偏差，保证数据具有一定的可用性。</p></li></ul><h3 id="本地化差分隐私技术的实验特性分析"><a href="#本地化差分隐私技术的实验特性分析" class="headerlink" title="本地化差分隐私技术的实验特性分析"></a>本地化差分隐私技术的实验特性分析</h3><p>  本地化差分隐私技术主要依赖于ε的设定，ε的取值决定了隐私化处理后数据的可用性高低。但同时，对数据集的数据量有一定的要求，数据量也是影响数据可用性的一个重要因素。</p><ul><li><p>隐私预算对数据可用性的影响</p><p>隐私保护程度与数据可用性呈负相关。当给定较多的隐私预算时，统计结果比较接近真实值。</p></li><li><p>数据量对数据可用性的影响</p><p>同样的隐私预算的情况下，统计的数据量小时，偏差较大；统计的数据量大时，偏差较小。</p></li></ul><h2 id="研究挑战"><a href="#研究挑战" class="headerlink" title="研究挑战"></a>研究挑战</h2><p>目前的研究主要集中在两个方面：</p><p>1）理论上，设计满足本地化差分隐私的保护机制；</p><p>2）方法上，对频数和均值两种统计结果进行保护</p><p>现在还有很多挑战性的问题未解决：</p><h3 id="复杂数据类型的本地化差分隐私保护"><a href="#复杂数据类型的本地化差分隐私保护" class="headerlink" title="复杂数据类型的本地化差分隐私保护"></a>复杂数据类型的本地化差分隐私保护</h3><p>e.g.</p><p>键值对：需要对键和值都进行隐私化处理，且仍需保证“键”和“值”之间的对应性</p><p>图数据：全局敏感性极高，本地化差分隐私技术虽然不存在敏感性过大的问题，但每个用户对数据扰动过程相互独立，数据收集者如何根据扰动后的数据构建可用性高的图结构，即如何保证原始数据之间的关联性是一大挑战。</p><h3 id="不同查询和分析任务的本地化差分隐私保护"><a href="#不同查询和分析任务的本地化差分隐私保护" class="headerlink" title="不同查询和分析任务的本地化差分隐私保护"></a>不同查询和分析任务的本地化差分隐私保护</h3><p>本地化差分隐私下，不仅要求能够支持不同的查询类型，还要求扰动后的数据能够同时支持多种不同的查询。本地化差分隐私通过抵消添加在数据中的正向和负向噪声来得到比较准确的统计结果，就单条数据而言通常扰动前后数据偏差较大，加大了查询难度。</p><p>因此主要考虑以下三种实现方法：</p><p>1）提供对除计数查询和均值查询外的多种查询方式的支持；</p><p>2）数据扰动方式与查询类型的解绑，使得扰动后的数据给、能够同时支持多种查询；</p><p>3）提高数据分析结果的可用性。</p><h3 id="基于本地化差分隐私的高维数据发布"><a href="#基于本地化差分隐私的高维数据发布" class="headerlink" title="基于本地化差分隐私的高维数据发布"></a>基于本地化差分隐私的高维数据发布</h3><p>属性个数较多&#x3D;&#x3D;&gt;数据维度较高=&#x3D;&gt;数据规模变大，信噪比降低，增加通信代价（线性&#x2F;指数增长）</p><p>目前的解决方案：属性划分</p><p>在满足本地化差分隐私的基础上，将高维数据的联合概率分布分解为多个低维的边缘概率分布形式，然后将其通过某种推理机制近似估计联合概率分布。</p><p>但是该方法在高维数据的情况下会带来很大噪声，使得推理结果准确性大大降低。</p><p>因此考虑三个问题：</p><p>1）如何在一定隐私预算内衡量属性之间的关联性，从而进行降维处理；</p><p>2）如何设计推理模型，最小化边缘分布到联合分布的近似误差，提高数据可用性；</p><p>3）如何控制高维数据在用户和数据收集者之间的通信代价</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对2018年软件学报论文的翻译。&lt;/p&gt;</summary>
    
    
    
    <category term="隐私计算" scheme="http://example.com/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="隐私计算" scheme="http://example.com/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="差分隐私" scheme="http://example.com/tags/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>静态分析基础</title>
    <link href="http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-03T11:30:15.000Z</published>
    <updated>2022-03-03T12:03:08.545Z</updated>
    
    <content type="html"><![CDATA[<p>恶意代码分析的基础——静态分析，分析程序指令与结构来确定功能。</p><span id="more"></span><h1 id="静态分析基础"><a href="#静态分析基础" class="headerlink" title="静态分析基础"></a>静态分析基础</h1><p>[toc]</p><p>静态分析指的是分析程序指令与结构来确定功能的过程。</p><h2 id="1-1-反病毒引擎扫描：实用的第一步"><a href="#1-1-反病毒引擎扫描：实用的第一步" class="headerlink" title="1.1 反病毒引擎扫描：实用的第一步"></a>1.1 反病毒引擎扫描：实用的第一步</h2><p>分析可疑的恶意代码样本时，第一步就是拿多个反病毒软件扫描这个文件，看是否有哪个引擎已经能够识别它。</p><p>反病毒软件&#x3D;&gt;依靠一个已知恶意代码可识别片段的特征数据库，以及基于行为与模式匹配的分析来识别可疑文件。</p><p>编写者&#x3D;&gt;修改代码，改变特征，躲避反病毒引擎的检测。</p><p>而且一些罕见的恶意代码根本不在特征数据库里。</p><p>启发式检测经常也能识别一些未知的恶意代码，但仍然可以被一些新型的恶意代码绕过。</p><p>不同的反病毒软件特征库和启发式检测不一样，因此对一个恶意代码样本，要运行多个进行扫描检测。</p><p><a href="https://www.virustotal.com/gui/home/upload">VirrusTotal</a>可以上传一个文件，调用多个引擎扫描生成一个报告。</p><h2 id="1-2-哈希值：恶意代码的指纹"><a href="#1-2-哈希值：恶意代码的指纹" class="headerlink" title="1.2 哈希值：恶意代码的指纹"></a>1.2 哈希值：恶意代码的指纹</h2><p>哈希是一种用来唯一标识恶意代码的常用方法。恶意代码样本通过一个哈希程序，会产生出一段用于唯一标识这个样本的独特哈希值。</p><p>常用于恶意代码分析的哈希函数：</p><ul><li>MD5算法</li><li>SHA-1算法</li></ul><p><code>md5deep</code>可以计算Windows自带的Solitaire程序哈希值</p><p>当对一段恶意代码样本有了一段独特的哈希值之后，可以将其用于：</p><ul><li>作为标签使用</li><li>与其他人分享，以帮助他们识别恶意代码</li><li>在线搜索这段哈希值，看这个文件是否已经被识别</li></ul><h2 id="1-3-查找字符串"><a href="#1-3-查找字符串" class="headerlink" title="1.3 查找字符串"></a>1.3 查找字符串</h2><p>一个程序会包含一些字符串，如：打印出的消息，连接的URL，或是复制文件到某个特定位置。</p><p>从字符串中进行搜索是获得程序功能提示的一种简单方法。比如程序访问了一个URL，访问的URL就存储为程序中的一个字符串。可以使用<a href="technet.microsoft.com/en-us/sysinternals/bb897439">String</a>来搜索可执行文件中可打印的字符串，通常以ASCII或Unicode格式存储。</p><p>这两种格式都以NULL结束符表示字符串已经终结。一个NULL结束符表示该字符串是完整的。ASCII码每个字符用1B，Unicode用2B。</p><p>Strings程序从可执行程序中搜索ASCII和Unicode字符串时，忽略上下文和格式，所以它将分析任何文件类型，并从中检测出可以打印的字符串，<strong>可能会识别出实际上并非真正字符串的一些字符序列</strong>。它搜索三个及三个以上的连续ASCII和Unicode字符，并以终结符结尾的字符串。</p><p>但是一般检测出来，如果是无效的字符串，肉眼是很容易判断的，因为他们并不代表一些合法的文字。</p><p>DLL文件中包含着一个应用程序中共享的可执行代码。</p><h2 id="1-4-加壳与混淆恶意代码"><a href="#1-4-加壳与混淆恶意代码" class="headerlink" title="1.4 加壳与混淆恶意代码"></a>1.4 加壳与混淆恶意代码</h2><p><strong>混淆程序是恶意代码编写者尝试去隐藏其执行过程的代码。</strong></p><p>加壳程序是混淆程序中的一类，加壳后的恶意程序会被压缩，难以分析。</p><h3 id="1-4-1-文件加壳"><a href="#1-4-1-文件加壳" class="headerlink" title="1.4.1 文件加壳"></a>1.4.1 文件加壳</h3><p>加壳程序运行：运行一小段脱壳代码&#x3D;&gt;解压缩加壳的文件&#x3D;&gt;运行脱壳后的文件</p><p>进行静态分析时，只有一小段脱壳代码可以被解析。</p><h3 id="1-4-2-使用PEiD检测加壳"><a href="#1-4-2-使用PEiD检测加壳" class="headerlink" title="1.4.2 使用PEiD检测加壳"></a>1.4.2 使用PEiD检测加壳</h3><p>检测加壳软件的一种方法是使用PEiD工具。</p><p>使用UPX加壳的恶意代码比较容易进行脱壳处理，下载UPX工具就行，然后输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -d PackedProgram.exe</span><br></pre></td></tr></table></figure><h2 id="1-5-PE文件格式"><a href="#1-5-PE文件格式" class="headerlink" title="1.5 PE文件格式"></a>1.5 PE文件格式</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;恶意代码分析的基础——静态分析，分析程序指令与结构来确定功能。&lt;/p&gt;</summary>
    
    
    
    <category term="恶意代码分析实战" scheme="http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="恶意代码" scheme="http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析入门</title>
    <link href="http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-03T11:28:13.000Z</published>
    <updated>2022-03-03T11:29:28.103Z</updated>
    
    <content type="html"><![CDATA[<p>恶意代码分析入门概念。</p><span id="more"></span><h1 id="恶意代码分析技术入门"><a href="#恶意代码分析技术入门" class="headerlink" title="恶意代码分析技术入门"></a>恶意代码分析技术入门</h1><h2 id="0-1-恶意代码分析目标"><a href="#0-1-恶意代码分析目标" class="headerlink" title="0.1 恶意代码分析目标"></a>0.1 恶意代码分析目标</h2><ul><li>定位受感染的主机和文件</li><li>编写相应特征码&#x3D;&gt;检测感染主机</li><li>基于特征码，检测恶意代码</li><li>网络特征码&#x3D;&gt;监测网络流量检测恶意代码</li><li>弄清恶意代码如何工作</li></ul><h2 id="0-2-恶意代码分析技术"><a href="#0-2-恶意代码分析技术" class="headerlink" title="0.2 恶意代码分析技术"></a>0.2 恶意代码分析技术</h2><p>恶意代码分析有两种技术：静态分析，动态分析。静态分析是指没有运行代码时对其进行分析，动态分析则需要运行代码。</p><h3 id="0-2-1-静态分析基础技术"><a href="#0-2-1-静态分析基础技术" class="headerlink" title="0.2.1 静态分析基础技术"></a>0.2.1 静态分析基础技术</h3><ul><li>检查可执行文件但不查看具体命令</li><li>可以确认一个文件是否是恶意的</li><li>可能提供一些信息可以生成网络特征码</li><li>很快速，但大多数时候无效</li></ul><h3 id="0-2-2-动态分析基础技术"><a href="#0-2-2-动态分析基础技术" class="headerlink" title="0.2.2 动态分析基础技术"></a>0.2.2 动态分析基础技术</h3><ul><li>运行恶意代码并观察系统上的行为，以移除感染，产生有效的检测特征码</li><li>前提是建立一个安全环境，能够避免对系统和网络带来风险</li></ul><h3 id="0-2-3-静态分析高级技术"><a href="#0-2-3-静态分析高级技术" class="headerlink" title="0.2.3 静态分析高级技术"></a>0.2.3 静态分析高级技术</h3><ul><li>对恶意代码内部机制的逆向工程</li><li>将可执行文件装入反汇编器中，通过查看程序指令来发现恶意代码做了什么</li></ul><h3 id="0-2-4-动态分析高级技术"><a href="#0-2-4-动态分析高级技术" class="headerlink" title="0.2.4 动态分析高级技术"></a>0.2.4 动态分析高级技术</h3><ul><li>使用调试器来检查一个恶意可执行程序运行时刻的内部状态</li><li>可以从可执行文件中抽取详细的信息</li></ul><h2 id="0-3-恶意代码类型"><a href="#0-3-恶意代码类型" class="headerlink" title="0.3 恶意代码类型"></a>0.3 恶意代码类型</h2><ul><li><strong>后门</strong>：将自身安装到一台计算机来允许攻击者访问。通常让攻击者只需很少的认证或无须认证便可连接到远程计算机，并在本地系统执行命令。</li><li><strong>僵尸网络</strong>：允许攻击者访问系统，和后门类似。所有被同一个僵尸网络感染的计算机将会从一台控制命令服务器接收到相同的命令。</li><li><strong>下载器</strong>：下载其他恶意代码的恶意代码。在攻击者获得系统访问时首先进行安装的，下载器程序会下载和安装其他的恶意代码。</li><li><strong>间谍软件</strong>：从受害计算机上收集信息并发送给攻击者的恶意代码。</li><li><strong>启动器</strong>：启动其他恶意程序的恶意代码。一般使用一些非传统技术来启动其他恶意程序，以确保隐蔽性或以更高的权限访问系统。</li><li><strong>内核套件</strong>：隐藏其他恶意代码的恶意代码。通常和其他恶意代码组合成工具套装，来允许为攻击者提供远程访问，并且使其很难被受害者发现。</li><li><strong>勒索软件</strong>：吓唬受感染用户，勒索他们购买某些东西的恶意代码。（一般长得像杀毒软件，通知用户系统中有恶意代码，需要出钱买，然而事实上功能只是将勒索软件进行移除）</li><li><strong>发送垃圾邮件的恶意代码</strong>：感染计算机后使用系统和网络资源来发送大量垃圾邮件。（通过为攻击者出售垃圾邮件发送服务获益）</li><li><strong>蠕虫、计算机病毒</strong>：可以自我复制和感染其他计算机的恶意代码。</li></ul><p>恶意代码分为大众性的和针对性的，大众性的更容易被检测和防御，而针对性的比较难。</p><h2 id="0-4-恶意代码分析通用原则"><a href="#0-4-恶意代码分析通用原则" class="headerlink" title="0.4 恶意代码分析通用原则"></a>0.4 恶意代码分析通用原则</h2><ul><li>不要过于陷入细节。要先关注最关键的主要功能，先有一个概要性的了解。</li><li>对于不同的 任务使用不同的工具和方法。</li><li>不断更新技术。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;恶意代码分析入门概念。&lt;/p&gt;</summary>
    
    
    
    <category term="恶意代码分析实战" scheme="http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="恶意代码" scheme="http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux日志检测类型总结</title>
    <link href="http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/Linux%E6%97%A5%E5%BF%97%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/Linux%E6%97%A5%E5%BF%97%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-03T11:22:21.000Z</published>
    <updated>2022-03-03T11:29:35.600Z</updated>
    
    <content type="html"><![CDATA[<p>对Linux日志的基本分析以及对一些可能出现的恶意行为的分析。</p><span id="more"></span><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><h2 id="常见Linux日志"><a href="#常见Linux日志" class="headerlink" title="常见Linux日志"></a>常见Linux日志</h2><h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><ul><li>连接时间日志。由多个进程执行，把记录写入到<code>/var/log/wtmp</code>和<code>/var/run/utmp</code>。login等程序更新wtmp和utmp文件，使系统管理员能够跟踪到谁何时登录到系统；</li><li>进程统计。由系统内核执行。当一个进程终止时，为该进程往进程统计文件（pacct或acct）中写一个记录。进程统计的目的是为系统中的基本服务提供命令使用统计。</li><li>错误日志。由<code>syslogd(8)</code>执行。各种系统守护进程、用户程序和内核通过<code>syslogd(8)</code>向文件<code>/var/log/messages</code>报告值得注意的事件。</li></ul><h3 id="网络日志"><a href="#网络日志" class="headerlink" title="网络日志"></a>网络日志</h3><p>Linux系统下，网络服务器主要是Apache。Apache提供HTTP服务时产生访问日志<code>/usr/local/apache/logs/access_log</code>以及错误日志<code>/usr/local/apache/logs/access_log</code>两个日志文件。在Linux系统下，FTP日志则保存在<code>/usr/adm/xferlog</code>文件中，邮件日志在<code>/var/log/maillog</code>中。</p><p>总结：</p><table><thead><tr><th>日志</th><th>内容</th><th>文件</th></tr></thead><tbody><tr><td>lastlog</td><td>记录最近几次成功登录的事件和最后一次不成功登录</td><td><code>/usr/log/lastlog</code></td></tr><tr><td>utmp</td><td>记录当前登录的所有用户信息</td><td><code>/var/run/utmp</code></td></tr><tr><td>wtmp</td><td>记录每个用户登录&#x2F;退出的历史信息</td><td><code>/var/log/wtmp</code></td></tr><tr><td>sulog</td><td>记录su命令的使用情况信息</td><td><code>/var/log/sulog</code></td></tr><tr><td>Xfree86.x.log</td><td>该日志文件记录了X-Window启动</td><td><code>/var/log/Xfree86.x.log</code></td></tr><tr><td>kernlog</td><td>该文件记录了系统启动时加载设备或使用设备的情况</td><td><code>/var/log/kernlog</code></td></tr><tr><td>acct&#x2F;pact</td><td>记录用户执行能够的命令和资源使用情况</td><td><code>/var/run/pact</code></td></tr><tr><td>messages</td><td>syslog中值得注意的信息</td><td><code>/var/log/messages</code></td></tr><tr><td>syslog</td><td>记录由syslog产生的网络和系统信息</td><td><code>/var/log/syslog</code></td></tr><tr><td>btmp</td><td>记录失败信息</td><td><code>/var/log/btmp</code></td></tr><tr><td>access_log</td><td>记录http&#x2F;web的传输信息</td><td><code>/usr/local/apache/access_log</code></td></tr><tr><td>error_log</td><td>记录http&#x2F;web的错误信息</td><td><code>/usr/local/apache/logs/error_log</code></td></tr><tr><td>xferlog</td><td>记录FTP存取情况</td><td><code>/var/log/xferlog</code></td></tr><tr><td>maillog</td><td>记录发送和接收邮件信息</td><td><code>/var/log/maillog</code></td></tr></tbody></table><h3 id="各类日志文件的格式"><a href="#各类日志文件的格式" class="headerlink" title="各类日志文件的格式"></a>各类日志文件的格式</h3><ul><li>syslogd记录下的日志文件：ASCII文本文件，采用syslog协议和POSIX标准定义日志信息，由日期、时间、优先级、主机名和消息这几部分组成。</li><li>应用程序产生的日志文件：ASCII文本文件，现在大多数都是直接发往syslogd，统一由其处理，参照syslogd。</li><li>系统运行的一些有关安全和操作记录的文件。<ul><li>lastlog：二进制日志文件，由用户名、终端号、登入主机、日期和登入使用时间组成。</li><li>maillog：ASCII文本文件，基本由日期、时间、进程名、邮件代号和操作过程信息组成。</li></ul></li></ul><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><h3 id="登录日志"><a href="#登录日志" class="headerlink" title="登录日志"></a>登录日志</h3><ul><li>username：用户名</li><li>port：登陆点</li><li>from：用户主机</li><li>seq：登录号</li></ul><h3 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h3><ul><li>host：远程访问主机，在未确定是否入侵前，单独的远程访问主机名在判断入侵方面无作用，但若确认入侵，则需要知道远程主机名。</li><li>date：在不知道是否入侵前，没作用。</li><li>time：在不知道是否入侵前，没作用。</li><li>program程序：若程序有超出普通操作的范围，意味着越权发生。</li><li>msg日志消息：判断是否入侵中最重要的一环，记录了具体的访问行为，包括：<ul><li>行为：login，session open等。</li><li>目标：表示操作所针对的对象，apache日志中表示访问的页面内容。</li><li>完成状态或返回值：failed等，还有root也在此显示。</li></ul></li></ul><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><ul><li><p><code>/var/log/maillog</code></p><p>可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统。</p></li><li><p><code>/var/log/messages</code></p><p>该日志文件是许多进程日志文件的汇总<strong>从该文件可以看出任何入侵企图或成功的入侵</strong>。</p></li><li><p><code>/var/log/syslog</code></p><p>默认不生成该日志文件但可以配置&#x2F;etc&#x2F;syslog.conf让系统生成该日志文件。它和&#x2F;etc&#x2F;log&#x2F;messages日志文件不同它只记录警告信息常常是系统出问题的信息所以更应该关注该文件。要让系统生成该日志文件在&#x2F;etc&#x2F;syslog.conf文件中加上*.warning。该日志文件能记录当用户登录时login记录下的错误口令、Sendmail的问题、su命令执行失败等信息。</p></li><li><p><code>/var/log/secure</code></p><p>该日志文件记录与安全相关的信息。</p></li><li><p><code>/var/log/lastlog</code></p><p>该日志文件记录最近成功登录的事件和最后一次不成功的登录事件由login生成。在每次用户登录时被查询该文件是二进制文件需要使用 lastlog命令查看根据UID排序显示<strong>登录名、端口号和上次登录时间</strong>。如果某用户从来没有登录过就显示为”<strong>Never logged in</strong>“。该命令只能以<strong>root权限执行</strong>。</p><p>如果当前出现了很多“Never logged in”或发现记录的时间不是上次登录时间则很有可能账户泄密了。</p></li><li><p><code>/var/log/wtmp</code></p><p>该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。因此随着系统正常运行时间的增加该文件的大小也会越来越大增加的速度取决于系统用户登录的次数。该日志文件可以用来查看用户的登录记录last命令就通过访问这个文件获得这些信息并以反序从后向前显示用户的登录记录last也能根据用户、终端 tty或时间显示相应的记录。</p><p>命令last有两个可选参数</p><p>last -u 用户名显示用户上次登录的情况。</p><p>last -t 天数显示指定天数之前的用户登录情况。</p></li><li><p><code>/var/log/utmp</code></p><p>该日志文件记录有关当前登录的每个用户的信息。因此这个文件会随着用户登录和注销系统而不断变化它<strong>只保留当时联机的用户记录不会为用户保留永久的记录</strong>。系统中需要查询当前用户状态的程序如 who、w、users、finger等就需要访问这个文件。该日志文件<strong>并不能包括所有精确的信息因为某些突发错误会终止用户登录会话而系统没有及时更新 utmp记录</strong>因此该日志文件的记录不是百分之百值得信赖的。</p></li><li><p><code>/var/log/xferlog</code></p><p>该日志文件记录FTP会话可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序以及该用户拷贝了哪些文件供他使用。</p><p>该文件的格式为第一个域是日期和时间第二个域是下载文件所花费的秒数、远程系统名称、文件大小、本地路径名、传输类型ASCII&#x2F;二进制、与压缩相关的标志或tar或”_”如果没有压缩的话、传输方向相对于服务器而言i代表进o代表出、访问模式a匿名g输入口令r真实用户、用户名、服务名通常是ftp、认证方法lRFC931或0认证用户的ID或”*”。</p></li><li><p><code>/var/log/kernlog</code></p><p>Linux默认没有记录该日志文件。要启用该日志文件必须在&#x2F;etc&#x2F;syslog.conf文件中添加一行kern.* &#x2F;var&#x2F;log&#x2F;kernlog 。这样就启用了向&#x2F;var&#x2F;log&#x2F;kernlog文件中记录所有内核消息的功能。该文件记录了系统启动时加载设备或使用设备的情况。一般是正常的操作但如果记录了没有授权的用户进行的这些操作就要注意因为有可能这就是恶意用户的行为。</p></li></ul><h3 id="可疑的日志记录"><a href="#可疑的日志记录" class="headerlink" title="可疑的日志记录"></a>可疑的日志记录</h3><ul><li><p>非正常时间凌晨的用户登录</p></li><li><p>关键日志记录损坏尤其是记录用户登录登出信息的wtmp文件</p></li><li><p>非正常IP的用户登录</p></li><li><p>用户登录失败甚至一再尝试登录并失败的日志记录</p></li><li><p>非正常的超级用户权限切换su指令</p></li><li><p>非正常的控制进程启动或重启记录</p></li></ul><h3 id="查找对应进程的应用程序"><a href="#查找对应进程的应用程序" class="headerlink" title="查找对应进程的应用程序"></a>查找对应进程的应用程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/PID/cwd</span><br></pre></td></tr></table></figure><p>可以查看应用程序的绝对路径</p><h2 id="对每个日志分析"><a href="#对每个日志分析" class="headerlink" title="对每个日志分析"></a>对每个日志分析</h2><h4 id="x2F-var-x2F-log-x2F-messages"><a href="#x2F-var-x2F-log-x2F-messages" class="headerlink" title="&#x2F;var&#x2F;log&#x2F;messages"></a>&#x2F;var&#x2F;log&#x2F;messages</h4><p>messages 日志是核心系统日志文件。它包含了系统启动时的引导消息，以及系统运行时的其他状态消息。IO 错误、网络错误和其他系统错误都会记录到这个文件中。其他信息，比如某个人的身份切换为 root，也在这里列出。许多提权的行为都有可能是恶意行为。</p><p>从日志中寻找：谁(ID)，从哪里(IPaddress)，如何(Port)进来，通过什么操作非法入侵，或者确认信息是否泄漏和变更，所有这些都完全参照日志文件进行。必须清楚系统中存在哪些日志文件，哪些守护进程管理这些日志，以及它们是如何被保存下来的。基本日志由syslogd控制，通过修改syslogd的设置文件&#x2F;etc&#x2F;syslog.conf来存储位置和文件名。<code>/var/log/messages</code>文件的内容如下：</p><p><img src="C:/Users/%E9%92%9F%E5%85%88%E7%94%9F/AppData/Roaming/Typora/typora-user-images/image-20220106171552994.png" alt="image-20220106171552994"></p><p>该日志文件的意义分为月，日，时间，每个程序的名字和进程编号，用户的uid被记录下来。消息部分详细显示了生成日志时发生的事件。</p><p>在linux中，负责日志轮换制的包是logrotate。logrotate是一个旨在有效管理不断增大的文件的程序。自动运行轮换制，进行压缩、删除、发送邮件等工作。logrotate在早期linux安装时自动登录cron并周期性运行。使用linux日志文件管理工具logrotate可以完成以下操作：</p><ul><li>首先，rotate文件（如果指定的文件过期，则替换为其它文件）</li><li>第二，将日志文件压缩保存。</li><li>第三，工作时出现错误时，将状态报告给指定的邮箱地址。</li></ul><h4 id="x2F-var-x2F-log-x2F-secure"><a href="#x2F-var-x2F-log-x2F-secure" class="headerlink" title="&#x2F;var&#x2F;log&#x2F;secure"></a>&#x2F;var&#x2F;log&#x2F;secure</h4><p>一般用来记录安全相关的信息，记录最多的是哪些用户登录服务器的相关日志，如果该文件很大，说明有人在破解你的 root 密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如何进行查看: <span class="built_in">cat</span></span><br><span class="line"> 方法一: 只查看最新的信息</span><br><span class="line"> <span class="built_in">head</span> -n 文件信息     --- 查看文件前几行信息</span><br><span class="line"> <span class="built_in">tail</span> -n 文件信息     --- 查看文件后几行信息</span><br><span class="line"> <span class="built_in">tail</span> -f 文件信息     --- 实时查看日志文件最新数据内容</span><br><span class="line"> 方法二: 关注指定信息  fail(错误)   error(错误)</span><br><span class="line"> grep  <span class="string">&quot;关注信息&quot;</span>  文件 </span><br><span class="line"> -C(Center)  -B(Before)   -A(After)    -i(ignore忽视.忽略)</span><br></pre></td></tr></table></figure><p>可以分为几个字段来描述这些事件信息：</p><p>　　1. 事件的日期和时间<br>　　2. 事件的来源主机 ( 通常是写主机名 )<br>　　3. 产生这个事件的程序[进程号]<br>　　4. 实际的日志信息</p><p>该<strong>文件如果很大</strong>，说明有人在破解root密码，一般是SSH暴力破解，可以通过这个日志查到对方的IP，每次登陆，无论密码对错都会被详细记录下来。</p><h4 id="x2F-var-x2F-log-x2F-syslog"><a href="#x2F-var-x2F-log-x2F-syslog" class="headerlink" title="&#x2F;var&#x2F;log&#x2F;syslog"></a>&#x2F;var&#x2F;log&#x2F;syslog</h4><p>它和<code>/etc/log/messages</code>日志文件不同，它只记录警告信息，常常是系统出问题的信息，所以更应该关注该文件。</p><p>要让系统生成该日志文件，在&#x2F;etc&#x2F;syslog.conf文件中加上：*.warning &#x2F;var&#x2F;log&#x2F;syslog 该日志文件能记录当用户登录时login记录下的错误口令、Sendmail的问题、su命令执行失败等信息。</p><p>该日志文件记录最近成功登录的事件和最后一次不成功的登录事件，由login生成。在每次用户登录时被查询，该文件是二进制文件，需要<strong>使用lastlog命令</strong>查看，根据UID排序显示登录名、端口号和上次登录时间。如果某用户从来没有登录过，就显示为”<strong>Never logged in</strong>“。该命令只能<strong>以root权限</strong>执行。简单地输入lastlog命令后就会看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Username         Port     From             Latest</span><br><span class="line">root             pts/0    110.87.109.232   Wed Jan  5 10:34:20 +0800 2022</span><br><span class="line">bin                                        **Never logged  <span class="keyword">in</span> **</span><br><span class="line">daemon                                     **Never logged  <span class="keyword">in</span> **</span><br><span class="line">adm                                        **Never logged  <span class="keyword">in</span> **</span><br><span class="line">lp                                         **Never logged  <span class="keyword">in</span> **</span><br><span class="line"><span class="built_in">sync</span>                                       **Never logged  <span class="keyword">in</span> **</span><br><span class="line">shutdown                                   **Never logged  <span class="keyword">in</span> **</span><br><span class="line">halt                                       **Never logged  <span class="keyword">in</span> **</span><br><span class="line">mail                                       **Never logged  <span class="keyword">in</span> **</span><br><span class="line">uucp                                       **Never logged  <span class="keyword">in</span> **</span><br><span class="line">operator                                    **Never logged  <span class="keyword">in</span> **</span><br><span class="line">games                                      **Never logged  <span class="keyword">in</span> **</span><br><span class="line">gopher                                     **Never logged  <span class="keyword">in</span> **</span><br><span class="line">ftp                                        **Never logged  <span class="keyword">in</span> **</span><br><span class="line">nobody                                     **Never logged  <span class="keyword">in</span> **</span><br><span class="line">vcsa                                       **Never logged  <span class="keyword">in</span> **</span><br><span class="line">saslauth                                   **Never logged  <span class="keyword">in</span> **</span><br><span class="line">postfix                                    **Never logged  <span class="keyword">in</span> **</span><br><span class="line">sshd                                       **Never logged  <span class="keyword">in</span> **</span><br><span class="line">ntp                                        **Never logged  <span class="keyword">in</span> **</span><br><span class="line">suda             pts/2    222.79.79.120    Tue Oct 25 16:00:01 +0800 2021</span><br></pre></td></tr></table></figure><p>系统账户诸如bin、daemon、adm、uucp、mail等<strong>决不应该登录</strong>，如果发现这些账户已经登录，就说明系统可能已经被入侵了。若发现记录的时间不是用户上次登录的时间，则说明该用户的账户已经泄密了。</p><p>可以使用lastlog命令检查某特定用户上次登录的时间，并格式化输出上次登录日志&#x2F;var&#x2F;log&#x2F;lastlog的内容。它根据<strong>UID排序</strong>显示登录名、端口号和上次登录时间。如果一个用户从未登录过，lastlog显示<strong>Never logged</strong>。注意需要<strong>以root身份运行</strong>该命令。</p><h4 id="x2F-var-x2F-log-x2F-wtmp"><a href="#x2F-var-x2F-log-x2F-wtmp" class="headerlink" title="&#x2F;var&#x2F;log&#x2F;wtmp"></a>&#x2F;var&#x2F;log&#x2F;wtmp</h4><p>　　该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。因此随着系统正常运行时间的增加，该文件的大小也会越来越大，增加的速度取决于系统用户登录的次数。该日志文件可以用来查看用户的登录记录，last命令就通过访问这个文件获得这些信息，并以<strong>反序从后向前显示用户的登录记录</strong>，last也能根据用户、终端 tty或时间显示相应的记录。</p><p>who命令查询utmp文件并报告<strong>当前登录的每个用户</strong>。Who的缺省输出包括用户名、终端类型、登录日期及远程主机。使用该命令，系统管理员可以查看当前系统存在哪些不法用户，从而对其进行审计和处理。如果指明了wtmp文件名，则who命令<strong>查询所有以前的记录</strong>。命令who &#x2F;var&#x2F;log&#x2F;wtmp将报告自从wtmp文件<strong>创建或删改以来的每一次登录</strong>。</p><p>last命令往回搜索wtmp来显示自从文件第<strong>一次创建以来登录过的用户</strong>。可以周期性地对这些用户的登录情况进行审计和考核，从而发现起中存在的问题，确定不法用户。</p><p>可以通过指明用户来显示其登录信息即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last reboot</span><br></pre></td></tr></table></figure><p>显示reboot的历史登录信息。<br>last -u 102将报告UID为102的用户；last -t 7表示限制上一周的报告。</p><p>last -u 用户名 显示用户<strong>上次登录的情况</strong>。</p><p>last -t 天数 显示<strong>指定天数之前的用户登录情况</strong>。</p><p><strong>ac命令</strong>根据当前的<code>/var/log/wtmp</code>文件中的登录进入和退出来报告用户连接的时间（小时），如果不使用标志，则报告总的时间。</p><h4 id="x2F-var-x2F-run-x2F-utmp"><a href="#x2F-var-x2F-run-x2F-utmp" class="headerlink" title="&#x2F;var&#x2F;run&#x2F;utmp"></a>&#x2F;var&#x2F;run&#x2F;utmp</h4><p>　　该日志文件记录有关<strong>当前登录的每个用户的信息</strong>。因此这个文件会随着用户登录和注销系统而不断变化，它只保留当时联机的用户记录，不会为用户保留永久的记录。系统中需要查询<strong>当前用户状态的程序</strong>，如 who、w、users、finger等就需要访问这个文件。该日志文件并不能包括所有精确的信息，因为某些突发错误会终止用户登录会话，而系统没有及时更新 utmp记录，因此该日志文件的记录不是百分之百值得信赖的。</p><p>　　每次有一个用户登录时，login程序在文件lastlog中查看用户的UID。如果存在，则把用户上次登录、注销时间和主机名写到标准输出中，然后login程序在lastlog中记录新的登录时间，打开utmp文件并插入用户的utmp记录。该记录一直用到用户登录退出时删除。utmp文件被各种命令使用，包括who、w、users和finger。</p><p>　　下一步，login程序打开文件wtmp附加用户的utmp记录。当用户登录退出时，具有更新时间戳的同一utmp记录附加到文件中。wtmp文件被程序last使用。</p><h4 id="x2F-var-x2F-log-x2F-btmp"><a href="#x2F-var-x2F-log-x2F-btmp" class="headerlink" title="&#x2F;var&#x2F;log&#x2F;btmp"></a>&#x2F;var&#x2F;log&#x2F;btmp</h4><p>&#x2F;var&#x2F;log&#x2F;btmp文件是记录错误登录系统的日志。如果发现&#x2F;var&#x2F;log&#x2F;btmp日志文件比较大，大于1M，就算大了，就说明很多人在暴力破解ssh服务，此日志需要使用<code>lastb</code>查看。</p><h2 id="可能出现的一些恶意行为"><a href="#可能出现的一些恶意行为" class="headerlink" title="可能出现的一些恶意行为"></a>可能出现的一些恶意行为</h2><h4 id="iptables被关闭"><a href="#iptables被关闭" class="headerlink" title="iptables被关闭"></a>iptables被关闭</h4><p>攻击者登录以后先关闭iptables再进行高危操作：</p><p>在<code>/var/log/messages</code>日志中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stopping IPv4 firewall with iptables...</span><br></pre></td></tr></table></figure><p>在查看日志时，发现在某个时间，系统的iptables被关闭或者被永久禁止。</p><h4 id="权限重置"><a href="#权限重置" class="headerlink" title="权限重置"></a>权限重置</h4><p>攻击者登录服务器后对文件或者对文件夹更改原有的权限，通过提权获得管理员权限达到窃取机密数据等目的：</p><p>修改&#x2F;etc&#x2F;profile文件，将操作日志输出到文件中，进行查看分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/root <span class="built_in">command</span>: <span class="built_in">chmod</span> -R 755 <span class="built_in">test</span></span><br><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/root <span class="built_in">command</span>: <span class="built_in">chown</span> hopeful.root JZZS/</span><br></pre></td></tr></table></figure><p>查看系统日志，发现某时间内某个文件或文件夹原有的权限发生了修改</p><h4 id="用户增删改"><a href="#用户增删改" class="headerlink" title="用户增删改"></a>用户增删改</h4><p>系统中新增用户、删除用户、修改已有用户等也是高危行为：</p><p>&#x2F;var&#x2F;log&#x2F;secure日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/root <span class="built_in">command</span>: useradd test1</span><br><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/root <span class="built_in">command</span>: usermod -G hopeful</span><br><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/root <span class="built_in">command</span>: userdel <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>查看系统日志，有新增用户、修改用户权限、删除相应用户的行为。</p><h4 id="指定目录创建、删除、修改文件"><a href="#指定目录创建、删除、修改文件" class="headerlink" title="指定目录创建、删除、修改文件"></a>指定目录创建、删除、修改文件</h4><p>在指定的目录中，攻击者进行了创建、修改、删除文件的操作，可能会造成数据的泄露或者被篡改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/home <span class="built_in">command</span>: <span class="built_in">touch</span> quail</span><br><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/home <span class="built_in">command</span>: vi quail</span><br><span class="line">root: turbo user=root client=192.168.1.190 61629 22 path=/home <span class="built_in">command</span>: <span class="built_in">rm</span> -rf quail</span><br></pre></td></tr></table></figure><p>在某个时间，查看系统日志，通过原始日志中的命令操作touch、vi、rm，以及<strong>在home目录下</strong>进行的操作，属于危险的操作行为。</p><h4 id="linux用户su至root多次失败"><a href="#linux用户su至root多次失败" class="headerlink" title="linux用户su至root多次失败"></a>linux用户su至root多次失败</h4><p>攻击者获取账号后，通过su的方式获得root权限：</p><p>&#x2F;var&#x2F;log&#x2F;secure日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hopeful-01 su: FAILED SU (to root) hopeful on pts/1</span><br><span class="line">hopeful-01 su: FAILED SU (to root) hopeful on pts/1</span><br></pre></td></tr></table></figure><p>通过原始日志中的su行为，并且多次都是FAILED</p><h4 id="Linux用户组-x2F-密码重置"><a href="#Linux用户组-x2F-密码重置" class="headerlink" title="Linux用户组&#x2F;密码重置"></a>Linux用户组&#x2F;密码重置</h4><p>系统中的每一个用户组都是用一个唯一的身份组标识GID，如果非正常授权修改Linux用户组或密码，则可能被攻击者修改并控制：</p><p>若攻击者修改&#x2F;etc&#x2F;group或&#x2F;etc&#x2F;passwd：</p><p>&#x2F;var&#x2F;log&#x2F;secure：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 54471 22 path=/root <span class="built_in">command</span>: vi /etc/passwd secislog</span><br><span class="line">root: turbo user=root client=192.168.1.190 54471 22 path=/root <span class="built_in">command</span>: vi /etc/group secislog</span><br></pre></td></tr></table></figure><p>查找到有修改group或者passwd文件的命令，且后面还有一些危险指令，则有可能遭遇入侵。</p><h4 id="账户提权"><a href="#账户提权" class="headerlink" title="账户提权"></a>账户提权</h4><p>利用某些特殊方法而得到目标系统更高的权限：分析出存在修改sudoers文件行为，以及对提权账号的操作记录进行追踪和记录。</p><p>&#x2F;var&#x2F;log&#x2F;secure：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 60200 22 path=/etc <span class="built_in">command</span>: vi /etc/sudoers secislog</span><br><span class="line">root: turbo user=root client=192.168.1.190 60200 22 path=/etc <span class="built_in">command</span>: visudo secislog</span><br></pre></td></tr></table></figure><p>存在修改sudoers文件行为，修改后提权账户成功使用超级用户的命令。同时对一定时间内的提权账户操作行为进行追踪和判断，是否存在账户高危操作和修改审计日志行为。存在相关后续操作行为，判定账户异常。</p><h4 id="账号短时间内创建删除"><a href="#账号短时间内创建删除" class="headerlink" title="账号短时间内创建删除"></a>账号短时间内创建删除</h4><p>攻击者或内部员工，拥有新增删除用户权限。进行账号创建与删除操作。</p><p>&#x2F;var&#x2F;log&#x2F;secure：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 55538 22 path=/root <span class="built_in">command</span>: userdel -r wdsg3 secislog</span><br><span class="line">root: turbo user=root client=192.168.1.190 55538 22 path=/root <span class="built_in">command</span>: useradd wdsg3 secislog</span><br></pre></td></tr></table></figure><p>日志中得知有创建用户和删除账号的行为，但创建账号后删除账号在较短的时间内删除。</p><h4 id="删除、修改、移动审查日志"><a href="#删除、修改、移动审查日志" class="headerlink" title="删除、修改、移动审查日志"></a>删除、修改、移动审查日志</h4><p>&#x2F;var&#x2F;log&#x2F;secure：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 55905 22 path=/root <span class="built_in">command</span>: vi /var/log/messages secislog</span><br></pre></td></tr></table></figure><p>查找到有修改系统重要日志文件的操作，且通过对修改日志文件前的操作命令进行追踪。分析操作记录和修改的日志文件进行对比，来进行排查。</p><h4 id="主机开启大量监听端口"><a href="#主机开启大量监听端口" class="headerlink" title="主机开启大量监听端口"></a>主机开启大量监听端口</h4><p>攻击者可以通过nc命令开启大量监听端口：</p><p>&#x2F;etc&#x2F;profile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root: turbo user=root client=192.168.1.190 50234 22 path=/root <span class="built_in">command</span>: nc -l 12342 &amp; secilog</span><br><span class="line">root: turbo user=root client=192.168.1.190 50234 22 path=/root <span class="built_in">command</span>: nc -l 12343 &amp; secilog</span><br><span class="line">root: turbo user=root client=192.168.1.190 50234 22 path=/root <span class="built_in">command</span>: nc -l 12344 &amp; secilog</span><br></pre></td></tr></table></figure><p>通过对系统原始日志进行分析中有多次使用nc命令开启端口的行为或者通过防火墙开启大量端口，此时应当对开放的端口进行排查。</p><p>可以<strong>在 netstat 输出中显示 PID 和进程名称</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -p</span><br></pre></td></tr></table></figure><h2 id="用Shell日志分析"><a href="#用Shell日志分析" class="headerlink" title="用Shell日志分析"></a>用Shell日志分析</h2><h4 id="IP分析"><a href="#IP分析" class="headerlink" title="IP分析"></a>IP分析</h4><ul><li><p>当天访问次数最多的IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d- -f 1 /usr/local/apache2/logs/access_log |uniq -c | sort -rn | head -20</span><br></pre></td></tr></table></figure></li><li><p>查看当天有多少个IP访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; log_file|sort|uniq|wc -l</span><br></pre></td></tr></table></figure></li><li><p>查看每一个IP访问了多少页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#x27; log_file</span><br></pre></td></tr></table></figure></li><li><p>查看某一个IP访问了哪些页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^111.111.111.111 log_file| awk &#x27;&#123;print $1,$7&#125;&#x27;</span><br></pre></td></tr></table></figure></li></ul><h4 id="ERROR日志"><a href="#ERROR日志" class="headerlink" title="ERROR日志"></a>ERROR日志</h4><ul><li>记录的时间范围：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut -f 4 -d &#x27; &#x27; /var/log/apache2/error.log| cut -f 1 -d &#x27;:&#x27; |head -1|tr -d [</span><br><span class="line">cut -f 4 -d &#x27; &#x27; /var/log/apache2/error.log| cut -f 1 -d &#x27;:&#x27; |tail -1|tr -d [</span><br></pre></td></tr></table></figure><ul><li>错误记录：（检查注册表中错误项的数量）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/apache2/error.log |wc -l</span><br></pre></td></tr></table></figure><ul><li>数量和类型：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/apache2/error.log |cut -f 3 -d &#x27;[&#x27;|sort|uniq -c|sort -g|tr -d ]</span><br></pre></td></tr></table></figure><ul><li>重复次数错误&#x2F;警告:（检查重复次数是否过多）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/apache2/error.log|cut -f 4 -d &#x27;]&#x27;|sort|uniq -c|sort -g|tail -1</span><br></pre></td></tr></table></figure><ul><li>导致最多错误的ip地址和此ip引发的错误：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client=$(cat /var/log/apache2/error.log|cut -f 4 -d &#x27;[&#x27;|cut -f 1 -d &#x27;]&#x27;|sort|uniq -c|sort -g|tail -1|cut -f 6 -d &#x27; &#x27;)</span><br><span class="line">grep $client /var/log/apache2/error.log |cut -f 4 -d &#x27;]&#x27;|sort| uniq</span><br></pre></td></tr></table></figure><ul><li><p>错误日志最多的IP地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/apache2/error.log|cut -f 4 -d &#x27;[&#x27;|cut -f 1 -d &#x27;]&#x27;|sort|uniq -c|sort -g|grep -v &#x27;sh&#x27;|tail -10|tr -s &#x27; &#x27; &#x27; &#x27;|cut -f 4 -d &#x27; &#x27;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对Linux日志的基本分析以及对一些可能出现的恶意行为的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="恶意代码分析" scheme="http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="恶意代码" scheme="http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="Log" scheme="http://example.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://example.com/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-03T11:18:17.000Z</published>
    <updated>2022-03-03T11:24:06.608Z</updated>
    
    <content type="html"><![CDATA[<p>Linux的一些简单常用命令总结。</p><span id="more"></span><h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><hr><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p><code>man</code> 是Linux的帮助手册，即<code>manual</code></p><p><code>man ls</code> 有关<code>ls</code> 的帮助</p><p><code>man -f ls</code> 看看有多少同名手册</p><p><code>man lp ls</code> 查看特定的lp ls手册</p><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p><code>info program</code> 获得特定程序的帮助</p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>获得比较基础有用的帮助</p><p><code>man --help</code> 获取man的帮助</p><h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><ul><li>up可以调出输入的历史执行记录</li><li>down配合up选择历史记录</li><li>Home移动光标到本行开头</li><li>End移动光标到本行结尾</li><li>PgUp向上翻页</li><li>PgDN向下翻页</li><li>ctrl+c终止当前程序</li></ul><h2 id="Tab"><a href="#Tab" class="headerlink" title="Tab"></a>Tab</h2><p>Tab补全可自动补全命令或文件名</p><ul><li>未输入状态下连按两次Tab可以调出所有可用命令</li><li>已输入部分命令名或文件名，按Tab自动补全</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>打开某个路径，也就是打开某个文件夹，并跳转到该处</p><p><code>cd path</code> 其中的path有绝对路径和相对路径之分，绝对路径强调从 <code>/</code> 起，一直到所在路径。相对路径则相对于当前路径来说，假设当前目录有<code>etc</code> 文件夹（绝对路径应为 <code>/home/username/etc</code>），如果直接 <code>cd etc</code> 则进入此文件夹，但若是 <code>cd /etc/</code> 则是进入系统 <code>etc</code> ，多琢磨一下就可以理解了。另外在 Linux 中， <code>.</code> 代表当前目录， <code>..</code> 代表上级目录，因此返回上级目录可以 <code>cd ..</code> </p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>list，即列出文件</p><p><code>ls</code> 列出当前目录可见文件</p><p><code>ls -l</code> 列出当前目录可见文件详细信息</p><p><code>ls -hl</code> 列出详细信息并以可读大小显示文件大小</p><p><code>ls -al</code> 列出所有文件<strong>（包括隐藏）</strong>的详细信息</p><p>注：以<code>.</code>开头的文件或文件夹均为隐藏文件或隐藏文件夹</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>用于返回当前工作目录的名字，为绝对路径名</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><code>mkdir folder</code></p><p><code>mkdir -p folder/subfolder</code> -p参数为当父目录存在时忽略，若不存在则建立，用此参数可以建立多层文件夹</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>即remove，删除文件</p><p><code>rm filename</code> 删除filename</p><p><code>rm -i filename</code> 删除filename前提示</p><p><code>rm -rf folder/subfolder</code> 递归删除subfolder下所有文件及文件夹，包括subfolder本身</p><p><code>rm -d folder</code> 删除空文件夹</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>即copy，复制文件</p><p><code>cp source dest</code> 将source复制到dest</p><p><code>cp folder/* dest</code> 将folder下所有文件（不包含子文件夹）中的文件复制到dest</p><p><code>cp -r folder dest</code> 将folder下所有文件（包含子文件夹中的所有文件）复制到dest</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>即move，移动文件</p><p><code>mv source folder</code> 将source<strong>移动</strong>到folder下，完成后为folder&#x2F;source</p><p><code>mv -i source folder</code> 在移动时，若文件已存在，则提示是否覆盖</p><p><code>mv source dest</code> 在dest不为目录的前提下，<strong>重命名</strong>source为dest</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>用于输出文件内容到Terminal</p><p><code>cat /etc/locale.gen</code> 输出locale.gen的内容</p><p><code>cat -n/etc/locale.gen</code> 输出locale.gen的内容并显示行号</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p><code>more</code> 与<code>cat</code>相似，都可以查看文件的内容，不同的是，当文档较长时，<code>cat</code> 只能展示最后布满屏幕的内容，前面的内容要用<code>more</code>逐行显示</p><p><code>more /etc/locale.gen</code> 显示locale.gen内容</p><p><code>more +100 /etc/locale.gen</code> 从100行开始显示</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p><code>less</code>与<code>more</code>相似，但是<code>less</code>支持上下滚动查看，而<code>more</code> 只支持逐行显示</p><p><code>less /etc/locale.gen</code></p><p><code>less +100 /etc/locale.gen</code></p><h3 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h3><p>是一个简单实用的文本编辑器，使用简单</p><p><code>nano filename</code> 编辑filename文件，如果不存在，则打开一个新文件，若退出时保存，则创建该文件</p><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>重启命令</p><p><code>reboot</code> 需要root用户或者普通用户使用<code>sudo</code>才能执行</p><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p><code>poweroff</code> 需要root用户或者普通用户使用<code>sudo</code>才能执行</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>用于测试网络连通，通过对目标机器发送数据包来测试两台主机是否连通，及延时情况</p><p><code>ping locez.com</code></p><p><code>ping 211.157.2.94</code> 通过ip地址ping</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>用于返回匹配的项目，支持正则表达式</p><p><code>grep PATTERM filename</code>     返回所有含PATTERN的行</p><p><code>grep zh_CN /etc/locale.gen</code> 返回所有含zh_CN的行</p><h3 id="mount-x2F-umount"><a href="#mount-x2F-umount" class="headerlink" title="mount&#x2F;umount"></a>mount&#x2F;umount</h3><p><code>mount</code>用于挂载一个文件系统，需要root用户执行，一个磁盘可分为若干个分区，在分区上面可以创建文件系统，而挂载点则是提供一个访问的入口，将一个分区的文件系统挂载到某个目录中，称这个目录为挂载点，并且可以通过这个挂载点访问该文件系统中的内容</p><p>例如一块硬盘在 Linux 中表示为 <code>/dev/sda</code> 那么它上面的分区应该表示为 <code>/dev/sda1</code> 、<code>/dev/sda2</code></p><p>则</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mount                       <span class="comment">### 输出系统目前的挂载信息</span></span><br><span class="line">mount /dev/sda1 /mnt        <span class="comment">### 将 sda1 挂载到 /mnt 中</span></span><br><span class="line"><span class="built_in">cd</span> /mnt                     <span class="comment">### 直接通过 /mnt 访问内容</span></span><br><span class="line">mount -o remount,rw  /mnt   <span class="comment">### 重新挂载 sda1 到 /mnt 并设置为 可读写 </span></span><br><span class="line">mount -a                    <span class="comment">### 挂载 fstab 文件配置好的文件系统</span></span><br><span class="line">umount /mnt                 <span class="comment">### 卸载 /mnt 这个挂载点的文件系统</span></span><br><span class="line">umount -a                   <span class="comment">### 卸载所有已挂载的文件系统 </span></span><br></pre></td></tr></table></figure><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>用于创建归档文件和解压归档文件，其本身是没有压缩功能的，但可以调用 <code>gzip</code> 、 <code>bzip2</code> 进行压缩处理。参数解释：</p><ul><li><code>-c</code> 创建归档</li><li><code>-x</code> 解压归档</li><li><code>-v</code> 显示处理过程</li><li><code>-f</code> 目标文件，其后必须紧跟 目标文件</li><li><code>-j</code> 调用 <code>bzip2</code> 进行解压缩</li><li><code>-z</code> 调用 <code>gzip</code> 进行解压缩</li><li><code>-t</code> 列出归档中的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf filename.tar .       <span class="comment">### 将当前目录所有文件归档，但不压缩，注意后面有个 &#x27;.&#x27; 不可省略，代表当前目录的意思 </span></span><br><span class="line">$ tar -xvf filename.tar         <span class="comment">### 解压 filename.tar 到当前文件夹</span></span><br><span class="line">$ tar -cvjf filename.tar.bz2 .  <span class="comment">### 使用 bzip2 压缩</span></span><br><span class="line">$ tar -xvjf  filename.tar.bz2   <span class="comment">### 解压 filename.tar.bz2 到当前文件夹</span></span><br><span class="line">$ tar -cvzf filename.tar.gz     <span class="comment">### 使用 gzip  压缩</span></span><br><span class="line">$ tar -xvzf filename.tar.gz     <span class="comment">### 解压 filename.tar.gz 到当前文件夹</span></span><br><span class="line">$ tar -tf   filename            <span class="comment">### 只查看 filename 归档中的文件，不解压</span></span><br></pre></td></tr></table></figure><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>ln用于在两个文件中创建链接，链接又分为Hard Links和Symbolic Links（符号链接&#x2F;软链接），其中默认为创建Hard Links，使用<code>-s</code> 参数指定创建软链接</p><ul><li>硬链接主要是增加一个文件的链接数，只要该文件的链接数不为 <code>0</code> ，该文件就不会被物理删除，所以<strong>删除一个具有多个硬链接数的文件，必须删除所有它的硬链接才可删除</strong>。</li><li>软链接简单来说是为文件创建了一个类似<strong>快捷方式</strong>的东西，通过该链接可以访问文件，修改文件，但不会增加该文件的链接数，删除一个软链接并不会删除源文件，即使源文件被删除，软链接也存在，当重新创建一个同名的源文件，该软链接则指向新创建的文件。</li><li>硬链接只可链接两个文件，不可链接目录，而软链接可链接目录，所以软链接是非常灵活的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> <span class="built_in">source</span> dest<span class="comment">#硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="built_in">source</span> dest <span class="comment">#软连接</span></span><br></pre></td></tr></table></figure><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>用于改变一个文件的所有者及所在的组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user filename<span class="comment">#改变Filename的所有者为user</span></span><br><span class="line"><span class="built_in">chown</span> user:group filename<span class="comment">#改变filename的所有者为user，组为group</span></span><br><span class="line"><span class="built_in">chown</span> -R root folder<span class="comment">#改变folder文件及其子文件的所有者为root</span></span><br></pre></td></tr></table></figure><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>永远改变一个文件的权限，主要有读取、写入、执行三种权限，其中所有者、用户组、其他各占三个</p><p>r&#x3D;read w&#x3D;write x&#x3D;execute</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x filename<span class="comment">#为user，group，others添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> -x filename        <span class="comment">#取消 user ， group ，others 的执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +w filename        <span class="comment">#为 user 添加写入权限</span></span><br><span class="line"><span class="built_in">chmod</span> ugo=rwx filename   <span class="comment">#设置 user ，group ，others 具有 读取、写入、执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> ug=rw filename     <span class="comment">#设置 user ，group 添加 读取、写入权限</span></span><br><span class="line"><span class="built_in">chmod</span> ugo=--- filename   <span class="comment">#取消所有权限</span></span><br></pre></td></tr></table></figure><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加一个普通用户</p><p><code>useradd -m -g users -G audio -s /usr/bin/bash newuser</code></p><p>-m创建home目录，-g所属的主组，-G指定该用户在哪些附加组，-s设定默认的shell，newuser为新用户名</p><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>改变用户登录密码</p><p><code>passwd</code>    不带参数更改当前用户密码</p><p><code>passwd newuser</code>  更改上述新建的newuser的用户密码</p><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>用于查找文件、手册等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis bash </span><br><span class="line">whereis -b bash       <span class="comment">### 仅查找 binary</span></span><br><span class="line">whereis -m bash       <span class="comment">### 仅查找 manual</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于查找文件，但更为强大，支持正则，并且可以将查找结果传递到其他命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name PATTERN    <span class="comment">### 从当前目录查找符合 PATTERN 的文件</span></span><br><span class="line">$ find /home -name PATTERN -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;  <span class="comment"># 从 /home 文件查找所有符合 PATTERN 的文件，并交由 ls 输出详细信息</span></span><br></pre></td></tr></table></figure><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>一个下载工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O newname.md https://github.com/LCTT/TranslateProject/blob/master/README.md     <span class="comment">### 下载 README 文件并重命名为 newname.md</span></span><br><span class="line">wget -c url     <span class="comment">### 下载 url 并开启断点续传</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux的一些简单常用命令总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>解决Github无法访问的问题</title>
    <link href="http://example.com/Debug/%E8%A7%A3%E5%86%B3Github%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/Debug/%E8%A7%A3%E5%86%B3Github%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-03T11:13:45.000Z</published>
    <updated>2022-03-03T11:16:36.010Z</updated>
    
    <content type="html"><![CDATA[<p>通过手动配置DNS来加速国内Github的访问。</p><span id="more"></span><h3 id="解决Github无法访问问题"><a href="#解决Github无法访问问题" class="headerlink" title="解决Github无法访问问题"></a>解决Github无法访问问题</h3><p>国内Github访问速度较慢，原因可能是被墙了，DNS解析不出来，这时我们可以手动添加DNS解析：</p><ul><li><p>在<code>C:\Windows\System32\drivers\etc</code>找到hosts文件</p></li><li><p>将hosts文件拖到桌面</p></li><li><p>在<a href="https://www.ipaddress.com/">IP Adress</a>查找对应域名的ip地址（如果查找到多个，可以多个都写，更加稳定）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">140.82.114.4 github.com</span><br><span class="line">140.82.113.3 gist.GitHub.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br><span class="line">185.199.108.153 raw.githubusercontent.com</span><br><span class="line">185.199.109.153 raw.githubusercontent.com</span><br><span class="line">185.199.110.153 raw.githubusercontent.com</span><br><span class="line">185.199.111.153 raw.githubusercontent.com</span><br><span class="line">185.199.108.153 gist.githubusercontent.com</span><br><span class="line">185.199.109.153 gist.githubusercontent.com</span><br><span class="line">185.199.110.153 gist.githubusercontent.com</span><br><span class="line">185.199.111.153 gist.githubusercontent.com</span><br><span class="line">185.199.108.153 cloud.githubusercontent.com</span><br><span class="line">185.199.109.153 cloud.githubusercontent.com</span><br><span class="line">185.199.110.153 cloud.githubusercontent.com</span><br><span class="line">185.199.111.153 cloud.githubusercontent.com</span><br><span class="line">185.199.108.153 camo.githubusercontent.com</span><br><span class="line">185.199.109.153 camo.githubusercontent.com</span><br><span class="line">185.199.110.153 camo.githubusercontent.com</span><br><span class="line">185.199.111.153 camo.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars0.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars0.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars0.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars0.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars1.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars1.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars1.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars1.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars2.githubusercontent.com </span><br><span class="line">185.199.109.153 avatars2.githubusercontent.com </span><br><span class="line">185.199.110.153 avatars2.githubusercontent.com </span><br><span class="line">185.199.111.153 avatars2.githubusercontent.com </span><br><span class="line">185.199.108.153 avatars3.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars3.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars3.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars3.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars4.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars4.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars4.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars4.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars5.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars5.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars5.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars5.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars6.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars6.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars6.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars6.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars7.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars7.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars7.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars7.githubusercontent.com</span><br><span class="line">185.199.108.153 avatars8.githubusercontent.com</span><br><span class="line">185.199.109.153 avatars8.githubusercontent.com</span><br><span class="line">185.199.110.153 avatars8.githubusercontent.com</span><br><span class="line">185.199.111.153 avatars8.githubusercontent.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.114.6 api.github.com</span><br><span class="line">140.82.113.4 www.github.com</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这些ip地址可能经常会变，如果有一天进不去了可能需要重新去查ip地址然后更新！！</p></li><li><p>将这些DNS加到hosts文件最后面并保存，然后拖到刚刚的<code>etc</code>文件夹中</p></li><li><p><code>win+R</code>打开<code>cmd</code>，输入<code>ipconfig/flushdns</code>刷新DNS缓存，再重新进入Github可以很快地访问了</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过手动配置DNS来加速国内Github的访问。&lt;/p&gt;</summary>
    
    
    
    <category term="Debug" scheme="http://example.com/categories/Debug/"/>
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>宽字节注入</title>
    <link href="http://example.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</id>
    <published>2022-03-03T11:10:38.000Z</published>
    <updated>2022-03-03T11:12:32.076Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍魔术引号，宽字节及其注入。</p><span id="more"></span><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><h2 id="魔术引号"><a href="#魔术引号" class="headerlink" title="魔术引号"></a>魔术引号</h2><p><code>magic_quotes_gpc（魔术引号开关）</code></p><p>magic_quotes_gpc函数在php中的作用是判断解析用户提交的数据，如包括有：post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。</p><p>单引号（’）、双引号（”）、反斜线（\）等字符都会被自动加上反斜线</p><p>SQL的第一步是闭合</p><p>魔术引号&#x3D;&gt;防止闭合</p><p>在PHP5.4以下 存在<br>PHP5.4及其以上魔术引号是被删除了<br>高版本加上<code>addslashes()</code>函数，就相当与魔术引号</p><p>基本上所有网站都会用魔术引号</p><p>绕过魔术引号：</p><p>1.找不需要闭合的地方<br>    select*from news where id&#x3D;1</p><p>​    库名 &#x3D;&gt; table_schema&#x3D;’error’</p><p>2.仔细研究作用域（Head）</p><p>通过head传参可以绕过</p><p>3.宽字节</p><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>字符编码：</p><p>尽管现在呼吁所有的程序都使用unicode编码，所有的网站都使用utf-8编码，来一个统一的国际规范。但仍然有很多，包括国内及国外（特别是非英语国家）的一些cms，仍然使用着自己国家的一套编码，比如我国的gbk、gb2312，作为自己默认的编码类型。也有一些cms为了考虑老用户，推出了gbk和utf-8两个版本（例如:dedecms）。</p><p>GBK全称《汉字内码扩展规范》,gbk是一种多字符编码。他使用了双字节编码方案，因为双字节编码所以gbk编码汉字，占用2个字节（2个16进制）。一个utf-8编码的汉字，占用3个字节。我们可以通过输出来验证这句话。</p><h2 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h2><p>多字节编码的东西</p><p>魔术引号： <code>\</code>&#x3D;&gt;一个字符</p><p>x+<code>\</code>&#x3D;&gt; 让其构成汉字，使魔术引号失效</p><p>GBK可以宽字节，但是UTF-8不可以</p><p>确定是什么编码？直接加宽字节去测试，看能不能用</p><p>旧网站cms存在gbk的可能性更大</p><p><code>%df</code> 与魔术引号自动添加的<code>\</code>就能组成汉字</p><p>也可以用sqlmap来跑宽字节，但是效果不是太好,最好不用（可以帮助其闭合，跑得更准确）</p><p>%df &#x3D;&gt; URL编码 &#x3D;&gt; POST是不接受URL解码<br>    1、抓包改Hex<br>    2、<strong>传汉字</strong></p><p>汉 &#x3D;&gt; UTF-8 &#x3D;&gt; 3个字符<br>    3个字符+ \ &#x3D;&gt; 4个字符 &#x3D;&gt; 2个汉字</p><p>使用GBK的是数据库，当前页面的编码不重要</p><p>GBK不是唯一一个宽字节（非万国，非英文都可能存在宽字节）</p><blockquote><p>参数：–technique</p><p>这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。</p><p>支持的探测方式如下：</p><p>B: Boolean-based blind SQL injection（布尔型注入）<br>E: Error-based SQL injection（报错型注入）<br>U: UNION query SQL injection（可联合查询注入）<br>S: Stacked queries SQL injection（可多语句查询注入）<br>T: Time-based blind SQL injection（基于时间延迟注入）</p><p><code>--technique B</code></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍魔术引号，宽字节及其注入。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="渗透测试" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="SQL注入" scheme="http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
    <category term="字符编码" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>盲注</title>
    <link href="http://example.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%9B%B2%E6%B3%A8/"/>
    <id>http://example.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%9B%B2%E6%B3%A8/</id>
    <published>2022-03-03T11:08:41.000Z</published>
    <updated>2022-03-03T11:09:55.981Z</updated>
    
    <content type="html"><![CDATA[<p>盲注对应的是SQL注入中的显错注入&#x2F;报错注入，有布尔型盲注和时间型盲注。</p><span id="more"></span><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>盲注对应的是显错注入&#x2F;报错注入。</p><p>盲注：页面毫无回显，但是我们可以判断出我们想要的数据。</p><p>如果没有回显点，并且报错注入不能使用就要用盲注。</p><p>分为两种：布尔型盲注&#x2F;时间型盲注</p><p>布尔型盲注：返回0&#x2F;1（有结果或没有结果）</p><p>时间型盲注：无论<code>1=1</code> <code>1=2</code> 都返回正常，藏得很深，依靠时间差<code>sleep()</code> </p><h2 id="盲注所需函数"><a href="#盲注所需函数" class="headerlink" title="盲注所需函数"></a>盲注所需函数</h2><h3 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h3><p><code>length()</code> 返回字符串长度内容</p><p><code>substr()</code> 截取字符串,即把字符串分开 （语法:<code>SUBSTR(str,pos,len)</code>）pos:从哪里开始截,len:截取的长度</p><p> <code>select*from duomi_admin where id=1 and substr(database(),1,1)=&#39;a&#39;</code> </p><p>首先要保证<code>and</code> 的前半部分要有数据返回</p><p>其次，只有后面这个字符正确才会返回，然后一个一个字符查询……</p><p>太慢了怎么办？</p><ul><li>数字是可以进行比较的（可以用二分法来进行判断）</li><li>字母无法比较&#x3D;&gt;转化成ascii码<code>ascii(substr(database(),3,1))&gt;110</code> 然后用二分法判断</li><li>用burp直接跑数据（如果要更快则跑双包等）</li></ul><p>查表：</p><p><code>length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;1</code></p><p>sql也可以跑盲注</p><h3 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h3><p><code>A条件 and b条件(sleep())</code> 要保证A条件成立，如果不成立则不会执行b条件</p><p>select*from news where id&#x3D;1 or sleep(10);<br>1   不延时<br>2    10秒<br>3    10秒<br>4    10秒 &#x3D;&gt; 30秒<br>延时说明：他有注入 &#x3D;&gt;（库名、表名、字段名）?</p><p>if(expr1,expr2,expr3) 判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</p><p><code>select if(length(database())&gt;3,sleep(3),1)</code> </p><p>也可用sqlmap来跑</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;盲注对应的是SQL注入中的显错注入&amp;#x2F;报错注入，有布尔型盲注和时间型盲注。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="渗透测试" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="SQL注入" scheme="http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
